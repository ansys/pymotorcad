[
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadFEAResult",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadFEAResult.html#loadfearesult",
        "title": "LoadFEAResult",
        "section": "LoadFEAResult",
        "text": "Deprecated function. Replaced by MotorCAD.load_fea_result()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.magnet_polarity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.magnet_polarity.html#magnet_polarity",
        "title": "magnet_polarity",
        "section": "magnet_polarity",
        "text": "Polarity of the magnet."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetTemperatureGraphPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetTemperatureGraphPoint.html#gettemperaturegraphpoint",
        "title": "GetTemperatureGraphPoint",
        "section": "GetTemperatureGraphPoint",
        "text": "Deprecated function. Replaced by MotorCAD.get_temperature_graph_point()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_power_source_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_power_source_value.html#set_power_source_value",
        "title": "set_power_source_value",
        "section": "set_power_source_value",
        "text": "Set or create a power source."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.remove",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.remove.html#remove",
        "title": "remove",
        "section": "remove",
        "text": "Remove first occurrence of value.\nRaises ValueError if the value is not present."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.midpoint",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.midpoint.html#midpoint",
        "title": "midpoint",
        "section": "midpoint",
        "text": "Get midpoint of Line."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.motorcad_instance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.motorcad_instance.html#motorcad_instance",
        "title": "motorcad_instance",
        "section": "motorcad_instance",
        "text": "Get linked Motor-CAD instance."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.update",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.update.html#update",
        "title": "update",
        "section": "update",
        "text": "Update class fields from another region.\nMotor-CAD region object"
    },
    {
        "objectID": "sg_execution_times",
        "href": "sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "26:43.325 total execution time for 16 files from all galleries:\nExample\nTime\nMem (MB)\nsphx_glr_examples_links_ece_export_for_twinbuilder.py (..\\..\\examples\\links\\ece_export_for_twinbuilder.py)\n09:16.291\n0.0\nsphx_glr_examples_internal_scripting_thermal_transient.py (..\\..\\examples\\internal_scripting\\thermal_transient.py)\n03:25.675\n0.0\nsphx_glr_examples_advanced_force_extraction.py (..\\..\\examples\\advanced\\force_extraction.py)\n02:42.315\n0.0\nsphx_glr_examples_basics_lab_basics.py (..\\..\\examples\\basics\\lab_basics.py)\n01:51.549\n0.0\nsphx_glr_examples_internal_scripting_mechanical_force.py (..\\..\\examples\\internal_scripting\\mechanical_force.py)\n01:50.533\n0.0\nsphx_glr_examples_basics_emag_basics.py (..\\..\\examples\\basics\\emag_basics.py)\n01:06.501\n0.0\nsphx_glr_examples_basics_thermal_basics.py (..\\..\\examples\\basics\\thermal_basics.py)\n01:06.298\n0.0\nsphx_glr_examples_adaptive_library_BezierCurveRotorPockets.py (..\\..\\examples\\adaptive_library\\BezierCurveRotorPockets.py)\n00:57.142\n0.0\nsphx_glr_examples_adaptive_library_TrapezoidalDuct.py (..\\..\\examples\\adaptive_library\\TrapezoidalDuct.py)\n00:51.142\n0.0\nsphx_glr_examples_adaptive_library_DXFImport.py (..\\..\\examples\\adaptive_library\\DXFImport.py)\n00:39.673\n0.0\nsphx_glr_examples_adaptive_library_OblongStatorDuct.py (..\\..\\examples\\adaptive_library\\OblongStatorDuct.py)\n00:34.844\n0.0\nsphx_glr_examples_adaptive_library_UShapeSYNCRELCurvedFluxBarriers.py (..\\..\\examples\\adaptive_library\\UShapeSYNCRELCurvedFluxBarriers.py)\n00:29.813\n0.0\nsphx_glr_examples_internal_scripting_mechanical_stress.py (..\\..\\examples\\internal_scripting\\mechanical_stress.py)\n00:28.797\n0.0\nsphx_glr_examples_internal_scripting_thermal_steady_state.py (..\\..\\examples\\internal_scripting\\thermal_steady_state.py)\n00:28.750\n0.0\nsphx_glr_examples_adaptive_library_BPMTriangularRotorNotches.py (..\\..\\examples\\adaptive_library\\BPMTriangularRotorNotches.py)\n00:28.157\n0.0\nsphx_glr_examples_internal_scripting_emag.py (..\\..\\examples\\internal_scripting\\emag.py)\n00:25.844\n0.0"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.edit_point",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.edit_point.html#edit_point",
        "title": "edit_point",
        "section": "edit_point",
        "text": "Edit a point in the region and update entities.\nPosition of point to edit\nPosition to move the point to"
    },
    {
        "objectID": "index",
        "href": "index.html#pymotorcad-documentation-065",
        "title": "PyMotorCAD documentation 0.6.5",
        "section": "PyMotorCAD documentation 0.6.5",
        "text": "Ansys Motor-CAD is a dedicated design and analysis tool for electric motors.\nIt enables rapid and accurate multiphysics design and analysis of electric\nmachines across the full operating spectrum.\nToday’s electric motor design requires multiphysics analysis across wide\ntorque and speed operating ranges to accommodate rapid development cycles and\nsystem integration. Motor-CAD facilitates this cutting-edge design approach\nby providing:\nIntuitive, template-based setups for fast initial electric machine designs\nBuilt-in electromagnetic, thermal, and mechanical solvers for multiphysics insights\nRapid analysis of efficiency maps, torque and speed characteristics, and drive cycles\nQuick evaluation of motor topologies and concepts to produce designs that are\noptimized for size, performance. and efficiency\nPyMotorCAD is part of the PyAnsys ecosystem\nthat facilitates the use of Motor-CAD within a Python environment in\nconjunction with other PyAnsys libraries and external Python libraries.\nPyMotorCAD uses a Python JSON-RPC (remote procedure call) interface for\nMotor-CAD to launch or connect with a Motor-CAD instance, either locally or\nfrom a remote machine via HTTP.\nPyMotorCAD allows you to programmatically create, interact with,\nand control a Motor-CAD model, with or without using the Motor-CAD GUI.\nYou can achieve Motor-CAD automation by running scripts, either internally\nvia the Motor-CAD Scripting tab or externally.\nFeatures of PyMotorCAD include:\nThe ability to launch Motor-CAD instances and connect to already-running\ninstances of Motor-CAD.\nThe ability to control Motor-CAD by automation using PyMotorCAD API methods\nto carry out Motor-CAD actions, such as setting and retrieving Motor-CAD\nparameters. For the list of API methods, see the ref_MotorCAD_object.\nThe ability to automate workflows and methodologies within an instance of\nMotor-CAD via its internal Scripting tab. For information internal\nscripting in Motor-CAD see the ref_user_guide.\nAutomation control of Motor-CAD via external scripts. Workflows and\nmethodologies can be carried out with either a visible Motor-CAD GUI\nor via BlackBox mode. For adding PyMotorCAD to your own Python, see\nref_external_scripting.\nThe ability to control communication and couple or link Motor-CAD\nwith other software such as Ansys optiSLang.\nThe ability to run automated sensitivity analysis studies and/or select\ntolerance buildup to produce robust designs.\nAllowing users to introduce their own formulations into Motor-CAD.\nThe running of multiple parallel Motor-CAD instances via an external script.\nAnsys optiSLang can be employed to carry out detailed optimizations by\ncontrolling multiple Motor-CAD instances in parallel.\nExample scripts for tutorials on Motor-CAD features and abilities.\nCustomizable example scripts for common or advanced workflows, both within\nMotor-CAD and involving the coupling of Motor-CAD to other software.\nDocumentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD documentation.\nIn the upper right corner of the documentation’s title bar, there is an option for switching from\nviewing the documentation for the latest stable release to viewing the documentation for the\ndevelopment version or previously released versions.\nYou can also view or\ndownload the\nPyMotorCAD cheat sheet. This one-page reference provides syntax rules and commands\nfor using PyMotorCAD.\nOn the PyMotorCAD Issues page, you can create\nissues to report bugs and request new features. On the Discussions\npage on the Ansys Developer portal, you can post questions, share ideas, and get community feedback.\nTo reach the project support team, email pyansys.core@ansys.com.\ngenindex"
    },
    {
        "objectID": "index",
        "href": "index.html#introduction",
        "title": "PyMotorCAD documentation 0.6.5 > Introduction",
        "section": "Introduction",
        "text": "Ansys Motor-CAD is a dedicated design and analysis tool for electric motors.\nIt enables rapid and accurate multiphysics design and analysis of electric\nmachines across the full operating spectrum.\nToday’s electric motor design requires multiphysics analysis across wide\ntorque and speed operating ranges to accommodate rapid development cycles and\nsystem integration. Motor-CAD facilitates this cutting-edge design approach\nby providing:\nIntuitive, template-based setups for fast initial electric machine designs\nBuilt-in electromagnetic, thermal, and mechanical solvers for multiphysics insights\nRapid analysis of efficiency maps, torque and speed characteristics, and drive cycles\nQuick evaluation of motor topologies and concepts to produce designs that are\noptimized for size, performance. and efficiency"
    },
    {
        "objectID": "index",
        "href": "index.html#what-is-pymotorcad",
        "title": "PyMotorCAD documentation 0.6.5 > What is PyMotorCAD?",
        "section": "What is PyMotorCAD?",
        "text": "PyMotorCAD is part of the PyAnsys ecosystem\nthat facilitates the use of Motor-CAD within a Python environment in\nconjunction with other PyAnsys libraries and external Python libraries.\nPyMotorCAD uses a Python JSON-RPC (remote procedure call) interface for\nMotor-CAD to launch or connect with a Motor-CAD instance, either locally or\nfrom a remote machine via HTTP.\nPyMotorCAD allows you to programmatically create, interact with,\nand control a Motor-CAD model, with or without using the Motor-CAD GUI.\nYou can achieve Motor-CAD automation by running scripts, either internally\nvia the Motor-CAD Scripting tab or externally."
    },
    {
        "objectID": "index",
        "href": "index.html#features",
        "title": "PyMotorCAD documentation 0.6.5 > Features",
        "section": "Features",
        "text": "Features of PyMotorCAD include:\nThe ability to launch Motor-CAD instances and connect to already-running\ninstances of Motor-CAD.\nThe ability to control Motor-CAD by automation using PyMotorCAD API methods\nto carry out Motor-CAD actions, such as setting and retrieving Motor-CAD\nparameters. For the list of API methods, see the ref_MotorCAD_object.\nThe ability to automate workflows and methodologies within an instance of\nMotor-CAD via its internal Scripting tab. For information internal\nscripting in Motor-CAD see the ref_user_guide.\nAutomation control of Motor-CAD via external scripts. Workflows and\nmethodologies can be carried out with either a visible Motor-CAD GUI\nor via BlackBox mode. For adding PyMotorCAD to your own Python, see\nref_external_scripting.\nThe ability to control communication and couple or link Motor-CAD\nwith other software such as Ansys optiSLang.\nThe ability to run automated sensitivity analysis studies and/or select\ntolerance buildup to produce robust designs.\nAllowing users to introduce their own formulations into Motor-CAD.\nThe running of multiple parallel Motor-CAD instances via an external script.\nAnsys optiSLang can be employed to carry out detailed optimizations by\ncontrolling multiple Motor-CAD instances in parallel.\nExample scripts for tutorials on Motor-CAD features and abilities.\nCustomizable example scripts for common or advanced workflows, both within\nMotor-CAD and involving the coupling of Motor-CAD to other software."
    },
    {
        "objectID": "index",
        "href": "index.html#documentation-and-issues",
        "title": "PyMotorCAD documentation 0.6.5 > Documentation and issues",
        "section": "Documentation and issues",
        "text": "Documentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD documentation.\nIn the upper right corner of the documentation’s title bar, there is an option for switching from\nviewing the documentation for the latest stable release to viewing the documentation for the\ndevelopment version or previously released versions.\nYou can also view or\ndownload the\nPyMotorCAD cheat sheet. This one-page reference provides syntax rules and commands\nfor using PyMotorCAD.\nOn the PyMotorCAD Issues page, you can create\nissues to report bugs and request new features. On the Discussions\npage on the Ansys Developer portal, you can post questions, share ideas, and get community feedback.\nTo reach the project support team, email pyansys.core@ansys.com."
    },
    {
        "objectID": "index",
        "href": "index.html#project-index",
        "title": "PyMotorCAD documentation 0.6.5 > Project index",
        "section": "Project index",
        "text": "genindex"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_Boundary_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_Boundary_RT.html#addline_boundary_rt",
        "title": "AddLine_Boundary_RT",
        "section": "AddLine_Boundary_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_line_boundary_rt()."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_3d_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_3d_graph.html#get_magnetic_3d_graph",
        "title": "get_magnetic_3d_graph",
        "section": "get_magnetic_3d_graph",
        "text": "Get graph points from a Motor-CAD Magnetic 3d graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nWhich skew slice to get results from. Slice 1 is the first.\nClass containing x, y and data as lists"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.UpdateForceAnalysisResults",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.UpdateForceAnalysisResults.html#updateforceanalysisresults",
        "title": "UpdateForceAnalysisResults",
        "section": "UpdateForceAnalysisResults",
        "text": "Deprecated function. Replaced by MotorCAD.update_force_analysis_results()."
    },
    {
        "objectID": "methods/_autogen_Adaptive Geometry",
        "href": "methods/_autogen_Adaptive Geometry.html#adaptive-geometry",
        "title": "Adaptive Geometry",
        "section": "Adaptive Geometry",
        "text": "check_closed_region(region)\nCheck region is closed using region detection.\ncheck_collisions(region, regions_to_check)\nCheck region does not collide with other geometry regions.\ndelete_region(region[, remove_children])\nDelete region from Motor-CAD geometry engine.\nget_adaptive_parameter_value(name)\nGet adaptive parameter.\nget_region(name)\nGet Motor-CAD geometry region.\nget_region_dxf(name)\nGet Motor-CAD dxf geometry region.\nload_adaptive_script(filepath)\nLoad adaptive templates script file to Motor-CAD.\nreset_adaptive_geometry()\nReset geometry to default.\nsave_adaptive_script(filepath)\nSave adaptive templates script from Motor-CAD to file.\nset_adaptive_parameter_value(name, value)\nSet adaptive parameter, if parameter does not exist then add it.\nset_region(region)\nSet Motor-CAD geometry region.\nsubtract_region(region, region_subtract)\nSubtract Motor-CAD region (region_subtract) from another Motor-CAD region (region).\nunite_regions(region, regions)\nUnite region with two or more other regions."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_transient_power_values",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_transient_power_values.html#save_transient_power_values",
        "title": "save_transient_power_values",
        "section": "save_transient_power_values",
        "text": "Save transient power results to a text file.\nText file separator defined using the\n\"ExportTextSeparator\" parameter (default is semicolon)."
    },
    {
        "objectID": "user_guide/virtual_env_motorcad",
        "href": "user_guide/virtual_env_motorcad.html#using-a-python-virtual-environment-in-motor-cad",
        "title": "Using a Python virtual environment in Motor-CAD",
        "section": "Using a Python virtual environment in Motor-CAD",
        "text": "You can use a Python virtual environment with Motor-CAD. By default, Motor-CAD uses the Python\nversion that comes with the Motor-CAD installation.\nIf you are using a Python IDE, this often creates a virtual environment for you when you\nstart a new project. In this case, you can skip the section below, which describes how to create\na virtual environment from the command line.\nIf Python is already installed, you can check the version by running the following command in a\nterminal. (You can use the Windows terminal or any terminal integrated with an IDE such as Visual\nStudio Code or PyCharm.)\nBased on the Python version, you create a virtual environment:\nActivate the newly created virtual environment:\nIn case of Windows Powershell\nIn case of Windows Command Prompt\nDepending on the terminal specification, the virtual environment name might be highlighted.\nUse pip to install all required packages, such as ansys.motorcad.core, numpy or\nbezier.\nIn the terminal window, the preceding commands might look like this:\nProceed to change the path for the Python exe in Defaults -> Default File Locations. This should\npoint to the pythonw.exe file in the Scripts folder of the virtual environment:\nThe Python path is updated accordingly, and the Python version is recognised by the Motor-CAD\nUI.\npython --version\npython -m venv virtual_environment_folder_location\n.\\virtual_environment_folder_location\\Scripts\\activate.ps1\n.\\virtual_environment_folder_location\\Scripts\\activate.bat\npip install ansys.motorcad.core bezier numpy"
    },
    {
        "objectID": "user_guide/virtual_env_motorcad",
        "href": "user_guide/virtual_env_motorcad.html#create-a-local-python-virtual-environment",
        "title": "Using a Python virtual environment in Motor-CAD > Create a local Python virtual environment",
        "section": "Create a local Python virtual environment",
        "text": "If you are using a Python IDE, this often creates a virtual environment for you when you\nstart a new project. In this case, you can skip the section below, which describes how to create\na virtual environment from the command line.\nIf Python is already installed, you can check the version by running the following command in a\nterminal. (You can use the Windows terminal or any terminal integrated with an IDE such as Visual\nStudio Code or PyCharm.)\nBased on the Python version, you create a virtual environment:\nActivate the newly created virtual environment:\nIn case of Windows Powershell\nIn case of Windows Command Prompt\nDepending on the terminal specification, the virtual environment name might be highlighted.\nUse pip to install all required packages, such as ansys.motorcad.core, numpy or\nbezier.\nIn the terminal window, the preceding commands might look like this:\npython --version\npython -m venv virtual_environment_folder_location\n.\\virtual_environment_folder_location\\Scripts\\activate.ps1\n.\\virtual_environment_folder_location\\Scripts\\activate.bat\npip install ansys.motorcad.core bezier numpy"
    },
    {
        "objectID": "user_guide/virtual_env_motorcad",
        "href": "user_guide/virtual_env_motorcad.html#change-the-python-exe-path-in-the-motor-cad-ui",
        "title": "Using a Python virtual environment in Motor-CAD > Change the Python exe path in the Motor-CAD UI",
        "section": "Change the Python exe path in the Motor-CAD UI",
        "text": "Proceed to change the path for the Python exe in Defaults -> Default File Locations. This should\npoint to the pythonw.exe file in the Scripts folder of the virtual environment:\nThe Python path is updated accordingly, and the Python version is recognised by the Motor-CAD\nUI."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Add_Region_Thermal_A",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Add_Region_Thermal_A.html#add_region_thermal_a",
        "title": "Add_Region_Thermal_A",
        "section": "Add_Region_Thermal_A",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.unite_regions",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.unite_regions.html#unite_regions",
        "title": "unite_regions",
        "section": "unite_regions",
        "text": "Unite region with two or more other regions.\nMotor-CAD region object\nMotor-CAD region objects to united with region\nUnited Motor-CAD region object."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_thermal_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_thermal_lab.html#calculate_thermal_lab",
        "title": "calculate_thermal_lab",
        "section": "calculate_thermal_lab",
        "text": "Run the Lab thermal calculation."
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#user-guide",
        "title": "User guide",
        "section": "User guide",
        "text": "PyMotorCAD provides Python access to Motor-CAD. The RPC-based ref_MotorCAD_object\nallows you to create a Motor-CAD instance on a local machine or connect to an existing\ninstance on a remote machine over HTTP. Using the many methods available in this API’s\nsingle class, you can create scripts for fully controlling and automating Motor-CAD\nwithout using the GUI.\nAdditionally, Motor-CAD scripts can be used via the internal\nScripting tab within Ansys Motor-CAD or externally.\nMotor-CAD is installed with an internal Python interpreter that includes a stable version\nof PyMotorCAD. This Python package is based around the MotorCAD() Python object.\nEach individual MotorCAD() object represents an instance of Motor-CAD.\nFor more information on using PyMotorCAD via the internal Scripting tab in Motor-CAD, see ref_internal_scripting.\nPyMotorCAD can be added to any Python installation and used to control Motor-CAD from\nthe command line or via scripts from a Python IDE of your choice.\nFor more information on using PyMotorCAD with an external Python installation, see ref_external_scripting.\nPyMotorCAD can also be used in MATLAB, for information on this, see ref_matlab_scripting.\nPyMotorCAD can be used to define Adaptive Templates Scripts\nfor designing models with geometries that cannot be modelled\nusing the standard Motor-CAD template geometries.\nAdaptive Templates Scripts can be defined using the internal\nGeometry -> Editor -> Adaptive Templates tab,\nand are run whenever the Motor-CAD geometry is created.\nFor more information on Adaptive Templates Scripting, see ref_adaptive_templates_UG.\nAltering old scripts for use with PyMotorCAD is straightforward and allows the user to take advantage of the improvements\noffered by PyMotorCAD over the previous Motor-CAD communication method (ActiveX).\nFor information on converting ActiveX scripts to use PyMotorCAD, see ref_backwards_compatibility."
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#using-pymotorcad-scripts-internally",
        "title": "User guide > Using PyMotorCAD scripts internally",
        "section": "Using PyMotorCAD scripts internally",
        "text": "Motor-CAD is installed with an internal Python interpreter that includes a stable version\nof PyMotorCAD. This Python package is based around the MotorCAD() Python object.\nEach individual MotorCAD() object represents an instance of Motor-CAD.\nFor more information on using PyMotorCAD via the internal Scripting tab in Motor-CAD, see ref_internal_scripting."
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#using-pymotorcad-scripts-externally",
        "title": "User guide > Using PyMotorCAD scripts externally",
        "section": "Using PyMotorCAD scripts externally",
        "text": "PyMotorCAD can be added to any Python installation and used to control Motor-CAD from\nthe command line or via scripts from a Python IDE of your choice.\nFor more information on using PyMotorCAD with an external Python installation, see ref_external_scripting.\nPyMotorCAD can also be used in MATLAB, for information on this, see ref_matlab_scripting."
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#adaptive-templates-scripts",
        "title": "User guide > Adaptive templates scripts",
        "section": "Adaptive templates scripts",
        "text": "PyMotorCAD can be used to define Adaptive Templates Scripts\nfor designing models with geometries that cannot be modelled\nusing the standard Motor-CAD template geometries.\nAdaptive Templates Scripts can be defined using the internal\nGeometry -> Editor -> Adaptive Templates tab,\nand are run whenever the Motor-CAD geometry is created.\nFor more information on Adaptive Templates Scripting, see ref_adaptive_templates_UG."
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#backwards-compatibility-with-old-scripts",
        "title": "User guide > Backwards compatibility with old scripts",
        "section": "Backwards compatibility with old scripts",
        "text": "Altering old scripts for use with PyMotorCAD is straightforward and allows the user to take advantage of the improvements\noffered by PyMotorCAD over the previous Motor-CAD communication method (ActiveX).\nFor information on converting ActiveX scripts to use PyMotorCAD, see ref_backwards_compatibility."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_offset_node_number",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_offset_node_number.html#get_offset_node_number",
        "title": "get_offset_node_number",
        "section": "get_offset_node_number",
        "text": "Get the offset node number.\nNumber of the node.\nNumber of the slice.\nNumber of the cuboid.\nOffset node number."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_adaptive_parameter_value",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_adaptive_parameter_value.html#get_adaptive_parameter_value",
        "title": "get_adaptive_parameter_value",
        "section": "get_adaptive_parameter_value",
        "text": "Get adaptive parameter.\nname of parameter.\nvalue of parameter."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_region_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_region_xy.html#add_region_xy",
        "title": "add_region_xy",
        "section": "add_region_xy",
        "text": "Add a region to the Motor-CAD geometry with an x, y coordinate system.\nIf a region already exists, this method overwrites the existing region.\nRegion position for the x coordinate.\nRegion position for the y coordinate.\nName of the region.\nadd_region_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.rt_to_xy",
        "href": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.rt_to_xy.html#rt_to_xy",
        "title": "rt_to_xy",
        "section": "rt_to_xy",
        "text": "Convert Motor-CAD polar coordinates to Cartesian coordinates in degrees.\nRadial coordinate.\nAngular coordinate.\nX coordinate value.\nY coordinate value."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.lamination_type",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.lamination_type.html#lamination_type",
        "title": "lamination_type",
        "section": "lamination_type",
        "text": "Return lamination type of region from Motor-CAD."
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#examples",
        "title": "Examples",
        "section": "Examples",
        "text": "End-to-end examples show how you can use PyMotorCAD. If PyMotorCAD is installed\non your machine, you can download these examples as Python files or Jupyter\nnotebooks and run them locally.\nSome examples require additional Python packages.\nLibrary of adaptive templates examples for setting up custom geometries in Motor-CAD.\nThese scripts can be loaded into the Motor-CAD Adaptive Templates tab.\nAdaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later.\nFor more information on the use of Adaptive Templates in Motor-CAD,\nand how to create, modify and debug Adaptive Templates Scripts,\nsee ref_adaptive_templates_UG in the ref_user_guide.\nsphx_glr_examples_adaptive_library_BPMTriangularRotorNotches.py\nsphx_glr_examples_adaptive_library_BezierCurveRotorPockets.py\nsphx_glr_examples_adaptive_library_DXFImport.py\nsphx_glr_examples_adaptive_library_OblongStatorDuct.py\nsphx_glr_examples_adaptive_library_TrapezoidalDuct.py\nsphx_glr_examples_adaptive_library_UShapeSYNCRELCurvedFluxBarriers.py\nThese examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_advanced_force_extraction.py\nThese examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_basics_emag_basics.py\nsphx_glr_examples_basics_lab_basics.py\nsphx_glr_examples_basics_thermal_basics.py\nThese examples show you how to use the internal scripting functionality of PyMotorCAD.\nsphx_glr_examples_internal_scripting_emag.py\nsphx_glr_examples_internal_scripting_mechanical_force.py\nsphx_glr_examples_internal_scripting_mechanical_stress.py\nsphx_glr_examples_internal_scripting_thermal_steady_state.py\nsphx_glr_examples_internal_scripting_thermal_transient.py\nThese examples show how you can link PyMotorCAD to other Ansys products.\nsphx_glr_examples_links_ece_export_for_twinbuilder.py\nGallery generated by Sphinx-Gallery"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#adaptive-templates-examples",
        "title": "Examples > Adaptive templates examples",
        "section": "Adaptive templates examples",
        "text": "Library of adaptive templates examples for setting up custom geometries in Motor-CAD.\nThese scripts can be loaded into the Motor-CAD Adaptive Templates tab.\nAdaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later.\nFor more information on the use of Adaptive Templates in Motor-CAD,\nand how to create, modify and debug Adaptive Templates Scripts,\nsee ref_adaptive_templates_UG in the ref_user_guide.\nsphx_glr_examples_adaptive_library_BPMTriangularRotorNotches.py\nsphx_glr_examples_adaptive_library_BezierCurveRotorPockets.py\nsphx_glr_examples_adaptive_library_DXFImport.py\nsphx_glr_examples_adaptive_library_OblongStatorDuct.py\nsphx_glr_examples_adaptive_library_TrapezoidalDuct.py\nsphx_glr_examples_adaptive_library_UShapeSYNCRELCurvedFluxBarriers.py\nThese examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_advanced_force_extraction.py\nThese examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_basics_emag_basics.py\nsphx_glr_examples_basics_lab_basics.py\nsphx_glr_examples_basics_thermal_basics.py\nThese examples show you how to use the internal scripting functionality of PyMotorCAD.\nsphx_glr_examples_internal_scripting_emag.py\nsphx_glr_examples_internal_scripting_mechanical_force.py\nsphx_glr_examples_internal_scripting_mechanical_stress.py\nsphx_glr_examples_internal_scripting_thermal_steady_state.py\nsphx_glr_examples_internal_scripting_thermal_transient.py"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#advanced-examples",
        "title": "Examples > Advanced examples",
        "section": "Advanced examples",
        "text": "These examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_advanced_force_extraction.py"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#basic-examples",
        "title": "Examples > Basic examples",
        "section": "Basic examples",
        "text": "These examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_basics_emag_basics.py\nsphx_glr_examples_basics_lab_basics.py\nsphx_glr_examples_basics_thermal_basics.py"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#internal-scripting-examples",
        "title": "Examples > Internal scripting examples",
        "section": "Internal scripting examples",
        "text": "These examples show you how to use the internal scripting functionality of PyMotorCAD.\nsphx_glr_examples_internal_scripting_emag.py\nsphx_glr_examples_internal_scripting_mechanical_force.py\nsphx_glr_examples_internal_scripting_mechanical_stress.py\nsphx_glr_examples_internal_scripting_thermal_steady_state.py\nsphx_glr_examples_internal_scripting_thermal_transient.py"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#linking-examples",
        "title": "Examples > Linking examples",
        "section": "Linking examples",
        "text": "These examples show how you can link PyMotorCAD to other Ansys products.\nsphx_glr_examples_links_ece_export_for_twinbuilder.py\nGallery generated by Sphinx-Gallery"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateTorqueEnvelope",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateTorqueEnvelope.html#calculatetorqueenvelope",
        "title": "CalculateTorqueEnvelope",
        "section": "CalculateTorqueEnvelope",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_torque_envelope()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.UpdateInterface",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.UpdateInterface.html#updateinterface",
        "title": "UpdateInterface",
        "section": "UpdateInterface",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTransientPowerValues",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTransientPowerValues.html#savetransientpowervalues",
        "title": "SaveTransientPowerValues",
        "section": "SaveTransientPowerValues",
        "text": "Deprecated function. Replaced by MotorCAD.save_transient_power_values()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportDutyCycle_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportDutyCycle_Lab.html#exportdutycycle_lab",
        "title": "ExportDutyCycle_Lab",
        "section": "ExportDutyCycle_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.export_duty_cycle_lab()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadDutyCycle",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadDutyCycle.html#loaddutycycle",
        "title": "LoadDutyCycle",
        "section": "LoadDutyCycle",
        "text": "Deprecated function. Replaced by MotorCAD.load_duty_cycle()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.unite",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite one or more other regions with self.\nMotor-CAD region object/list of objects"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRectangularConductor_A",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRectangularConductor_A.html#addrectangularconductor_a",
        "title": "AddRectangularConductor_A",
        "section": "AddRectangularConductor_A",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_iron_loss_coefficients",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_iron_loss_coefficients.html#calculate_iron_loss_coefficients",
        "title": "calculate_iron_loss_coefficients",
        "section": "calculate_iron_loss_coefficients",
        "text": "Calculate and return the iron loss coefficients for the solid material.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_graph.html#get_magnetic_graph",
        "title": "get_magnetic_graph",
        "section": "get_magnetic_graph",
        "text": "Get graph points from a Motor-CAD Magnetic graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nValue of x coordinates from graph\nValue of y coordinates from graph"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#motor-cad-thermal-example-script",
        "title": "Motor-CAD thermal example script",
        "section": "Motor-CAD thermal example script",
        "text": "This example provides a Motor-CAD thermal script.\nSetting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and\nopening the file for the thermal analysis.\nInitialize ActiveX automation and launch Motor-CAD.\nDisable all popup messages from Motor-CAD.\nSpecify the working directory and open the relevant file for the\nthermal analysis.\nCreating the analysis consists of showing the thermal context, displaying\nthe Scripting tab, setting parameters, and saving the file.\nDisplay the Scripting tab.\nChange the housing diameter.\nSet the flow rate of the WJ fluid volume.\nSet the temperature of the WJ fluid inlet.\nChange the cooling fluid.\nSet the heat transfer correlation.\nSave the file.\nCalculate the steady state.\nRetrieve the magnet temperature.\nRetrieve the minimum, maximum, and average winding temperatures.\nRun the transient simulation.\nGet the transient results.\nPlot results from the simulation.\nExit Motor-CAD.\nTotal running time of the script: (1 minutes 6.298 seconds)\nDownload Jupyter notebook: thermal_basics.ipynb\nDownload Python source code: thermal_basics.py\nDownload zipped: thermal_basics.zip\nGallery generated by Sphinx-Gallery\n# Perform required imports\n# ~~~~~~~~~~~~~~~~~~~~~~~~\n# Import the required packages.\nimport os\n\nimport matplotlib.pyplot as plt\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name))\n\nmcad.load_from_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed.\n# Show thermal context\n# -----------------------\nmcad.show_thermal_context()\nmcad.display_screen(\"Scripting\")\nmcad.set_variable(\"Housing_Dia\", 250)\nmcad.set_variable(\"WJ_Fluid_Volume_Flow_Rate\", 0.002)\nmcad.set_variable(\"WJ_Fluid_Inlet_Temperature\", 25)\nmcad.set_fluid(\"HousingWJFluid\", \"Dynalene HF-LO\")\nmcad.set_variable(\"Calc/Input_h[WJ]_Rear_Housing\", 1)\nmcad.set_array_variable(\"HousingWJ_CalcInputH_A\", 0, 1)\n\nwj_fluid_k = mcad.get_variable(\"WJ_Fluid_Thermal_Conductivity\")\nwj_fluid_rho = mcad.get_variable(\"WJ_Fluid_Density\")\nwj_fluid_mu = mcad.get_variable(\"WJ_Fluid_Dynamic_Viscosity\")\nwj_fluid_u_a = mcad.get_array_variable(\"HousingWJ_Velocity_A\", 0)\nwj_fluid_u_r = mcad.get_variable(\"WJ_Channel_Fluid_Velocity_[Rear]\")\n\nh_A = 0.005 * wj_fluid_k * wj_fluid_rho * wj_fluid_u_a / wj_fluid_mu\nh_R = 0.005 * wj_fluid_k * wj_fluid_rho * wj_fluid_u_r / wj_fluid_mu\n\nprint(\"h_A = \", h_A)\nprint(\"h_R = \", h_R)\n\nmcad.set_array_variable(\"HousingWJ_InputH_A\", 0, h_A)\nmcad.set_variable(\"Input_Value_h[WJ]_Rear_Housing\", h_R)\nh_A =  178.49062082139457\nh_R =  0.0\nmcad.save_to_file(os.path.join(working_folder, \"../MotorCAD_Thermal_Python.mot\"))\ntry:\n    mcad.do_steady_state_analysis()\n    print(\"Thermal calculation successfully completed.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Thermal calculation failed.\")\nThermal calculation successfully completed.\nnode_temperature = mcad.get_node_temperature(13)\nprint(\"Node Temp = \", node_temperature)\nNode Temp =  128.102528138655\nwinding_temperature_min = mcad.get_variable(\"T_[Winding_Min]\")\nwinding_temperature_max = mcad.get_variable(\"T_[Winding_Max]\")\nwinding_temperature_average = mcad.get_variable(\"T_[Winding_Average]\")\nprint(\"Min = \", winding_temperature_min)\nprint(\"Max = \", winding_temperature_max)\nprint(\"Average = \", winding_temperature_average)\nMin =  116.279266918815\nMax =  144.588223250193\nAverage =  137.132751906985\nmcad.set_variable(\"Transient_Calculation_Type\", 0)\nmcad.set_variable(\"Transient_Time_Period\", 60)\n\ntry:\n    mcad.do_transient_analysis()\nexcept pymotorcad.MotorCADError:\n    print(\"Thermal calculation failed.\")\nnum_time_steps = 51\nwinding_temp_average_transient = []\ntime = []\n\nfor timeStep in range(num_time_steps):\n    try:\n        (x, y) = mcad.get_temperature_graph_point(\"Winding (Avg)\", timeStep)\n        time.append(x)\n        winding_temp_average_transient.append(y)\n    except pymotorcad.MotorCADError:\n        print(\"Export failed.\")\nplt.figure(1)\nplt.plot(time, winding_temp_average_transient)\nplt.xlabel(\"Time\")\nplt.ylabel(\"WindingTemp_Average_Transient\")\nplt.show()\nmcad.quit()"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#set-up-example",
        "title": "Motor-CAD thermal example script > Set up example",
        "section": "Set up example",
        "text": "Setting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and\nopening the file for the thermal analysis.\nInitialize ActiveX automation and launch Motor-CAD.\nDisable all popup messages from Motor-CAD.\nSpecify the working directory and open the relevant file for the\nthermal analysis.\n# Perform required imports\n# ~~~~~~~~~~~~~~~~~~~~~~~~\n# Import the required packages.\nimport os\n\nimport matplotlib.pyplot as plt\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name))\n\nmcad.load_from_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed."
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#launch-motor-cad",
        "title": "Motor-CAD thermal example script > Launch Motor-CAD",
        "section": "Launch Motor-CAD",
        "text": "Initialize ActiveX automation and launch Motor-CAD.\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization."
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#disable-popup-messages",
        "title": "Motor-CAD thermal example script > Disable popup messages",
        "section": "Disable popup messages",
        "text": "Disable all popup messages from Motor-CAD.\nmcad.set_variable(\"MessageDisplayState\", 2)"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#open-relevant-file",
        "title": "Motor-CAD thermal example script > Open relevant file",
        "section": "Open relevant file",
        "text": "Specify the working directory and open the relevant file for the\nthermal analysis.\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name))\n\nmcad.load_from_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed."
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#create-analysis",
        "title": "Motor-CAD thermal example script > Create analysis",
        "section": "Create analysis",
        "text": "Creating the analysis consists of showing the thermal context, displaying\nthe Scripting tab, setting parameters, and saving the file.\nDisplay the Scripting tab.\nChange the housing diameter.\nSet the flow rate of the WJ fluid volume.\nSet the temperature of the WJ fluid inlet.\nChange the cooling fluid.\nSet the heat transfer correlation.\nSave the file.\n# Show thermal context\n# -----------------------\nmcad.show_thermal_context()\nmcad.display_screen(\"Scripting\")\nmcad.set_variable(\"Housing_Dia\", 250)\nmcad.set_variable(\"WJ_Fluid_Volume_Flow_Rate\", 0.002)\nmcad.set_variable(\"WJ_Fluid_Inlet_Temperature\", 25)\nmcad.set_fluid(\"HousingWJFluid\", \"Dynalene HF-LO\")\nmcad.set_variable(\"Calc/Input_h[WJ]_Rear_Housing\", 1)\nmcad.set_array_variable(\"HousingWJ_CalcInputH_A\", 0, 1)\n\nwj_fluid_k = mcad.get_variable(\"WJ_Fluid_Thermal_Conductivity\")\nwj_fluid_rho = mcad.get_variable(\"WJ_Fluid_Density\")\nwj_fluid_mu = mcad.get_variable(\"WJ_Fluid_Dynamic_Viscosity\")\nwj_fluid_u_a = mcad.get_array_variable(\"HousingWJ_Velocity_A\", 0)\nwj_fluid_u_r = mcad.get_variable(\"WJ_Channel_Fluid_Velocity_[Rear]\")\n\nh_A = 0.005 * wj_fluid_k * wj_fluid_rho * wj_fluid_u_a / wj_fluid_mu\nh_R = 0.005 * wj_fluid_k * wj_fluid_rho * wj_fluid_u_r / wj_fluid_mu\n\nprint(\"h_A = \", h_A)\nprint(\"h_R = \", h_R)\n\nmcad.set_array_variable(\"HousingWJ_InputH_A\", 0, h_A)\nmcad.set_variable(\"Input_Value_h[WJ]_Rear_Housing\", h_R)\nh_A =  178.49062082139457\nh_R =  0.0\nmcad.save_to_file(os.path.join(working_folder, \"../MotorCAD_Thermal_Python.mot\"))"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#calculate-steady-state",
        "title": "Motor-CAD thermal example script > Calculate steady state",
        "section": "Calculate steady state",
        "text": "Calculate the steady state.\nRetrieve the magnet temperature.\nRetrieve the minimum, maximum, and average winding temperatures.\ntry:\n    mcad.do_steady_state_analysis()\n    print(\"Thermal calculation successfully completed.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Thermal calculation failed.\")\nThermal calculation successfully completed.\nnode_temperature = mcad.get_node_temperature(13)\nprint(\"Node Temp = \", node_temperature)\nNode Temp =  128.102528138655\nwinding_temperature_min = mcad.get_variable(\"T_[Winding_Min]\")\nwinding_temperature_max = mcad.get_variable(\"T_[Winding_Max]\")\nwinding_temperature_average = mcad.get_variable(\"T_[Winding_Average]\")\nprint(\"Min = \", winding_temperature_min)\nprint(\"Max = \", winding_temperature_max)\nprint(\"Average = \", winding_temperature_average)\nMin =  116.279266918815\nMax =  144.588223250193\nAverage =  137.132751906985"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#run-simulation",
        "title": "Motor-CAD thermal example script > Run simulation",
        "section": "Run simulation",
        "text": "Run the transient simulation.\nGet the transient results.\nmcad.set_variable(\"Transient_Calculation_Type\", 0)\nmcad.set_variable(\"Transient_Time_Period\", 60)\n\ntry:\n    mcad.do_transient_analysis()\nexcept pymotorcad.MotorCADError:\n    print(\"Thermal calculation failed.\")\nnum_time_steps = 51\nwinding_temp_average_transient = []\ntime = []\n\nfor timeStep in range(num_time_steps):\n    try:\n        (x, y) = mcad.get_temperature_graph_point(\"Winding (Avg)\", timeStep)\n        time.append(x)\n        winding_temp_average_transient.append(y)\n    except pymotorcad.MotorCADError:\n        print(\"Export failed.\")"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#plot-results",
        "title": "Motor-CAD thermal example script > Plot results",
        "section": "Plot results",
        "text": "Plot results from the simulation.\nplt.figure(1)\nplt.plot(time, winding_temp_average_transient)\nplt.xlabel(\"Time\")\nplt.ylabel(\"WindingTemp_Average_Transient\")\nplt.show()"
    },
    {
        "objectID": "examples/basics/thermal_basics",
        "href": "examples/basics/thermal_basics.html#exit-motor-cad",
        "title": "Motor-CAD thermal example script > Exit Motor-CAD",
        "section": "Exit Motor-CAD",
        "text": "Exit Motor-CAD.\nTotal running time of the script: (1 minutes 6.298 seconds)\nDownload Jupyter notebook: thermal_basics.ipynb\nDownload Python source code: thermal_basics.py\nDownload zipped: thermal_basics.zip\nGallery generated by Sphinx-Gallery\nmcad.quit()"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_custom_drive_cycle",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_custom_drive_cycle.html#load_custom_drive_cycle",
        "title": "load_custom_drive_cycle",
        "section": "load_custom_drive_cycle",
        "text": "Load a custom waveform from a file.\nFilepath for loading the file with the custom waveform.\nUse the r'filepath' syntax to force Python to ignore\nspecial characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.get_polar_coords_deg",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.get_polar_coords_deg.html#get_polar_coords_deg",
        "title": "get_polar_coords_deg",
        "section": "get_polar_coords_deg",
        "text": "Get coordinates as polar coordinates in degrees."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_external_custom_loss",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_external_custom_loss.html#remove_external_custom_loss",
        "title": "remove_external_custom_loss",
        "section": "remove_external_custom_loss",
        "text": "Remove an external custom loss by name.\nName of lab external custom loss"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.insert",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.insert.html#insert",
        "title": "insert",
        "section": "insert",
        "text": "Insert object before index."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror region along entity.\nLine entity to mirror region about\nWhether to apply a unique name to returned region"
    },
    {
        "objectID": "methods/_autosummary_Utility/ansys.motorcad.core.motorcad_methods.MotorCAD.is_open",
        "href": "methods/_autosummary_Utility/ansys.motorcad.core.motorcad_methods.MotorCAD.is_open.html#is_open",
        "title": "is_open",
        "section": "is_open",
        "text": "Check if the Motor-CAD executable file is running.\nTrue if the Motor-CAD executable file is still running,\nFalse if this file is not running."
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#motor-cad-lab-model-example-script",
        "title": "Motor-CAD Lab model example script",
        "section": "Motor-CAD Lab model example script",
        "text": "This example provides a Motor-CAD Lab model script.\nSetting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and opening\nthe file for the lab model.\nPerform required imports\nSpecify the working directory and open the relevant file for\nthe lab model.\nSet build options for the lab model.\nShow the lab context.\nBuild the model.\nChange operating modes.\nSet e-magnetic calculation options.\nCalculate e-magnetic performance.\nRetrieve results.\nPlot torque/speed curve results.\nSet operating point calculation options.\n# Calculate operating point.\nRetrieve results.\nExit Motor-CAD.\nTotal running time of the script: (1 minutes 51.549 seconds)\nDownload Jupyter notebook: lab_basics.ipynb\nDownload Python source code: lab_basics.py\nDownload zipped: lab_basics.zip\nGallery generated by Sphinx-Gallery\nimport os\n\nimport matplotlib.pyplot as plt\nfrom scipy import io\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed.\nmcad.set_variable(\"ModelType_MotorLAB\", 1)\nmcad.set_variable(\"SatModelPoints_MotorLAB\", 0)\nmcad.set_variable(\"LossModel_Lab\", 0)\nmcad.set_variable(\"ModelBuildSpeed_MotorLAB\", 10000)\nmcad.set_variable(\"MaxModelCurrent_MotorLAB\", 480)\nmcad.set_variable(\"BuildSatModel_MotorLAB\", True)\nmcad.set_motorlab_context()\nmcad.clear_model_build_lab()\nmcad.build_model_lab()\nmcad.set_variable(\"OperatingMode_Lab\", 0)\nmcad.set_variable(\"EmagneticCalcType_Lab\", 0)\nmcad.set_variable(\"SpeedMax_MotorLAB\", 10000)\nmcad.set_variable(\"Speedinc_MotorLAB\", 250)\nmcad.set_variable(\"SpeedMin_MotorLAB\", 500)\nmcad.set_variable(\"Imax_MotorLAB\", 480)\ntry:\n    mcad.calculate_magnetic_lab()\n    print(\"Magnetic calculation successfully completed.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Magnetic calculation failed.\")\nMagnetic calculation successfully completed.\ndata = io.loadmat(os.path.join(working_folder, mcad_name, \"Lab\", \"MotorLAB_elecdata.mat\"))\nspeed = data[\"Speed\"]\nshaft_torque = data[\"Shaft_Torque\"]\nshaft_power = data[\"Shaft_Power\"]\nplt.figure(1)\nplt.subplot(211)\nplt.plot(speed, shaft_torque)\nplt.xlabel(\"Speed\")\nplt.ylabel(\"Shaft Torque\")\nplt.subplot(212)\nplt.plot(speed, shaft_power)\nplt.xlabel(\"Speed\")\nplt.ylabel(\"Shaft Power\")\nplt.show(block=False)\nplt.savefig(os.path.join(working_folder, \"../Maximum Torque VS Speed Curve.png\"))\nmcad.set_variable(\"OpPointSpec_MotorLAB\", 1)\nmcad.set_variable(\"StatorCurrentDemand_Lab\", 480)\nmcad.set_variable(\"SpeedDemand_MotorLAB\", 4000)\nmcad.set_variable(\"LabThermalCoupling\", 0)\nmcad.set_variable(\"LabMagneticCoupling\", 0)\nmcad.calculate_operating_point_lab()\nop_point_shaft_torque = mcad.get_variable(\"LabOpPoint_ShaftTorque\")\nop_point_efficiency = mcad.get_variable(\"LabOpPoint_Efficiency\")\nprint(\"Operating Point Shaft Torque = \", op_point_shaft_torque)\nprint(\"Operating Point Efficiency = \", op_point_efficiency)\nOperating Point Shaft Torque =  293.331897665637\nOperating Point Efficiency =  96.9372201241536\nmcad.quit()\nprint(\"Simulation completed.\")\nSimulation completed."
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#set-up-example",
        "title": "Motor-CAD Lab model example script > Set up example",
        "section": "Set up example",
        "text": "Setting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and opening\nthe file for the lab model.\nPerform required imports\nSpecify the working directory and open the relevant file for\nthe lab model.\nimport os\n\nimport matplotlib.pyplot as plt\nfrom scipy import io\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed."
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#launch-motor-cad",
        "title": "Motor-CAD Lab model example script > Launch Motor-CAD",
        "section": "Launch Motor-CAD",
        "text": "print(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization."
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#disable-popup-messages",
        "title": "Motor-CAD Lab model example script > Disable popup messages",
        "section": "Disable popup messages",
        "text": "mcad.set_variable(\"MessageDisplayState\", 2)"
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#open-relevant-file",
        "title": "Motor-CAD Lab model example script > Open relevant file",
        "section": "Open relevant file",
        "text": "Specify the working directory and open the relevant file for\nthe lab model.\nworking_folder = os.getcwd()\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name + \".mot\"))\n\nprint(\"Initialization completed.\")\nInitialization completed."
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#build-model",
        "title": "Motor-CAD Lab model example script > Build model",
        "section": "Build model",
        "text": "Set build options for the lab model.\nShow the lab context.\nBuild the model.\nChange operating modes.\nmcad.set_variable(\"ModelType_MotorLAB\", 1)\nmcad.set_variable(\"SatModelPoints_MotorLAB\", 0)\nmcad.set_variable(\"LossModel_Lab\", 0)\nmcad.set_variable(\"ModelBuildSpeed_MotorLAB\", 10000)\nmcad.set_variable(\"MaxModelCurrent_MotorLAB\", 480)\nmcad.set_variable(\"BuildSatModel_MotorLAB\", True)\nmcad.set_motorlab_context()\nmcad.clear_model_build_lab()\nmcad.build_model_lab()\nmcad.set_variable(\"OperatingMode_Lab\", 0)"
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#calculate-e-magnetic-performance",
        "title": "Motor-CAD Lab model example script > Calculate e-magnetic performance",
        "section": "Calculate e-magnetic performance",
        "text": "Set e-magnetic calculation options.\nCalculate e-magnetic performance.\nRetrieve results.\nmcad.set_variable(\"EmagneticCalcType_Lab\", 0)\nmcad.set_variable(\"SpeedMax_MotorLAB\", 10000)\nmcad.set_variable(\"Speedinc_MotorLAB\", 250)\nmcad.set_variable(\"SpeedMin_MotorLAB\", 500)\nmcad.set_variable(\"Imax_MotorLAB\", 480)\ntry:\n    mcad.calculate_magnetic_lab()\n    print(\"Magnetic calculation successfully completed.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Magnetic calculation failed.\")\nMagnetic calculation successfully completed.\ndata = io.loadmat(os.path.join(working_folder, mcad_name, \"Lab\", \"MotorLAB_elecdata.mat\"))\nspeed = data[\"Speed\"]\nshaft_torque = data[\"Shaft_Torque\"]\nshaft_power = data[\"Shaft_Power\"]"
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#plot-results",
        "title": "Motor-CAD Lab model example script > Plot results",
        "section": "Plot results",
        "text": "Plot torque/speed curve results.\nplt.figure(1)\nplt.subplot(211)\nplt.plot(speed, shaft_torque)\nplt.xlabel(\"Speed\")\nplt.ylabel(\"Shaft Torque\")\nplt.subplot(212)\nplt.plot(speed, shaft_power)\nplt.xlabel(\"Speed\")\nplt.ylabel(\"Shaft Power\")\nplt.show(block=False)\nplt.savefig(os.path.join(working_folder, \"../Maximum Torque VS Speed Curve.png\"))"
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#calculate-operating-point",
        "title": "Motor-CAD Lab model example script > Calculate operating point",
        "section": "Calculate operating point",
        "text": "Set operating point calculation options.\n# Calculate operating point.\nRetrieve results.\nmcad.set_variable(\"OpPointSpec_MotorLAB\", 1)\nmcad.set_variable(\"StatorCurrentDemand_Lab\", 480)\nmcad.set_variable(\"SpeedDemand_MotorLAB\", 4000)\nmcad.set_variable(\"LabThermalCoupling\", 0)\nmcad.set_variable(\"LabMagneticCoupling\", 0)\nmcad.calculate_operating_point_lab()\nop_point_shaft_torque = mcad.get_variable(\"LabOpPoint_ShaftTorque\")\nop_point_efficiency = mcad.get_variable(\"LabOpPoint_Efficiency\")\nprint(\"Operating Point Shaft Torque = \", op_point_shaft_torque)\nprint(\"Operating Point Efficiency = \", op_point_efficiency)\nOperating Point Shaft Torque =  293.331897665637\nOperating Point Efficiency =  96.9372201241536"
    },
    {
        "objectID": "examples/basics/lab_basics",
        "href": "examples/basics/lab_basics.html#exit-motor-cad",
        "title": "Motor-CAD Lab model example script > Exit Motor-CAD",
        "section": "Exit Motor-CAD",
        "text": "Exit Motor-CAD.\nTotal running time of the script: (1 minutes 51.549 seconds)\nDownload Jupyter notebook: lab_basics.ipynb\nDownload Python source code: lab_basics.py\nDownload zipped: lab_basics.zip\nGallery generated by Sphinx-Gallery\nmcad.quit()\nprint(\"Simulation completed.\")\nSimulation completed."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror line about a line.\nLine entity to mirror Line about"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_results",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_results.html#save_results",
        "title": "save_results",
        "section": "save_results",
        "text": "Save the output results from an \"EMagnetic\" or \"Thermal\" solution.\nThis method supports only \"EMagnetic\" or \"Thermal\" solutions.\nSolution type, which must be \"EMagnetic\" or \"Thermal\"."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_external_circuit",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_external_circuit.html#save_external_circuit",
        "title": "save_external_circuit",
        "section": "save_external_circuit",
        "text": "Save the external circuit to a file."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_to_node_resistance",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_to_node_resistance.html#get_node_to_node_resistance",
        "title": "get_node_to_node_resistance",
        "section": "get_node_to_node_resistance",
        "text": "Get the node-to-node resistance.\nNumber of the first thermal node.\nNumber of the second thermal node.\nResistance value."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_xy.html#add_line_xy",
        "title": "add_line_xy",
        "section": "add_line_xy",
        "text": "Add a line to the Motor-CAD axial geometry with an x, y coordinate system.\nStart position for the x coordinate.\nStart position for the y coordinate.\nEnd position for the x coordinate.\nEnd position for the y coordinate.\nadd_line_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetModelBuilt_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetModelBuilt_Lab.html#getmodelbuilt_lab",
        "title": "GetModelBuilt_Lab",
        "section": "GetModelBuilt_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.get_model_built_lab()."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_message",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_message.html#show_message",
        "title": "show_message",
        "section": "show_message",
        "text": "Display a message in the Motor-CAD message window.\nMessage to display."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DeleteRegions",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DeleteRegions.html#deleteregions",
        "title": "DeleteRegions",
        "section": "DeleteRegions",
        "text": "Deprecated function. Replaced by MotorCAD.delete_regions()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_dxf_file",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_dxf_file.html#load_dxf_file",
        "title": "load_dxf_file",
        "section": "load_dxf_file",
        "text": "Load a DXF geometry file.\nName of the DXF file. Use r’filepath’ syntax to force Python\nto ignore special characters."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveExternalCircuit",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveExternalCircuit.html#saveexternalcircuit",
        "title": "SaveExternalCircuit",
        "section": "SaveExternalCircuit",
        "text": "Deprecated function. Replaced by MotorCAD.save_external_circuit()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadCustomDriveCycle",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadCustomDriveCycle.html#loadcustomdrivecycle",
        "title": "LoadCustomDriveCycle",
        "section": "LoadCustomDriveCycle",
        "text": "Deprecated function. Replaced by MotorCAD.load_custom_drive_cycle()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.replace",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.replace.html#replace",
        "title": "replace",
        "section": "replace",
        "text": "Replace self with another region.\nThis method replaces region entities with entities from the replacement region object,\nsuch as an imported DXF region.\nMotor-CAD region object whose entities are to replace those of the\nexisting region."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddMagnetRegion_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddMagnetRegion_XY.html#addmagnetregion_xy",
        "title": "AddMagnetRegion_XY",
        "section": "AddMagnetRegion_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_magnet_region_xy()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_duty_cycle",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_duty_cycle.html#load_duty_cycle",
        "title": "load_duty_cycle",
        "section": "load_duty_cycle",
        "text": "Load a duty cycle from a DAT file.\nName of the DAT file with the duty cycle to load. The default\ndirectory is the one with the MOT file. To use a different\ndirectory, specify the absolute filepath to the DAT file.\nUse the r'filepath' syntax to force Python to ignore\nspecial characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Coordinate by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportFigure_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportFigure_Lab.html#exportfigure_lab",
        "title": "ExportFigure_Lab",
        "section": "ExportFigure_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.export_figure_lab()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.linked_region",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.linked_region.html#linked_region",
        "title": "linked_region",
        "section": "linked_region",
        "text": "Get linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_messages",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_messages.html#clear_messages",
        "title": "clear_messages",
        "section": "clear_messages",
        "text": "Clear messages in the message display window."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.add_point",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.add_point.html#add_point",
        "title": "add_point",
        "section": "add_point",
        "text": "Add a new point into region on an existing Line/Arc.\nThe point must already exist on a Line/Arc belonging to the region. The entity will be split\nand 2 new entities created.\nCoordinate at which to add new point"
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.update_force_analysis_results",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.update_force_analysis_results.html#update_force_analysis_results",
        "title": "update_force_analysis_results",
        "section": "update_force_analysis_results",
        "text": "Update force analysis results for the multiforce operating point.\nFFT data type. Options are:\n0: 1D Temporal Harmonics\n1: 1D Spatial Harmonics"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTemplate",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTemplate.html#savetemplate",
        "title": "SaveTemplate",
        "section": "SaveTemplate",
        "text": "Deprecated function. Replaced by MotorCAD.save_template()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_report_structure",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_report_structure.html#load_report_structure",
        "title": "load_report_structure",
        "section": "load_report_structure",
        "text": "Load the tree structure of the report from a file.\nFilepath for the file with the tree structure of the\nreport. Use the r'filepath' syntax to force Python\nto ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_power_graph_point",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_power_graph_point.html#get_power_graph_point",
        "title": "get_power_graph_point",
        "section": "get_power_graph_point",
        "text": "Get a point from a Motor-CAD power graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nPoint number to get x and y coordinate values from.\nValue of the x coordinate from the graph.\nValue of the y coordinate from the graph."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.coordinate_on_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.coordinate_on_entity.html#coordinate_on_entity",
        "title": "coordinate_on_entity",
        "section": "coordinate_on_entity",
        "text": "Get if a coordinate exists on this Arc.\nCheck if this coordinate is on the Arc"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#trapezoidal-ducts",
        "title": "Trapezoidal ducts",
        "section": "Trapezoidal ducts",
        "text": "This script applies the adaptive templates functionality to modify rectangular ducts\ninto trapezoidal ducts.\nImport pymotorcad to access Motor-CAD.\nImport Coordinate, rt_to_xy, xy_to_rt\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e10 IPM motor template is loaded and set up with four rectangular rotor ducts, and the file is\nsaved to a temporary folder. To keep a new Motor-CAD instance open after executing the script, use\nthe``MotorCAD(keep_instance_open=True)`` option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nThe set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nThe rectangle consists of two lines of length equal to the rectangle width.\nOnly the top line requires modification.\nIt is necessary to check whether the line is closest to the origin. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\nFrom Motor-CAD, get the adaptive parameters and their values.\nUse the set_default_parameter() method to set the required Trapezoid_base_ratio parameter\nif undefined.\nSet required parameters for the trapezoid: ratio of top width / base width\n(Trapezoid_base_ratio), trapezoid width and trapezoid height.\nGet the standard template rotor region. This can be drawn for debugging if required.\nFor each child region of the rotor region:\nCheck whether the region is a rotor duct.\nFind the top line that makes up the duct.\nModify the start and end points of the line.\nSet the region in Motor-CAD.\nThe script accounts for whether ducts are full ducts or half ducts (the case when a duct spans the\nrotor pole boundary)\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 51.142 seconds)\nDownload Jupyter notebook: TrapezoidalDuct.ipynb\nDownload Python source code: TrapezoidalDuct.py\nDownload zipped: TrapezoidalDuct.zip\nGallery generated by Sphinx-Gallery\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Coordinate, rt_to_xy, xy_to_rt\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e10\")\n    mc.set_variable(\"RotorDuctType\", 4)  # selected rectangular ducts\n    mc.set_array_variable(\"RotorCircularDuctLayer_ChannelWidth\", 0, 4)  # set duct width\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"Trapezoidal_duct\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False\nset_default_parameter(\"Trapezoid_base_ratio\", 0.7)\nTrap_ratio = mc.get_adaptive_parameter_value(\"Trapezoid_base_ratio\")\nTrap_W = mc.get_array_variable(\n    \"RotorCircularDuctLayer_ChannelWidth\",\n    0,\n)\nTrap_H = mc.get_array_variable(\n    \"RotorCircularDuctLayer_ChannelHeight\",\n    0,\n)\nrt_region = mc.get_region(\"Rotor\")  # get the rotor region\nduct_area = Trap_H * Trap_W\nfor child_name in rt_region.child_names:\n    if \"RotorDuctFluidRegion\" in child_name:\n        duct_region = mc.get_region(child_name)\n        if round(duct_region.area / duct_area, 2) == 1:  # check if  full duct is drawn\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / Trap_W, 2) == 1:  # check if  the line is width\n                    # additional check in case width = height\n                    r_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    r_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if abs(angle_end_point - angle_start_point) > 0.05:  # 0.05 degree is tolerance\n                        # check if the line located at top or bottom\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        if not Line_origin:\n                            del_trap_angle = (\n                                (angle_end_point - angle_start_point) * (1 - Trap_ratio) / 2\n                            )\n                            new_angle_start_point = angle_start_point + del_trap_angle\n                            new_angle_end_point = angle_end_point - del_trap_angle\n                            new_start_x, new_start_y = rt_to_xy(\n                                r_start_point, new_angle_start_point\n                            )\n                            new_end_x, new_end_y = rt_to_xy(r_end_point, new_angle_end_point)\n                            new_start_point = Coordinate(new_start_x, new_start_y)\n                            new_end_point = Coordinate(new_end_x, new_end_y)\n                            duct_region.edit_point(entity.start, new_start_point)\n                            duct_region.edit_point(entity.end, new_end_point)\n                            mc.set_region(duct_region)\n\n        elif round(duct_region.area / duct_area, 2) == 0.5:  # half duct\n            Symm_angle = 360 / duct_region.duplications  # angle of symmetry\n\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / Trap_W, 2) == 0.5:  # check if  the line is width\n                    # additional check in case width = height\n                    r_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    r_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if abs(angle_end_point - angle_start_point) > 0.05:  # 0.05 degree is tolerance\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        if not Line_origin:\n                            del_trap_angle = (angle_end_point - angle_start_point) * (\n                                1 - Trap_ratio\n                            )\n                            if (\n                                angle_start_point - 0 < 1e-10\n                                or angle_start_point == 0\n                                or round(angle_start_point / Symm_angle, 2) == 1\n                            ):  # on symmetry plane\n                                new_angle_end_point = angle_end_point - del_trap_angle\n                                new_end_x, new_end_y = rt_to_xy(r_end_point, new_angle_end_point)\n                                new_end_point = Coordinate(new_end_x, new_end_y)\n                                duct_region.edit_point(entity.end, new_end_point)\n                            elif (\n                                angle_end_point - 0 < 1e-10\n                                or round(angle_end_point / Symm_angle, 2) == 1\n                            ):  # symmetry plan\n                                new_angle_start_point = angle_start_point + del_trap_angle\n                                new_start_x, new_start_y = rt_to_xy(\n                                    r_start_point, new_angle_start_point\n                                )\n                                new_start_point = Coordinate(new_start_x, new_start_y)\n                                duct_region.edit_point(entity.start, new_start_point)\n\n                            mc.set_region(duct_region)\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#perform-required-imports",
        "title": "Trapezoidal ducts > Perform required imports",
        "section": "Perform required imports",
        "text": "Import pymotorcad to access Motor-CAD.\nImport Coordinate, rt_to_xy, xy_to_rt\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Coordinate, rt_to_xy, xy_to_rt"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#connect-to-motor-cad",
        "title": "Trapezoidal ducts > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e10 IPM motor template is loaded and set up with four rectangular rotor ducts, and the file is\nsaved to a temporary folder. To keep a new Motor-CAD instance open after executing the script, use\nthe``MotorCAD(keep_instance_open=True)`` option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e10\")\n    mc.set_variable(\"RotorDuctType\", 4)  # selected rectangular ducts\n    mc.set_array_variable(\"RotorCircularDuctLayer_ChannelWidth\", 0, 4)  # set duct width\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"Trapezoidal_duct\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#define-necessary-functions",
        "title": "Trapezoidal ducts > Define necessary functions",
        "section": "Define necessary functions",
        "text": "The set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nThe rectangle consists of two lines of length equal to the rectangle width.\nOnly the top line requires modification.\nIt is necessary to check whether the line is closest to the origin. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#set-adaptive-parameter-if-required",
        "title": "Trapezoidal ducts > Set adaptive parameter if required",
        "section": "Set adaptive parameter if required",
        "text": "The set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#check-line-distance-from-origin",
        "title": "Trapezoidal ducts > Check line distance from origin",
        "section": "Check line distance from origin",
        "text": "The rectangle consists of two lines of length equal to the rectangle width.\nOnly the top line requires modification.\nIt is necessary to check whether the line is closest to the origin. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#get-required-parameters-and-objects",
        "title": "Trapezoidal ducts > Get required parameters and objects",
        "section": "Get required parameters and objects",
        "text": "From Motor-CAD, get the adaptive parameters and their values.\nUse the set_default_parameter() method to set the required Trapezoid_base_ratio parameter\nif undefined.\nSet required parameters for the trapezoid: ratio of top width / base width\n(Trapezoid_base_ratio), trapezoid width and trapezoid height.\nGet the standard template rotor region. This can be drawn for debugging if required.\nset_default_parameter(\"Trapezoid_base_ratio\", 0.7)\nTrap_ratio = mc.get_adaptive_parameter_value(\"Trapezoid_base_ratio\")\nTrap_W = mc.get_array_variable(\n    \"RotorCircularDuctLayer_ChannelWidth\",\n    0,\n)\nTrap_H = mc.get_array_variable(\n    \"RotorCircularDuctLayer_ChannelHeight\",\n    0,\n)\nrt_region = mc.get_region(\"Rotor\")  # get the rotor region"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#create-the-adaptive-templates-geometry",
        "title": "Trapezoidal ducts > Create the Adaptive Templates geometry",
        "section": "Create the Adaptive Templates geometry",
        "text": "For each child region of the rotor region:\nCheck whether the region is a rotor duct.\nFind the top line that makes up the duct.\nModify the start and end points of the line.\nSet the region in Motor-CAD.\nThe script accounts for whether ducts are full ducts or half ducts (the case when a duct spans the\nrotor pole boundary)\nduct_area = Trap_H * Trap_W\nfor child_name in rt_region.child_names:\n    if \"RotorDuctFluidRegion\" in child_name:\n        duct_region = mc.get_region(child_name)\n        if round(duct_region.area / duct_area, 2) == 1:  # check if  full duct is drawn\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / Trap_W, 2) == 1:  # check if  the line is width\n                    # additional check in case width = height\n                    r_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    r_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if abs(angle_end_point - angle_start_point) > 0.05:  # 0.05 degree is tolerance\n                        # check if the line located at top or bottom\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        if not Line_origin:\n                            del_trap_angle = (\n                                (angle_end_point - angle_start_point) * (1 - Trap_ratio) / 2\n                            )\n                            new_angle_start_point = angle_start_point + del_trap_angle\n                            new_angle_end_point = angle_end_point - del_trap_angle\n                            new_start_x, new_start_y = rt_to_xy(\n                                r_start_point, new_angle_start_point\n                            )\n                            new_end_x, new_end_y = rt_to_xy(r_end_point, new_angle_end_point)\n                            new_start_point = Coordinate(new_start_x, new_start_y)\n                            new_end_point = Coordinate(new_end_x, new_end_y)\n                            duct_region.edit_point(entity.start, new_start_point)\n                            duct_region.edit_point(entity.end, new_end_point)\n                            mc.set_region(duct_region)\n\n        elif round(duct_region.area / duct_area, 2) == 0.5:  # half duct\n            Symm_angle = 360 / duct_region.duplications  # angle of symmetry\n\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / Trap_W, 2) == 0.5:  # check if  the line is width\n                    # additional check in case width = height\n                    r_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    r_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if abs(angle_end_point - angle_start_point) > 0.05:  # 0.05 degree is tolerance\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        if not Line_origin:\n                            del_trap_angle = (angle_end_point - angle_start_point) * (\n                                1 - Trap_ratio\n                            )\n                            if (\n                                angle_start_point - 0 < 1e-10\n                                or angle_start_point == 0\n                                or round(angle_start_point / Symm_angle, 2) == 1\n                            ):  # on symmetry plane\n                                new_angle_end_point = angle_end_point - del_trap_angle\n                                new_end_x, new_end_y = rt_to_xy(r_end_point, new_angle_end_point)\n                                new_end_point = Coordinate(new_end_x, new_end_y)\n                                duct_region.edit_point(entity.end, new_end_point)\n                            elif (\n                                angle_end_point - 0 < 1e-10\n                                or round(angle_end_point / Symm_angle, 2) == 1\n                            ):  # symmetry plan\n                                new_angle_start_point = angle_start_point + del_trap_angle\n                                new_start_x, new_start_y = rt_to_xy(\n                                    r_start_point, new_angle_start_point\n                                )\n                                new_start_point = Coordinate(new_start_x, new_start_y)\n                                duct_region.edit_point(entity.start, new_start_point)\n\n                            mc.set_region(duct_region)"
    },
    {
        "objectID": "examples/adaptive_library/TrapezoidalDuct",
        "href": "examples/adaptive_library/TrapezoidalDuct.html#load-in-adaptive-templates-script-if-required",
        "title": "Trapezoidal ducts > Load in Adaptive Templates script if required",
        "section": "Load in Adaptive Templates script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 51.142 seconds)\nDownload Jupyter notebook: TrapezoidalDuct.ipynb\nDownload Python source code: TrapezoidalDuct.py\nDownload zipped: TrapezoidalDuct.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodePower",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodePower.html#getnodepower",
        "title": "GetNodePower",
        "section": "GetNodePower",
        "text": "Deprecated function. Replaced by MotorCAD.get_node_power()."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_fea_graph_point",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_fea_graph_point.html#get_fea_graph_point",
        "title": "get_fea_graph_point",
        "section": "get_fea_graph_point",
        "text": "Get a point from a Motor-CAD FEA graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nWhich skew slice to get results from. Slice 1 is the first.\nPoint number to get x and y coordinate values from.\nValue of the x coordinate from the graph.\nValue of the y coordinate from the graph."
    },
    {
        "objectID": "methods/_autogen_Graphs",
        "href": "methods/_autogen_Graphs.html#graphs",
        "title": "Graphs",
        "section": "Graphs",
        "text": "get_fea_graph(graph_name, slice_number[, ...])\nGet graph points from a Motor-CAD FEA graph.\nget_fea_graph_point(graph_id, slice_number, ...)\nGet a point from a Motor-CAD FEA graph.\nget_heatflow_graph(graph_name)\nGet graph points from a Motor-CAD heat flow graph.\nget_magnetic_3d_graph(graph_name, slice_number)\nGet graph points from a Motor-CAD Magnetic 3d graph.\nget_magnetic_3d_graph_point(graph_name, ...)\nGet a point from a Motor-CAD magnetic 3D graph.\nget_magnetic_graph(graph_name)\nGet graph points from a Motor-CAD Magnetic graph.\nget_magnetic_graph_point(graph_name, ...)\nGet a point from a Motor-CAD magnetic graph.\nget_power_graph(graph_name)\nGet graph points from a Motor-CAD transient power loss graph.\nget_power_graph_point(graph_name, point_number)\nGet a point from a Motor-CAD power graph.\nget_temperature_graph(graph_name)\nGet graph points from a Motor-CAD transient temperature graph.\nget_temperature_graph_point(graph_name, ...)\nGet a point from a Motor-CAD thermal graph."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_report_tree",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_report_tree.html#load_report_tree",
        "title": "load_report_tree",
        "section": "load_report_tree",
        "text": "Load the report with the tree structure of the modules and components."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.replace",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.replace.html#replace",
        "title": "replace",
        "section": "replace",
        "text": "Replace self with another region.\nThis method replaces region entities with entities from the replacement region object,\nsuch as an imported DXF region.\nMotor-CAD region object whose entities are to replace those of the\nexisting region."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_loss",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_loss.html#get_region_loss",
        "title": "get_region_loss",
        "section": "get_region_loss",
        "text": "Calculate the loss value for an expression of a region.\nThis method is valid for a magnetic solution only.\nThe region is bounded by the radii and angles that are specified in parameters.\nRadii and angle values of 0 give all region losses.\nLosses calculated are per unit length and are only for the FEA areas modeled.\nFor total losses, you must multiply by the symmetry factor."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror arc about a line.\nLine entity to mirror Line about"
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.disable_error_messages",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.disable_error_messages.html#disable_error_messages",
        "title": "disable_error_messages",
        "section": "disable_error_messages",
        "text": "Disable the display of error messages.\nWhether to disable the display of error message. If True,\nerror messages are hidden. If False, error messages are\nshown."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DisableErrorMessages",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DisableErrorMessages.html#disableerrormessages",
        "title": "DisableErrorMessages",
        "section": "DisableErrorMessages",
        "text": "Deprecated function. Replaced by MotorCAD.disable_error_messages()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_power_injection_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_power_injection_value.html#set_power_injection_value",
        "title": "set_power_injection_value",
        "section": "set_power_injection_value",
        "text": "Set or create a power injection.\nName of the power injection."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.lamination_type",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.lamination_type.html#lamination_type",
        "title": "lamination_type",
        "section": "lamination_type",
        "text": "Return lamination type of region from Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_adaptive_parameter_value",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_adaptive_parameter_value.html#set_adaptive_parameter_value",
        "title": "set_adaptive_parameter_value",
        "section": "set_adaptive_parameter_value",
        "text": "Set adaptive parameter, if parameter does not exist then add it.\nname of parameter.\nvalue of parameter."
    },
    {
        "objectID": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_winding_coil",
        "href": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_winding_coil.html#set_winding_coil",
        "title": "set_winding_coil",
        "section": "set_winding_coil",
        "text": "Set go and return slots, positions, and turns for the winding coil.\nPosition values for the upper and lower paths of a go slot can\nbe lowercase alphabetic characters, such as \"a\", \"b\",\nand \"c\". Position values for left and right paths of a go\nslot are \"L\" and \"R\".\nPosition values for the upper and lower paths of a return slot can\nbe lowercase alphabetic characters, such as \"a\", \"b\",\nand \"c\". Position values for left and right paths of a return\nslot are \"L\" and \"R\"."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.save_motorcad_screen_to_file",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.save_motorcad_screen_to_file.html#save_motorcad_screen_to_file",
        "title": "save_motorcad_screen_to_file",
        "section": "save_motorcad_screen_to_file",
        "text": "Save the entire Motor-CAD screen of a tab to an image file.\nCall the initialise_tab_names method before called this method.l The\nMotor-CAD UI must be visible.\nPath of the screen to save. The path must be in this format:\n\"tabName;tabName;tabName\". For example,\n\"Geometry;Axial\".\nFull path for the image file, including the file name and file extension. The\nextensions supported are BMP, JPG, and PNG."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMechanicalCalculation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMechanicalCalculation.html#domechanicalcalculation",
        "title": "DoMechanicalCalculation",
        "section": "DoMechanicalCalculation",
        "text": "Deprecated function. Replaced by MotorCAD.do_mechanical_calculation()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_steady_state_analysis",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_steady_state_analysis.html#do_steady_state_analysis",
        "title": "do_steady_state_analysis",
        "section": "do_steady_state_analysis",
        "text": "Run the thermal steady state analysis."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathLine",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathLine.html#setfeapathline",
        "title": "SetFEAPathLine",
        "section": "SetFEAPathLine",
        "text": "Deprecated function. Replaced by MotorCAD.set_fea_path_line()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetIMIronLoss",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetIMIronLoss.html#getimironloss",
        "title": "GetIMIronLoss",
        "section": "GetIMIronLoss",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_external_circuit",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_external_circuit.html#clear_external_circuit",
        "title": "clear_external_circuit",
        "section": "clear_external_circuit",
        "text": "Clear the external circuit."
    },
    {
        "objectID": "methods/_autogen_Lab",
        "href": "methods/_autogen_Lab.html#lab",
        "title": "Lab",
        "section": "Lab",
        "text": "add_external_custom_loss(name, ...)\nAdd an external custom loss.\nadd_internal_custom_loss(name, function, ...)\nAdd an internal custom loss.\nbuild_model_lab()\nBuild the Lab model.\ncalculate_duty_cycle_lab()\nRun the Lab duty cycle.\ncalculate_generator_lab()\nCalculate generator performance.\ncalculate_magnetic_lab()\nRun the Lab magnetic calculation.\ncalculate_operating_point_lab()\nRun the Lab operating point calculation.\ncalculate_test_performance_lab()\nCalculate the test performance.\ncalculate_thermal_lab()\nRun the Lab thermal calculation.\nclear_model_build_lab()\nClear the Lab model build.\nexport_duty_cycle_lab()\nExport the calculated duty cycle data to the thermal model.\nexport_figure_lab(calculation_type, ...)\nExport an image of the Lab results graph.\nexport_lab_model(file_path)\nExport lab model.\nget_model_built_lab()\nTest if the Lab model must be built or rebuilt before running calculations.\nload_external_model_lab(file_path)\nLoad an external model data file.\nremove_external_custom_loss(name)\nRemove an external custom loss by name.\nremove_internal_custom_loss(name)\nRemove an internal custom loss by name.\nshow_results_viewer_lab(calculation_type)\nLoad the results viewer for the specified Lab calculation type."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.child_names",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.child_names.html#child_names",
        "title": "child_names",
        "section": "child_names",
        "text": "Property for child names list.\nlist of child region names"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.is_horizontal",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.is_horizontal.html#is_horizontal",
        "title": "is_horizontal",
        "section": "is_horizontal",
        "text": "Check whether line is horizontal."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RemoveExternalComponent",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RemoveExternalComponent.html#removeexternalcomponent",
        "title": "RemoveExternalComponent",
        "section": "RemoveExternalComponent",
        "text": "Deprecated function. Replaced by MotorCAD.remove_external_component()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddCircularConductor_A",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddCircularConductor_A.html#addcircularconductor_a",
        "title": "AddCircularConductor_A",
        "section": "AddCircularConductor_A",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMultiForceCalculation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMultiForceCalculation.html#domultiforcecalculation",
        "title": "DoMultiForceCalculation",
        "section": "DoMultiForceCalculation",
        "text": "Deprecated function. Replaced by MotorCAD.do_multi_force_calculation()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.from_coordinate_list",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.from_coordinate_list.html#from_coordinate_list",
        "title": "from_coordinate_list",
        "section": "from_coordinate_list",
        "text": "Work in progress. Need to split up geometry first to avoid circular imports.\nUse geometry_fitting.return_entity_list for now"
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.save_screen_to_file",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.save_screen_to_file.html#save_screen_to_file",
        "title": "save_screen_to_file",
        "section": "save_screen_to_file",
        "text": "Save a screen to an image file.\nName of the screen.\nFull path for the image file, including the file name and file extension. The\nextensions supported are BMP, JPG, and PNG."
    },
    {
        "objectID": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_winding_coil",
        "href": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_winding_coil.html#get_winding_coil",
        "title": "get_winding_coil",
        "section": "get_winding_coil",
        "text": "Get the go and return slots, positions, and turns for the winding coil.\nIn Motor-CAD, you can select Winding -> Pattern to see how phases, paths,\nand coils are indexed."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddMagnetRegion_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddMagnetRegion_RT.html#addmagnetregion_rt",
        "title": "AddMagnetRegion_RT",
        "section": "AddMagnetRegion_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_magnet_region_rt()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetResistanceMultiplier",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetResistanceMultiplier.html#setresistancemultiplier",
        "title": "SetResistanceMultiplier",
        "section": "SetResistanceMultiplier",
        "text": "Deprecated function. Replaced by MotorCAD.set_resistance_multiplier()."
    },
    {
        "objectID": "methods/_autogen_FEA Geometry",
        "href": "methods/_autogen_FEA Geometry.html#fea-geometry",
        "title": "FEA Geometry",
        "section": "FEA Geometry",
        "text": "add_arc_boundary_rt(direction, rc, tc, th1, ...)\nAdd a boundary condition arc using r, t coordinates for the center.\nadd_arc_boundary_xy(direction, xc, yc, th1, ...)\nAdd a boundary condition arc using x, y coordinates for the center.\nadd_arc_centre_start_end_rt(radius_centre, ...)\nAdd an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nadd_arc_centre_start_end_xy(x_centre, ...)\nAdd an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nadd_arc_rt(radius_center, theta_centre, ...)\nAdd an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nadd_arc_xy(x_centre, y_centre, theta_start, ...)\nAdd an arc to the Motor-CAD axial geometry with an x, y coordinate system.\nadd_line_boundary_rt(rs, ts, re, t_e, ...)\nAdd a boundary condition line using r, t coordinates for the start and end points.\nadd_line_boundary_xy(xs, ys, xe, ye, ...)\nAdd a boundary condition line using x, y coordinates for the start and end points.\nadd_line_rt(radius_start, theta_start, ...)\nAdd a line to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nadd_line_xy(x_start, y_start, x_end, y_end)\nAdd a line to the Motor-CAD axial geometry with an x, y coordinate system.\nadd_magnet_region_rt(radius, theta, ...)\nAdd a magnet region to the Motor-CAD geometry with an r, t (polar) coordinate system.\nadd_magnet_region_xy(x, y, region_name, ...)\nAdd a magnet region to the Motor-CAD geometry with an x, y coordinate system.\nadd_point_custom_material_rt(radius, theta, ...)\nAdd a region to the geometry and specify the material.\nadd_point_custom_material_xy(x, y, ...)\nAdd a region to the geometry and specify the material.\nadd_region_rt(radius, theta, region_name)\nAdd a region to the Motor-CAD geometry with an r, t (polar) coordinate system.\nadd_region_xy(x, y, region_name)\nAdd a region to the Motor-CAD geometry with an x, y coordinate system.\nclear_all_data()\nClear data and initialize the FEA.\ncreate_optimised_mesh()\nCreate the FEA geometry and an optimized mesh.\ndelete_regions(region_name)\nDelete a comma-separated list of named regions or all regions.\ndo_slot_finite_element()\nRun slot FEA.\nedit_magnet_region(region_name, ...)\nEdit a magnet region.\nget_point_value(parameter, x, y)\nGet a point value from the Motor-CAD FEA.\nget_region_loss(expression, region_name, ...)\nCalculate the loss value for an expression of a region.\nget_region_value(expression, region_name)\nCalculate the integral value for an expression of a region.\ninitiate_geometry_from_script()\nInitiate the geometry from scripting so Motor-CAD knows how to use it.\nreset_regions()\nReset custom FEA regions to standard regions from the Motor-CAD template geometry.\nsave_fea_data(file, first_step, final_step, ...)\nSave raw data for the open FEA solution.\nset_fea_path_arc(path_name, path_location, ...)\nAdd or edit an arc in the path editor.\nset_fea_path_line(path_name, path_location, ...)\nAdd or edit a line in the path editor.\nset_fea_path_point(path_name, path_location, ...)\nAdd or edit a point in the path editor."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.pop",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.pop.html#pop",
        "title": "pop",
        "section": "pop",
        "text": "Remove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.add_point",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.add_point.html#add_point",
        "title": "add_point",
        "section": "add_point",
        "text": "Add a new point into region on an existing Line/Arc.\nThe point must already exist on a Line/Arc belonging to the region. The entity will be split\nand 2 new entities created.\nCoordinate at which to add new point"
    },
    {
        "objectID": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.load_script",
        "href": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.load_script.html#load_script",
        "title": "load_script",
        "section": "load_script",
        "text": "Load a script file into Motor-CAD’s internal scripting.\nFull path to the script file, including the file name.\nUse the r'filepath' syntax to force Python to ignore\nspecial characters."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_fixed_temperature_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_fixed_temperature_value.html#clear_fixed_temperature_value",
        "title": "clear_fixed_temperature_value",
        "section": "clear_fixed_temperature_value",
        "text": "Remove a fixed temperature from a node."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_im_saturation_model",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_im_saturation_model.html#calculate_im_saturation_model",
        "title": "calculate_im_saturation_model",
        "section": "calculate_im_saturation_model",
        "text": "Calculate saturation lookup tables for IM machines."
    },
    {
        "objectID": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.get_entities_have_common_coordinate",
        "href": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.get_entities_have_common_coordinate.html#get_entities_have_common_coordinate",
        "title": "get_entities_have_common_coordinate",
        "section": "get_entities_have_common_coordinate",
        "text": "Check whether region entities create a closed region.\nLine or Arc object to check for common coordinate\nLine or Arc object to check for common coordinate"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#contribute",
        "title": "Contribute",
        "section": "Contribute",
        "text": "Overall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys Developer’s Guide. Ensure that you are thoroughly familiar\nwith this guide before attempting to contribute to PyMotorCAD.\nThe following contribution information is specific to PyMotorCAD.\nRun this code to clone and install the latest version of PyMotorCAD in development mode:\nUse the PyMotorCAD Issues\npage to submit questions, report bugs, and request new features. When possible,\nuse these issue templates:\nBug report template\nFeature request template\nDocumentation issue template\nIf your issue does not fit into one of these categories, create your own issue.\nTo reach the project support team, email pyansys.core@ansys.com.\nDocumentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD Documentation.\nIn the upper right corner of the documentation’s title bar, there is an option\nfor switching from viewing the documentation for the latest stable release\nto viewing the documentation for the development version or previously\nreleased versions.\nPyMotorCAD is compliant with the PyAnsys code style. it\nuses the tool pre-commit to enforce the code style.\nYou can install and activate this tool with this code:\nYou can also install this tool as a pre-commit hook by running this command:\nThis way, it’s not possible for you to push code that fails the style checks. For example:\ngit clone https://github.com/ansys/pymotorcad\ncd pymotorcad\npip install --editable ansys-motorcad-core\npip install pre-commit\npre-commit run --all-files\npre-commit install\n$ pre-commit install\n$ git commit -am \"Add a new feature.\"\nblack....................................................................Passed\nblacken-docs.............................................................Passed\nisort....................................................................Passed\nflake8...................................................................Passed\ncodespell................................................................Passed\npydocstyle...............................................................Passed\ncheck for merge conflicts................................................Passed\ndebug statements (python)................................................Passed\nValidate GitHub Workflows................................................Passed"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#clone-the-repository",
        "title": "Contribute > Clone the repository",
        "section": "Clone the repository",
        "text": "Run this code to clone and install the latest version of PyMotorCAD in development mode:\ngit clone https://github.com/ansys/pymotorcad\ncd pymotorcad\npip install --editable ansys-motorcad-core"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#post-issues",
        "title": "Contribute > Post issues",
        "section": "Post issues",
        "text": "Use the PyMotorCAD Issues\npage to submit questions, report bugs, and request new features. When possible,\nuse these issue templates:\nBug report template\nFeature request template\nDocumentation issue template\nIf your issue does not fit into one of these categories, create your own issue.\nTo reach the project support team, email pyansys.core@ansys.com."
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#view-pymotorcad-documentation",
        "title": "Contribute > View PyMotorCAD documentation",
        "section": "View PyMotorCAD documentation",
        "text": "Documentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD Documentation.\nIn the upper right corner of the documentation’s title bar, there is an option\nfor switching from viewing the documentation for the latest stable release\nto viewing the documentation for the development version or previously\nreleased versions."
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#adhere-to-code-style",
        "title": "Contribute > Adhere to code style",
        "section": "Adhere to code style",
        "text": "PyMotorCAD is compliant with the PyAnsys code style. it\nuses the tool pre-commit to enforce the code style.\nYou can install and activate this tool with this code:\nYou can also install this tool as a pre-commit hook by running this command:\nThis way, it’s not possible for you to push code that fails the style checks. For example:\npip install pre-commit\npre-commit run --all-files\npre-commit install\n$ pre-commit install\n$ git commit -am \"Add a new feature.\"\nblack....................................................................Passed\nblacken-docs.............................................................Passed\nisort....................................................................Passed\nflake8...................................................................Passed\ncodespell................................................................Passed\npydocstyle...............................................................Passed\ncheck for merge conflicts................................................Passed\ndebug statements (python)................................................Passed\nValidate GitHub Workflows................................................Passed"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateGenerator_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateGenerator_Lab.html#calculategenerator_lab",
        "title": "CalculateGenerator_Lab",
        "section": "CalculateGenerator_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_generator_lab()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_x",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_x.html#br_x",
        "title": "br_x",
        "section": "br_x",
        "text": "X-axis component of br value."
    },
    {
        "objectID": "getting_started/running_motorcad",
        "href": "getting_started/running_motorcad.html#standard-installation",
        "title": "Standard installation",
        "section": "Standard installation",
        "text": "The PyAnsys ansys-motorcad-core package requires either a local or\nremote instance of Motor-CAD to communicate with it. This section covers\nlaunching and interfacing with Motor-CAD from a local instance by\nlaunching it from Python.\nThe Motor-CAD installer can be downloaded from the Ansys Customer Portal.\nA valid Motor-CAD licence is required to run the software.\nOnce the Windows setup file is downloaded, run this as administrator.\nIt may take up to around 5 minutes to prepare the installation wizard.\nThen follow the steps to proceed with installing Motor-CAD: read and accept the license agreement etc.\nThe installation may take several minutes to complete.\nYou can use the MotorCAD method to have Python start a new instance of Motor-CAD and\nautomatically connect to it:\nThis is the easiest and fastest way to get PyMotorCAD up and running.\nBut you need to have an Ansys license server installed locally.\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "getting_started/running_motorcad",
        "href": "getting_started/running_motorcad.html#install-motor-cad",
        "title": "Standard installation > Install Motor-CAD",
        "section": "Install Motor-CAD",
        "text": "The Motor-CAD installer can be downloaded from the Ansys Customer Portal.\nA valid Motor-CAD licence is required to run the software.\nOnce the Windows setup file is downloaded, run this as administrator.\nIt may take up to around 5 minutes to prepare the installation wizard.\nThen follow the steps to proceed with installing Motor-CAD: read and accept the license agreement etc.\nThe installation may take several minutes to complete."
    },
    {
        "objectID": "getting_started/running_motorcad",
        "href": "getting_started/running_motorcad.html#launch-motor-cad",
        "title": "Standard installation > Launch Motor-CAD",
        "section": "Launch Motor-CAD",
        "text": "You can use the MotorCAD method to have Python start a new instance of Motor-CAD and\nautomatically connect to it:\nThis is the easiest and fastest way to get PyMotorCAD up and running.\nBut you need to have an Ansys license server installed locally.\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "getting_started/running_motorcad",
        "href": "getting_started/running_motorcad.html#launch-motor-cad-locally",
        "title": "Standard installation > Launch Motor-CAD locally",
        "section": "Launch Motor-CAD locally",
        "text": "You can use the MotorCAD method to have Python start a new instance of Motor-CAD and\nautomatically connect to it:\nThis is the easiest and fastest way to get PyMotorCAD up and running.\nBut you need to have an Ansys license server installed locally.\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMotorCADScreenToFile",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMotorCADScreenToFile.html#savemotorcadscreentofile",
        "title": "SaveMotorCADScreenToFile",
        "section": "SaveMotorCADScreenToFile",
        "text": "Deprecated function. Replaced by MotorCAD.save_motorcad_screen_to_file()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate entity around a point for a given angle.\nCoordinate to rotate line around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_winding_pattern",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_winding_pattern.html#load_winding_pattern",
        "title": "load_winding_pattern",
        "section": "load_winding_pattern",
        "text": "Load the winding pattern from a text file.\nAbsolute filepath of the text file to load. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_temperature_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_temperature_graph.html#get_temperature_graph",
        "title": "get_temperature_graph",
        "section": "get_temperature_graph",
        "text": "Get graph points from a Motor-CAD transient temperature graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nvalue of x coordinates from graph\nvalue of y coordinates from graph"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoSlotFiniteElement",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoSlotFiniteElement.html#doslotfiniteelement",
        "title": "DoSlotFiniteElement",
        "section": "DoSlotFiniteElement",
        "text": "Deprecated function. Replaced by MotorCAD.do_slot_finite_element()."
    },
    {
        "objectID": "methods/_autogen_Thermal",
        "href": "methods/_autogen_Thermal.html#thermal",
        "title": "Thermal",
        "section": "Thermal",
        "text": "clear_external_circuit()\nClear the external circuit.\nclear_fixed_temperature_value(node1)\nRemove a fixed temperature from a node.\ncreate_new_node(name, node1, row, column, ...)\nCreate a node.\nget_node_capacitance(node_number)\nGet the capacitance of a thermal node.\nget_node_exists(node_number)\nCheck if a node exists.\nget_node_power(node_number)\nGet the power of a thermal node.\nget_node_temperature(node_number)\nGet the temperature of a thermal node.\nget_node_to_node_resistance(node1, node2)\nGet the node-to-node resistance.\nget_offset_node_number(node_number, ...)\nGet the offset node number.\nload_external_circuit(circuit_file_name)\nLoad an external circuit from a file.\nmodify_node(name, node1, row, column, ...)\nModify an existing node.\nremove_external_component(component_type, ...)\nRemove an external circuit component.\nsave_external_circuit(circuit_file_name)\nSave the external circuit to a file.\nsave_transient_power_values(file_name)\nSave transient power results to a text file.\nsave_transient_temperatures(file_name)\nSave transient temperature results to a text file.\nset_capacitance_value(name, node1, value, ...)\nSet or create a capacitance.\nset_fixed_temperature_value(name, node1, ...)\nSet or create a fixed temperature on a node.\nset_power_injection_value(name, node1, ...)\nSet or create a power injection.\nset_power_source_value(name, node1, value, ...)\nSet or create a power source.\nset_resistance_multiplier(name, node1, ...)\nSet or create a resistance multiplication factor.\nset_resistance_value(name, node1, node2, ...)\nSet or create a resistance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.EditMagnetRegion",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.EditMagnetRegion.html#editmagnetregion",
        "title": "EditMagnetRegion",
        "section": "EditMagnetRegion",
        "text": "Deprecated function. Replaced by MotorCAD.edit_magnet_region()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.from_polar_coords",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.from_polar_coords.html#from_polar_coords",
        "title": "from_polar_coords",
        "section": "from_polar_coords",
        "text": "Create Coordinate from polar coordinates.\nRadial coordinate.\nAngular coordinate."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetPowerGraphPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetPowerGraphPoint.html#getpowergraphpoint",
        "title": "GetPowerGraphPoint",
        "section": "GetPowerGraphPoint",
        "text": "Deprecated function. Replaced by MotorCAD.get_power_graph_point()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fixed_temperature_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fixed_temperature_value.html#set_fixed_temperature_value",
        "title": "set_fixed_temperature_value",
        "section": "set_fixed_temperature_value",
        "text": "Set or create a fixed temperature on a node."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.reverse",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.reverse.html#reverse",
        "title": "reverse",
        "section": "reverse",
        "text": "Reverse EntityList, including entity start end coordinates."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.insert_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.insert_entity.html#insert_entity",
        "title": "insert_entity",
        "section": "insert_entity",
        "text": "Insert entity to list of region entities at given index.\nIndex of which to insert at\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_XY.html#addline_xy",
        "title": "AddLine_XY",
        "section": "AddLine_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_line_xy()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.count",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.count.html#count",
        "title": "count",
        "section": "count",
        "text": "Return number of occurrences of value."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.region_type",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.region_type.html#region_type",
        "title": "region_type",
        "section": "region_type",
        "text": "Get region type."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.html#regionmagnet",
        "title": "RegionMagnet",
        "section": "RegionMagnet",
        "text": "Provides the Python representation of a Motor-CAD magnet geometry region.\nRegionMagnet.add_entity(entity)\nAdd entity to list of region entities.\nRegionMagnet.add_point(point)\nAdd a new point into region on an existing Line/Arc.\nRegionMagnet.collides(regions)\nCheck whether any of the specified regions collide with self.\nRegionMagnet.edit_point(old_coordinates, ...)\nEdit a point in the region and update entities.\nRegionMagnet.find_entity_from_coordinates(...)\nSearch through region to find an entity with start and end coordinates.\nRegionMagnet.from_coordinate_list()\nWork in progress.\nRegionMagnet.insert_entity(index, entity)\nInsert entity to list of region entities at given index.\nRegionMagnet.insert_polyline(index, polyline)\nInsert polyline at given index, polyline can be made up of line/arc entities.\nRegionMagnet.is_closed()\nCheck whether region entities create a closed region.\nRegionMagnet.mirror(mirror_line[, unique_name])\nMirror region along entity.\nRegionMagnet.remove_entity(entity_remove)\nRemove the entity from the region.\nRegionMagnet.replace(replacement_region)\nReplace self with another region.\nRegionMagnet.rotate(centre_point, angle)\nRotate Region around a point for a given angle.\nRegionMagnet.subtract(region)\nSubtract region from self, returning any additional regions.\nRegionMagnet.translate(x, y)\nTranslate Region by specified x,y distances.\nRegionMagnet.unite(regions)\nUnite one or more other regions with self.\nRegionMagnet.update(region)\nUpdate class fields from another region.\nRegionMagnet.br_multiplier\nBr multiplier.\nRegionMagnet.br_used\nBr used after applying Br multiplier.\nRegionMagnet.br_value\nBr value of magnet before Br multiplier applied.\nRegionMagnet.br_x\nX-axis component of br value.\nRegionMagnet.br_y\nY-axis component of the br value.\nRegionMagnet.child_names\nProperty for child names list.\nRegionMagnet.children\nReturn list of child regions from Motor-CAD.\nRegionMagnet.lamination_type\nReturn lamination type of region from Motor-CAD.\nRegionMagnet.linked_region\nGet linked duplication/unite region.\nRegionMagnet.magnet_angle\nAngle of the magnet in degrees.\nRegionMagnet.magnet_polarity\nPolarity of the magnet.\nRegionMagnet.motorcad_instance\nGet linked Motor-CAD instance.\nRegionMagnet.parent\nReturn parent region from Motor-CAD.\nRegionMagnet.parent_name\nGet region parent name.\nRegionMagnet.points\nGet points that exist in region.\nRegionMagnet.region_type\nGet region type.\nRegionMagnet.singular\nGet linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportSolidMaterial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportSolidMaterial.html#exportsolidmaterial",
        "title": "ExportSolidMaterial",
        "section": "ExportSolidMaterial",
        "text": "Deprecated function. Replaced by MotorCAD.export_solid_material()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.insert_polyline",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.insert_polyline.html#insert_polyline",
        "title": "insert_polyline",
        "section": "insert_polyline",
        "text": "Insert polyline at given index, polyline can be made up of line/arc entities.\nIndex of which to insert at\nlist of Line or list of Arc"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RestoreCompatibilitySettings",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RestoreCompatibilitySettings.html#restorecompatibilitysettings",
        "title": "RestoreCompatibilitySettings",
        "section": "RestoreCompatibilitySettings",
        "text": "Deprecated function. Replaced by MotorCAD.restore_compatibility_settings()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_exists",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_exists.html#get_node_exists",
        "title": "get_node_exists",
        "section": "get_node_exists",
        "text": "Check if a node exists.\nThermal node number\nTrue if node exists, False otherwise."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateOptimisedMesh",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateOptimisedMesh.html#createoptimisedmesh",
        "title": "CreateOptimisedMesh",
        "section": "CreateOptimisedMesh",
        "text": "Deprecated function. Replaced by MotorCAD.create_optimised_mesh()."
    },
    {
        "objectID": "examples/advanced/force_extraction",
        "href": "examples/advanced/force_extraction.html#motor-cad-force-extraction-example-script",
        "title": "Motor-CAD force extraction example script",
        "section": "Motor-CAD force extraction example script",
        "text": "todo: expand this…\nPerform required imports\nLaunch Motor-CAD\nDisable pop-up messages\nLoad a baseline model - in this case a template.\nFor users, this would normally be a baseline model\nSet up the point we want to extract\nRun the calculation (Assume that it has already been set up as required)\nHow many cycles have been run\nExtract max space order that exists in the calculation\nGet the indexes to use in querying the force:\nrequired_time_order should always be 0 or positive. This is the order of\nthe number of cycles run, which will be the same as electrical order if\nelectrical_cycles = 1\nResults stored with negative space orders at the end, so apply offset\nFind the force density using GetMagnetic3DGraphPoint:\nNote the use of _Th1 for the 1st operating point in the name.\nApply 2x factor due to FFT symmetry, unless 0th time order (mean)\nThis is equivalent to showing results with ‘Positive time only’\nTotal running time of the script: (2 minutes 42.315 seconds)\nDownload Jupyter notebook: force_extraction.ipynb\nDownload Python source code: force_extraction.py\nDownload zipped: force_extraction.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\nmc = pymotorcad.MotorCAD()\nmc.set_variable(\"MessageDisplayState\", 2)\nmc.load_template(\"e9\")\nrequired_space_order = 8  # Space order required, positive or negative\nrequired_electrical_time_order = 2  # Electrical time order required, should be 0 or positive\noperating_point = (\n    1  # Which speed point to extract data for (between 1 and the number of calculations run)\n)\nrotor_slice = 1  # Which rotor slice (if more than one) that we want results from\nmc.do_multi_force_calculation()\nelectrical_cycles = mc.get_variable(\"TorqueNumberCycles\")\nmech_force_space_order_max = mc.get_variable(\"ForceMaxOrder_Space_Stator_OL\")\nrequired_time_order = required_electrical_time_order * electrical_cycles\nif required_space_order < 0:\n    required_space_order = required_space_order + 2 * mech_force_space_order_max\n_, force_density_result = mc.get_magnetic_3d_graph_point(\n    \"Fr_Density_Stator_FFT_Amplitude_OL\" + \"_Th\" + str(operating_point),\n    rotor_slice,\n    required_space_order,\n    required_time_order,\n)\nif required_time_order > 0:\n    force_density_result = force_density_result * 2\nprint(\"Force density: \" + str(force_density_result))\nForce density: 122696.3686592"
    },
    {
        "objectID": "examples/advanced/force_extraction",
        "href": "examples/advanced/force_extraction.html#results",
        "title": "Motor-CAD force extraction example script > Results",
        "section": "Results",
        "text": "Total running time of the script: (2 minutes 42.315 seconds)\nDownload Jupyter notebook: force_extraction.ipynb\nDownload Python source code: force_extraction.py\nDownload zipped: force_extraction.zip\nGallery generated by Sphinx-Gallery\nprint(\"Force density: \" + str(force_density_result))\nForce density: 122696.3686592"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.children",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.children.html#children",
        "title": "children",
        "section": "children",
        "text": "Return list of child regions from Motor-CAD.\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.run_script",
        "href": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.run_script.html#run_script",
        "title": "run_script",
        "section": "run_script",
        "text": "Run the script file in Motor-CAD’s internal scripting."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateNewNode",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateNewNode.html#createnewnode",
        "title": "CreateNewNode",
        "section": "CreateNewNode",
        "text": "Deprecated function. Replaced by MotorCAD.create_new_node()."
    },
    {
        "objectID": "examples/basics/index",
        "href": "examples/basics/index.html#basic-examples",
        "title": "Basic examples",
        "section": "Basic examples",
        "text": "These examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_basics_emag_basics.py\nsphx_glr_examples_basics_lab_basics.py\nsphx_glr_examples_basics_thermal_basics.py"
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.get_model_built_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.get_model_built_lab.html#get_model_built_lab",
        "title": "get_model_built_lab",
        "section": "get_model_built_lab",
        "text": "Test if the Lab model must be built or rebuilt before running calculations.\nTrue if the Lab model has been built and is valid for the current settings,\nFalse otherwise."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.create_optimised_mesh",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.create_optimised_mesh.html#create_optimised_mesh",
        "title": "create_optimised_mesh",
        "section": "create_optimised_mesh",
        "text": "Create the FEA geometry and an optimized mesh.\nCall this method at the end of creating a custom scripting geometry.\nDeprecated since version 0.6.0: create_optimised_mesh will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveScript",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveScript.html#savescript",
        "title": "SaveScript",
        "section": "SaveScript",
        "text": "Deprecated function. Replaced by MotorCAD.save_script()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.quit",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.quit.html#quit",
        "title": "quit",
        "section": "quit",
        "text": "Quit Motor-CAD."
    },
    {
        "objectID": "examples/adaptive_library/sg_execution_times",
        "href": "examples/adaptive_library/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "04:00.770 total execution time for 6 files from examplesadaptive_library:\nExample\nTime\nMem (MB)\nsphx_glr_examples_adaptive_library_BezierCurveRotorPockets.py (BezierCurveRotorPockets.py)\n00:57.142\n0.0\nsphx_glr_examples_adaptive_library_TrapezoidalDuct.py (TrapezoidalDuct.py)\n00:51.142\n0.0\nsphx_glr_examples_adaptive_library_DXFImport.py (DXFImport.py)\n00:39.673\n0.0\nsphx_glr_examples_adaptive_library_OblongStatorDuct.py (OblongStatorDuct.py)\n00:34.844\n0.0\nsphx_glr_examples_adaptive_library_UShapeSYNCRELCurvedFluxBarriers.py (UShapeSYNCRELCurvedFluxBarriers.py)\n00:29.813\n0.0\nsphx_glr_examples_adaptive_library_BPMTriangularRotorNotches.py (BPMTriangularRotorNotches.py)\n00:28.157\n0.0"
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_xy.html#add_arc_xy",
        "title": "add_arc_xy",
        "section": "add_arc_xy",
        "text": "Add an arc to the Motor-CAD axial geometry with an x, y coordinate system.\nThis method uses the center point, radius, and angles. Use degrees for angles.\nCenter position for the x coordinate.\nCenter position for the x coordinate.\nAngular coordinate of the arc start point in degrees.\nAngular coordinate of the arc end point in degrees.\nRadius of the arc from the center point.\nadd_arc_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadDXFFile",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadDXFFile.html#loaddxffile",
        "title": "LoadDXFFile",
        "section": "LoadDXFFile",
        "text": "Deprecated function. Replaced by MotorCAD.load_dxf_file()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RunScript",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.RunScript.html#runscript",
        "title": "RunScript",
        "section": "RunScript",
        "text": "Deprecated function. Replaced by MotorCAD.run_script()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_value",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_value.html#br_value",
        "title": "br_value",
        "section": "br_value",
        "text": "Br value of magnet before Br multiplier applied."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_rt.html#add_line_rt",
        "title": "add_line_rt",
        "section": "add_line_rt",
        "text": "Add a line to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nUse degrees for angles.\nStart position for the radial coordinate.\nStart position for the angular coordinate in degrees.\nEnd position for the radial coordinate.\nEnd position for the angular coordinate in degrees.\nadd_line_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.reset_regions",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.reset_regions.html#reset_regions",
        "title": "reset_regions",
        "section": "reset_regions",
        "text": "Reset custom FEA regions to standard regions from the Motor-CAD template geometry.\nDeprecated since version 0.6.0: reset_regions will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.initiate_geometry_from_script",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.initiate_geometry_from_script.html#initiate_geometry_from_script",
        "title": "initiate_geometry_from_script",
        "section": "initiate_geometry_from_script",
        "text": "Initiate the geometry from scripting so Motor-CAD knows how to use it.\nThis method clears the current scripting geometry.\nThe clear_all_data method must be called before this method is called.\nDeprecated since version 0.6.0: initiate_geometry_from_script will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.is_closed",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.is_closed.html#is_closed",
        "title": "is_closed",
        "section": "is_closed",
        "text": "Check whether region entities create a closed region.\nWhether region is closed"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportMatrices",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportMatrices.html#exportmatrices",
        "title": "ExportMatrices",
        "section": "ExportMatrices",
        "text": "Deprecated function. Replaced by MotorCAD.export_matrices()."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_magnetic_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_magnetic_lab.html#calculate_magnetic_lab",
        "title": "calculate_magnetic_lab",
        "section": "calculate_magnetic_lab",
        "text": "Run the Lab magnetic calculation."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoTransientAnalysis",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoTransientAnalysis.html#dotransientanalysis",
        "title": "DoTransientAnalysis",
        "section": "DoTransientAnalysis",
        "text": "Deprecated function. Replaced by MotorCAD.do_transient_analysis()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.child_names",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.child_names.html#child_names",
        "title": "child_names",
        "section": "child_names",
        "text": "Property for child names list.\nlist of child region names"
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_array_variable",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_array_variable.html#get_array_variable",
        "title": "get_array_variable",
        "section": "get_array_variable",
        "text": "Get a Motor-CAD array variable.\nName of the array.\nPosition variable in the array.\nValue of the Motor-CAD variable"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#curved-rotor-flux-barriers-for-syncrel-u-shape",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape",
        "section": "Curved Rotor Flux Barriers for SYNCREL U-Shape",
        "text": "This script applies the adaptive templates functionality to alter SYNCREL U-Shape rotor template to\nuse curved rotor pockets.\nFor more information on the use of Adaptive Templates in Motor-CAD,\nand how to create, modify and debug Adaptive Templates Scripts,\nsee ref_adaptive_templates_UG in the ref_user_guide.\nAdaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later and\nPyMotorCAD v0.4.1. To update PyMotorCAD in Motor-CAD, go to Scripting -> Settings -> PyMotorCAD\nupdates and select ‘Update to Latest Release’.\nThis script does not support:\nZero inner/outer layer thickness\nInner/outer posts\nThis script is designed to be run from Motor-CAD template “i3”.\nIf no Motor-CAD file is open,\nthe i3 template will be loaded.\nTo set an adaptive geometry for a Motor-CAD file,\na script must be loaded in to the Adaptive Templates tab\n(Geometry -> Editor -> Adaptive Templates) in Motor-CAD\nand run.\nWhen the option ‘Geometry Templates Type’ is set to ‘Adaptive’,\nthis script is automatically run repeatedly\nto keep the Adaptive Geometry set in Motor-CAD.\nThis Python script can also be executed externally,\nbut unless the script is loaded in to the Adaptive Templates tab\nin Motor-CAD, the geometry will only be defined temporarily.\nImport pymotorcad to access Motor-CAD.\nImport Arc, Coordinate, Line, Region and rt_to_xy\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe i3 SYNC motor template is loaded, and the file is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True)  option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nThis example Adaptive Templates Script works by defining\na number of required functions.\nThese functions are then called within a for loop,\nwhich executes the script for each rotor duct layer.\nDefine a function to get the radius and centre of a barrier arc.\nParameters:\ncoordinate_1 : Coordinate, Arc start coordinate.\ncoordinate_2 : Coordinate, Extra coordinate on arc\ncoordinate_3 : Coordinate, Arc end coordinate\narc_direction : Integer, Direction to create arc between start/end\nReturns:\nradius : float, Arc radius\ncentre : Coordinate, Arc centre coordinate\nDefine a function to determine whether corner rounding should be applied to pocket.\nReturns a boolean.\nReturns True if Corner Rounding is selected for the Rotor in the Motor-CAD\nfile, and if the Corner Rounding radius is set to a non-zero value.\nDefine a function to create mirror line through rotor from origin to airgap.\nReturns a Line.\nGet the rotor diameter and pole number from the Motor-CAD file.\nCalculate the airgap coordinates.\nDefine a function to get a list of coordinates\nfrom the pocket using coordinate_indices.\nOrder of coordinates: start, end, extra coordinate on arc.\nParameters:\npocket : Region, Pocket region\ncoordinate_indices : list of integer, Pocket region coordinate indices\nmirror_line : Line, Mirror line to generate extra coordinate on arc\nReturns\nlist of Coordinates\nLoop through coordinates and add to a list.\nMirror the first coordinate to generate the third coordinate on the arc.\nDefine functions to get a list of coordinates\nto use to generate the top and bottom arcs for pocket.\nReturn coordinates at indices from pocket.points.\nThese indices match up with coordinates from each pocket region\nwith/without corner rounding.\nOrder of coordinates: [start, end, centre, start, end, centre]\nIndices have been selected using Motor-CAD geometry editor.\nFor no centre post:\nParameters:\npocket : Region, Pocket region\nReturns\nlist of Coordinates\nFor centre post:\nParameters:\npocket : Region, Pocket region\nReturns:\nlist of Coordinates\nMirror required to generate the third point on arc.\nThis third point is required to calculate the centre and radius of arc.\nThe mirror line mirrors the start point of each pocket arc\nto generate this third point.\nDefine a function to update the pocket entities\nto create a curved pocket using input coordinates.\nParameters:\npocket : Region, Pocket region\ncoordinates : list of Coordinate, Coordinates to generate arcs with in region\nCreate a list of arc entities from the coordinates.\nRemove the entities between the start and end coordinates\nof each arc, then insert into the pocket.\nDefine a function to return the unique pocket name\nused in Motor-CAD.\nParameters:\nindex : integer, Current pocket index\nReturns:\nstring\nGet the number of layers in the rotor for the Motor-CAD file\nFor each layer:\nGet the U-Shape layer parameters\nRaise an exception if the curved barrier\ncan’t be created for a layer\ndue to the thickness being zero\nRaise an exception if the curved barrier\ncan’t be created for a layer\ndue to the post width being zero\nGet the pocket from Motor-CAD using unique name\nDetermine whether there are 1 or 2 pockets in the layer\nand get the new coordinates\nUpdate the rotor pocket geometry with the new coordinates\nSet the updated pocket region in Motor-CAD\nIf there are 2 pockets in the layer,\nthe left pocket region is updated first.\nThis is then mirrored to update the right pocket region.\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 29.813 seconds)\nDownload Jupyter notebook: UShapeSYNCRELCurvedFluxBarriers.ipynb\nDownload Python source code: UShapeSYNCRELCurvedFluxBarriers.py\nDownload zipped: UShapeSYNCRELCurvedFluxBarriers.zip\nGallery generated by Sphinx-Gallery\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy, xy_to_rt\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"i3\")\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"SYNCRELCurvedFluxBarriers\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\ndef get_barrier_centre_and_radius(coordinate_1, coordinate_2, coordinate_3, arc_direction):\n    _, start_t = xy_to_rt(coordinate_1.x, coordinate_1.y)\n    _, end_t = xy_to_rt(coordinate_3.x, coordinate_3.y)\n\n    a = (\n        coordinate_1.x * (coordinate_2.y - coordinate_3.y)\n        - coordinate_1.y * (coordinate_2.x - coordinate_3.x)\n        + coordinate_2.x * coordinate_3.y\n        - coordinate_3.x * coordinate_2.y\n    )\n    b = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_3.y - coordinate_2.y)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_1.y - coordinate_3.y)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_2.y - coordinate_1.y)\n    )\n    c = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_2.x - coordinate_3.x)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_3.x - coordinate_1.x)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_1.x - coordinate_2.x)\n    )\n    centre = Coordinate((-b / a) / 2, (-c / a) / 2)\n    radius = Line(centre, coordinate_1).length * arc_direction\n\n    return radius, centre\ndef get_pockets_include_corner_rounding():\n    return (mc.get_variable(\"CornerRounding_Rotor\") == 1) and (\n        mc.get_variable(\"CornerRoundingRadius_Rotor\") > 0\n    )\ndef get_rotor_mirror_line():\n    rotor_radius = mc.get_variable(\"RotorDiameter\")\n    number_poles = mc.get_variable(\"Pole_Number\")\n    airgap_centre_x, airgap_centre_y = rt_to_xy(rotor_radius, (360 / number_poles) / 2)\n\n    return Line(Coordinate(0, 0), Coordinate(airgap_centre_x, airgap_centre_y))\ndef get_coordinates(pocket, coordinate_indices, mirror_line=None):\n    coordinates = [pocket.points[index] for index in coordinate_indices]\n    if mirror_line is not None:\n        coordinates.append(coordinates[0].mirror(mirror_line))\n\n    return coordinates\ndef get_coordinates_no_centre_post(pocket):\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 8, 5, 11, 17, 14])\n    else:\n        return get_coordinates(pocket, [1, 5, 3, 6, 0, 8])\ndef get_coordinates_centre_post(pocket):\n    mirror = get_rotor_mirror_line()\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 5], mirror) + get_coordinates(\n            pocket, [8, 11], mirror_line=mirror\n        )\n    else:\n        return get_coordinates(pocket, [1, 3], mirror) + get_coordinates(\n            pocket, [4, 0], mirror_line=mirror\n        )\ndef update_pocket_geometry(pocket, coordinates):\n    entities = []\n    # create list of arc entities from coordinates\n    for element in range(0, len(coordinates), 3):\n        if (element + 1) % 2 == 0:\n            # clockwise arc\n            arc_direction = -1\n        else:\n            # ant-clockwise arc\n            arc_direction = 1\n\n        # get arc radius and centre point from three coordinates across the arc\n        radius, centre = get_barrier_centre_and_radius(\n            coordinates[element],  # arc start coordinate\n            coordinates[element + 1],  # arc end coordinate\n            coordinates[element + 2],  # arc third coordinate\n            arc_direction,\n        )\n        entities.append(\n            Arc(\n                coordinates[element],\n                coordinates[element + 1],\n                centre,\n                radius,\n            )\n        )\n    # remove entities between start and end coordinates of each arc then insert into pocket\n    for count, element in enumerate(range(0, len(coordinates), 3)):\n        start_index = pocket.points.index(coordinates[element])\n        end_index = pocket.points.index(coordinates[element + 1])\n        if end_index == 0:\n            end_index = len(pocket.points)\n\n        # use index of start/end coordinates to remove pockets entities between them\n        for index in reversed(range(start_index, end_index)):\n            pocket.entities.pop(index)\n\n        pocket.insert_entity(start_index, entities[count])\ndef get_pocket_name(index):\n    if index == 0:\n        return \"Rotor Pocket\"\n    else:\n        return \"Rotor Pocket_\" + str(index)\npocket_number = 0\nnumber_layers = mc.get_variable(\"Magnet_Layers\")\nfor layer in range(number_layers):\n    # get U-Shape layer parameters\n    outer_thickness = mc.get_array_variable(\"UShape_Thickness_Outer_Array\", layer)\n    outer_post_width = mc.get_array_variable(\"UShape_Post_Outer_Array\", layer)\n    inner_thickness = mc.get_array_variable(\"UShape_Thickness_Inner_Array\", layer)\n    inner_post_width = mc.get_array_variable(\"UShape_Post_Inner_Array\", layer)\n    centre_post_width = mc.get_array_variable(\"UShape_CentrePost_Array\", layer)\n\n    if (inner_thickness == 0) or (outer_thickness == 0):\n        message_string = (\n            \"Unable to create curved barrier for layer \"\n            + str(layer)\n            + \". No inner/outer thickness.\"\n        )\n        raise Exception(message_string)\n    elif (outer_post_width > 0) or (inner_post_width > 0):\n        message_string = (\n            \"Unable to create curved barrier for layer \"\n            + str(layer)\n            + \". Inner/Outer post width > 0\"\n        )\n        raise Exception(message_string)\n\n    # get pocket from Motor-CAD using unique name\n    pocket_left = mc.get_region(get_pocket_name(pocket_number))\n\n    if centre_post_width == 0:\n        # no centre post, single rotor pocket in layer\n        new_coordinates = get_coordinates_no_centre_post(pocket_left)\n    else:\n        # centre post, two pockets per layer\n        new_coordinates = get_coordinates_centre_post(pocket_left)\n\n    update_pocket_geometry(pocket_left, new_coordinates)\n    # increment pocket number to get next pocket from Motor-CAD\n    pocket_number += 1\n\n    if pocket_left.is_closed():\n        # set region back into Motor-CAD\n        mc.set_region(pocket_left)\n\n    if centre_post_width > 0:\n        # mirror left barrier/pocket region across the rotor using mirror line\n        pocket_right = pocket_left.mirror(get_rotor_mirror_line(), unique_name=False)\n        pocket_right.name = get_pocket_name(pocket_number)\n        # increment pocket number to get next pocket from Motor-CAD\n        pocket_number += 1\n\n        if pocket_right.is_closed():\n            # set region back into Motor-CAD\n            mc.set_region(pocket_right)\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#perform-required-imports",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Perform required imports",
        "section": "Perform required imports",
        "text": "Import pymotorcad to access Motor-CAD.\nImport Arc, Coordinate, Line, Region and rt_to_xy\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy, xy_to_rt"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#connect-to-motor-cad",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe i3 SYNC motor template is loaded, and the file is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True)  option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"i3\")\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"SYNCRELCurvedFluxBarriers\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#define-functions-for-the-adaptive-templates-script",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Define functions for the Adaptive Templates script",
        "section": "Define functions for the Adaptive Templates script",
        "text": "This example Adaptive Templates Script works by defining\na number of required functions.\nThese functions are then called within a for loop,\nwhich executes the script for each rotor duct layer.\nDefine a function to get the radius and centre of a barrier arc.\nParameters:\ncoordinate_1 : Coordinate, Arc start coordinate.\ncoordinate_2 : Coordinate, Extra coordinate on arc\ncoordinate_3 : Coordinate, Arc end coordinate\narc_direction : Integer, Direction to create arc between start/end\nReturns:\nradius : float, Arc radius\ncentre : Coordinate, Arc centre coordinate\nDefine a function to determine whether corner rounding should be applied to pocket.\nReturns a boolean.\nReturns True if Corner Rounding is selected for the Rotor in the Motor-CAD\nfile, and if the Corner Rounding radius is set to a non-zero value.\nDefine a function to create mirror line through rotor from origin to airgap.\nReturns a Line.\nGet the rotor diameter and pole number from the Motor-CAD file.\nCalculate the airgap coordinates.\nDefine a function to get a list of coordinates\nfrom the pocket using coordinate_indices.\nOrder of coordinates: start, end, extra coordinate on arc.\nParameters:\npocket : Region, Pocket region\ncoordinate_indices : list of integer, Pocket region coordinate indices\nmirror_line : Line, Mirror line to generate extra coordinate on arc\nReturns\nlist of Coordinates\nLoop through coordinates and add to a list.\nMirror the first coordinate to generate the third coordinate on the arc.\nDefine functions to get a list of coordinates\nto use to generate the top and bottom arcs for pocket.\nReturn coordinates at indices from pocket.points.\nThese indices match up with coordinates from each pocket region\nwith/without corner rounding.\nOrder of coordinates: [start, end, centre, start, end, centre]\nIndices have been selected using Motor-CAD geometry editor.\nFor no centre post:\nParameters:\npocket : Region, Pocket region\nReturns\nlist of Coordinates\nFor centre post:\nParameters:\npocket : Region, Pocket region\nReturns:\nlist of Coordinates\nMirror required to generate the third point on arc.\nThis third point is required to calculate the centre and radius of arc.\nThe mirror line mirrors the start point of each pocket arc\nto generate this third point.\nDefine a function to update the pocket entities\nto create a curved pocket using input coordinates.\nParameters:\npocket : Region, Pocket region\ncoordinates : list of Coordinate, Coordinates to generate arcs with in region\nCreate a list of arc entities from the coordinates.\nRemove the entities between the start and end coordinates\nof each arc, then insert into the pocket.\nDefine a function to return the unique pocket name\nused in Motor-CAD.\nParameters:\nindex : integer, Current pocket index\nReturns:\nstring\ndef get_barrier_centre_and_radius(coordinate_1, coordinate_2, coordinate_3, arc_direction):\n    _, start_t = xy_to_rt(coordinate_1.x, coordinate_1.y)\n    _, end_t = xy_to_rt(coordinate_3.x, coordinate_3.y)\n\n    a = (\n        coordinate_1.x * (coordinate_2.y - coordinate_3.y)\n        - coordinate_1.y * (coordinate_2.x - coordinate_3.x)\n        + coordinate_2.x * coordinate_3.y\n        - coordinate_3.x * coordinate_2.y\n    )\n    b = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_3.y - coordinate_2.y)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_1.y - coordinate_3.y)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_2.y - coordinate_1.y)\n    )\n    c = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_2.x - coordinate_3.x)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_3.x - coordinate_1.x)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_1.x - coordinate_2.x)\n    )\n    centre = Coordinate((-b / a) / 2, (-c / a) / 2)\n    radius = Line(centre, coordinate_1).length * arc_direction\n\n    return radius, centre\ndef get_pockets_include_corner_rounding():\n    return (mc.get_variable(\"CornerRounding_Rotor\") == 1) and (\n        mc.get_variable(\"CornerRoundingRadius_Rotor\") > 0\n    )\ndef get_rotor_mirror_line():\n    rotor_radius = mc.get_variable(\"RotorDiameter\")\n    number_poles = mc.get_variable(\"Pole_Number\")\n    airgap_centre_x, airgap_centre_y = rt_to_xy(rotor_radius, (360 / number_poles) / 2)\n\n    return Line(Coordinate(0, 0), Coordinate(airgap_centre_x, airgap_centre_y))\ndef get_coordinates(pocket, coordinate_indices, mirror_line=None):\n    coordinates = [pocket.points[index] for index in coordinate_indices]\n    if mirror_line is not None:\n        coordinates.append(coordinates[0].mirror(mirror_line))\n\n    return coordinates\ndef get_coordinates_no_centre_post(pocket):\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 8, 5, 11, 17, 14])\n    else:\n        return get_coordinates(pocket, [1, 5, 3, 6, 0, 8])\ndef get_coordinates_centre_post(pocket):\n    mirror = get_rotor_mirror_line()\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 5], mirror) + get_coordinates(\n            pocket, [8, 11], mirror_line=mirror\n        )\n    else:\n        return get_coordinates(pocket, [1, 3], mirror) + get_coordinates(\n            pocket, [4, 0], mirror_line=mirror\n        )\ndef update_pocket_geometry(pocket, coordinates):\n    entities = []\n    # create list of arc entities from coordinates\n    for element in range(0, len(coordinates), 3):\n        if (element + 1) % 2 == 0:\n            # clockwise arc\n            arc_direction = -1\n        else:\n            # ant-clockwise arc\n            arc_direction = 1\n\n        # get arc radius and centre point from three coordinates across the arc\n        radius, centre = get_barrier_centre_and_radius(\n            coordinates[element],  # arc start coordinate\n            coordinates[element + 1],  # arc end coordinate\n            coordinates[element + 2],  # arc third coordinate\n            arc_direction,\n        )\n        entities.append(\n            Arc(\n                coordinates[element],\n                coordinates[element + 1],\n                centre,\n                radius,\n            )\n        )\n    # remove entities between start and end coordinates of each arc then insert into pocket\n    for count, element in enumerate(range(0, len(coordinates), 3)):\n        start_index = pocket.points.index(coordinates[element])\n        end_index = pocket.points.index(coordinates[element + 1])\n        if end_index == 0:\n            end_index = len(pocket.points)\n\n        # use index of start/end coordinates to remove pockets entities between them\n        for index in reversed(range(start_index, end_index)):\n            pocket.entities.pop(index)\n\n        pocket.insert_entity(start_index, entities[count])\ndef get_pocket_name(index):\n    if index == 0:\n        return \"Rotor Pocket\"\n    else:\n        return \"Rotor Pocket_\" + str(index)"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#calculate-barrier-arc-centre-and-radius-coordinates",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Calculate barrier arc centre and radius coordinates",
        "section": "Calculate barrier arc centre and radius coordinates",
        "text": "Define a function to get the radius and centre of a barrier arc.\nParameters:\ncoordinate_1 : Coordinate, Arc start coordinate.\ncoordinate_2 : Coordinate, Extra coordinate on arc\ncoordinate_3 : Coordinate, Arc end coordinate\narc_direction : Integer, Direction to create arc between start/end\nReturns:\nradius : float, Arc radius\ncentre : Coordinate, Arc centre coordinate\ndef get_barrier_centre_and_radius(coordinate_1, coordinate_2, coordinate_3, arc_direction):\n    _, start_t = xy_to_rt(coordinate_1.x, coordinate_1.y)\n    _, end_t = xy_to_rt(coordinate_3.x, coordinate_3.y)\n\n    a = (\n        coordinate_1.x * (coordinate_2.y - coordinate_3.y)\n        - coordinate_1.y * (coordinate_2.x - coordinate_3.x)\n        + coordinate_2.x * coordinate_3.y\n        - coordinate_3.x * coordinate_2.y\n    )\n    b = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_3.y - coordinate_2.y)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_1.y - coordinate_3.y)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_2.y - coordinate_1.y)\n    )\n    c = (\n        (coordinate_1.x**2 + coordinate_1.y**2) * (coordinate_2.x - coordinate_3.x)\n        + (coordinate_2.x**2 + coordinate_2.y**2) * (coordinate_3.x - coordinate_1.x)\n        + (coordinate_3.x**2 + coordinate_3.y**2) * (coordinate_1.x - coordinate_2.x)\n    )\n    centre = Coordinate((-b / a) / 2, (-c / a) / 2)\n    radius = Line(centre, coordinate_1).length * arc_direction\n\n    return radius, centre"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#whether-corner-rounding-should-be-applied-to-pocket",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Whether corner rounding should be applied to pocket",
        "section": "Whether corner rounding should be applied to pocket",
        "text": "Define a function to determine whether corner rounding should be applied to pocket.\nReturns a boolean.\nReturns True if Corner Rounding is selected for the Rotor in the Motor-CAD\nfile, and if the Corner Rounding radius is set to a non-zero value.\ndef get_pockets_include_corner_rounding():\n    return (mc.get_variable(\"CornerRounding_Rotor\") == 1) and (\n        mc.get_variable(\"CornerRoundingRadius_Rotor\") > 0\n    )"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#create-a-rotor-mirror-line",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Create a rotor mirror line",
        "section": "Create a rotor mirror line",
        "text": "Define a function to create mirror line through rotor from origin to airgap.\nReturns a Line.\nGet the rotor diameter and pole number from the Motor-CAD file.\nCalculate the airgap coordinates.\ndef get_rotor_mirror_line():\n    rotor_radius = mc.get_variable(\"RotorDiameter\")\n    number_poles = mc.get_variable(\"Pole_Number\")\n    airgap_centre_x, airgap_centre_y = rt_to_xy(rotor_radius, (360 / number_poles) / 2)\n\n    return Line(Coordinate(0, 0), Coordinate(airgap_centre_x, airgap_centre_y))"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#get-list-of-coordinates",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Get list of coordinates",
        "section": "Get list of coordinates",
        "text": "Define a function to get a list of coordinates\nfrom the pocket using coordinate_indices.\nOrder of coordinates: start, end, extra coordinate on arc.\nParameters:\npocket : Region, Pocket region\ncoordinate_indices : list of integer, Pocket region coordinate indices\nmirror_line : Line, Mirror line to generate extra coordinate on arc\nReturns\nlist of Coordinates\nLoop through coordinates and add to a list.\nMirror the first coordinate to generate the third coordinate on the arc.\ndef get_coordinates(pocket, coordinate_indices, mirror_line=None):\n    coordinates = [pocket.points[index] for index in coordinate_indices]\n    if mirror_line is not None:\n        coordinates.append(coordinates[0].mirror(mirror_line))\n\n    return coordinates"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#get-list-of-coordinates-for-pocket-arcs",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Get list of coordinates for pocket arcs",
        "section": "Get list of coordinates for pocket arcs",
        "text": "Define functions to get a list of coordinates\nto use to generate the top and bottom arcs for pocket.\nReturn coordinates at indices from pocket.points.\nThese indices match up with coordinates from each pocket region\nwith/without corner rounding.\nOrder of coordinates: [start, end, centre, start, end, centre]\nIndices have been selected using Motor-CAD geometry editor.\nFor no centre post:\nParameters:\npocket : Region, Pocket region\nReturns\nlist of Coordinates\nFor centre post:\nParameters:\npocket : Region, Pocket region\nReturns:\nlist of Coordinates\nMirror required to generate the third point on arc.\nThis third point is required to calculate the centre and radius of arc.\nThe mirror line mirrors the start point of each pocket arc\nto generate this third point.\ndef get_coordinates_no_centre_post(pocket):\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 8, 5, 11, 17, 14])\n    else:\n        return get_coordinates(pocket, [1, 5, 3, 6, 0, 8])\ndef get_coordinates_centre_post(pocket):\n    mirror = get_rotor_mirror_line()\n    if get_pockets_include_corner_rounding():\n        return get_coordinates(pocket, [2, 5], mirror) + get_coordinates(\n            pocket, [8, 11], mirror_line=mirror\n        )\n    else:\n        return get_coordinates(pocket, [1, 3], mirror) + get_coordinates(\n            pocket, [4, 0], mirror_line=mirror\n        )"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#update-pocket-geometry",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Update pocket geometry",
        "section": "Update pocket geometry",
        "text": "Define a function to update the pocket entities\nto create a curved pocket using input coordinates.\nParameters:\npocket : Region, Pocket region\ncoordinates : list of Coordinate, Coordinates to generate arcs with in region\nCreate a list of arc entities from the coordinates.\nRemove the entities between the start and end coordinates\nof each arc, then insert into the pocket.\ndef update_pocket_geometry(pocket, coordinates):\n    entities = []\n    # create list of arc entities from coordinates\n    for element in range(0, len(coordinates), 3):\n        if (element + 1) % 2 == 0:\n            # clockwise arc\n            arc_direction = -1\n        else:\n            # ant-clockwise arc\n            arc_direction = 1\n\n        # get arc radius and centre point from three coordinates across the arc\n        radius, centre = get_barrier_centre_and_radius(\n            coordinates[element],  # arc start coordinate\n            coordinates[element + 1],  # arc end coordinate\n            coordinates[element + 2],  # arc third coordinate\n            arc_direction,\n        )\n        entities.append(\n            Arc(\n                coordinates[element],\n                coordinates[element + 1],\n                centre,\n                radius,\n            )\n        )\n    # remove entities between start and end coordinates of each arc then insert into pocket\n    for count, element in enumerate(range(0, len(coordinates), 3)):\n        start_index = pocket.points.index(coordinates[element])\n        end_index = pocket.points.index(coordinates[element + 1])\n        if end_index == 0:\n            end_index = len(pocket.points)\n\n        # use index of start/end coordinates to remove pockets entities between them\n        for index in reversed(range(start_index, end_index)):\n            pocket.entities.pop(index)\n\n        pocket.insert_entity(start_index, entities[count])"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#get-unique-pocket-name",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Get unique pocket name",
        "section": "Get unique pocket name",
        "text": "Define a function to return the unique pocket name\nused in Motor-CAD.\nParameters:\nindex : integer, Current pocket index\nReturns:\nstring\ndef get_pocket_name(index):\n    if index == 0:\n        return \"Rotor Pocket\"\n    else:\n        return \"Rotor Pocket_\" + str(index)"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#create-the-adaptive-templates-geometry",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Create the Adaptive Templates geometry",
        "section": "Create the Adaptive Templates geometry",
        "text": "Get the number of layers in the rotor for the Motor-CAD file\nFor each layer:\nGet the U-Shape layer parameters\nRaise an exception if the curved barrier\ncan’t be created for a layer\ndue to the thickness being zero\nRaise an exception if the curved barrier\ncan’t be created for a layer\ndue to the post width being zero\nGet the pocket from Motor-CAD using unique name\nDetermine whether there are 1 or 2 pockets in the layer\nand get the new coordinates\nUpdate the rotor pocket geometry with the new coordinates\nSet the updated pocket region in Motor-CAD\nIf there are 2 pockets in the layer,\nthe left pocket region is updated first.\nThis is then mirrored to update the right pocket region.\npocket_number = 0\nnumber_layers = mc.get_variable(\"Magnet_Layers\")\nfor layer in range(number_layers):\n    # get U-Shape layer parameters\n    outer_thickness = mc.get_array_variable(\"UShape_Thickness_Outer_Array\", layer)\n    outer_post_width = mc.get_array_variable(\"UShape_Post_Outer_Array\", layer)\n    inner_thickness = mc.get_array_variable(\"UShape_Thickness_Inner_Array\", layer)\n    inner_post_width = mc.get_array_variable(\"UShape_Post_Inner_Array\", layer)\n    centre_post_width = mc.get_array_variable(\"UShape_CentrePost_Array\", layer)\n\n    if (inner_thickness == 0) or (outer_thickness == 0):\n        message_string = (\n            \"Unable to create curved barrier for layer \"\n            + str(layer)\n            + \". No inner/outer thickness.\"\n        )\n        raise Exception(message_string)\n    elif (outer_post_width > 0) or (inner_post_width > 0):\n        message_string = (\n            \"Unable to create curved barrier for layer \"\n            + str(layer)\n            + \". Inner/Outer post width > 0\"\n        )\n        raise Exception(message_string)\n\n    # get pocket from Motor-CAD using unique name\n    pocket_left = mc.get_region(get_pocket_name(pocket_number))\n\n    if centre_post_width == 0:\n        # no centre post, single rotor pocket in layer\n        new_coordinates = get_coordinates_no_centre_post(pocket_left)\n    else:\n        # centre post, two pockets per layer\n        new_coordinates = get_coordinates_centre_post(pocket_left)\n\n    update_pocket_geometry(pocket_left, new_coordinates)\n    # increment pocket number to get next pocket from Motor-CAD\n    pocket_number += 1\n\n    if pocket_left.is_closed():\n        # set region back into Motor-CAD\n        mc.set_region(pocket_left)\n\n    if centre_post_width > 0:\n        # mirror left barrier/pocket region across the rotor using mirror line\n        pocket_right = pocket_left.mirror(get_rotor_mirror_line(), unique_name=False)\n        pocket_right.name = get_pocket_name(pocket_number)\n        # increment pocket number to get next pocket from Motor-CAD\n        pocket_number += 1\n\n        if pocket_right.is_closed():\n            # set region back into Motor-CAD\n            mc.set_region(pocket_right)"
    },
    {
        "objectID": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers",
        "href": "examples/adaptive_library/UShapeSYNCRELCurvedFluxBarriers.html#load-in-adaptive-templates-script-if-required",
        "title": "Curved Rotor Flux Barriers for SYNCREL U-Shape > Load in Adaptive Templates script if required",
        "section": "Load in Adaptive Templates script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 29.813 seconds)\nDownload Jupyter notebook: UShapeSYNCRELCurvedFluxBarriers.ipynb\nDownload Python source code: UShapeSYNCRELCurvedFluxBarriers.py\nDownload zipped: UShapeSYNCRELCurvedFluxBarriers.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_force_harmonics_temporal",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_force_harmonics_temporal.html#calculate_force_harmonics_temporal",
        "title": "calculate_force_harmonics_temporal",
        "section": "calculate_force_harmonics_temporal",
        "text": "Calculate 1D force harmonics on the time axis."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetVariable",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetVariable.html#getvariable",
        "title": "GetVariable",
        "section": "GetVariable",
        "text": "Deprecated function. Replaced by MotorCAD.get_variable()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateSaturationMap",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateSaturationMap.html#calculatesaturationmap",
        "title": "CalculateSaturationMap",
        "section": "CalculateSaturationMap",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_saturation_map()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.start_angle",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.start_angle.html#start_angle",
        "title": "start_angle",
        "section": "start_angle",
        "text": "Get angle of start point from centre point coordinates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_RT.html#addline_rt",
        "title": "AddLine_RT",
        "section": "AddLine_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_line_rt()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.update",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.update.html#update",
        "title": "update",
        "section": "update",
        "text": "Update class fields from another region.\nMotor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_value",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_value.html#get_region_value",
        "title": "get_region_value",
        "section": "get_region_value",
        "text": "Calculate the integral value for an expression of a region."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_y",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_y.html#br_y",
        "title": "br_y",
        "section": "br_y",
        "text": "Y-axis component of the br value."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_Boundary_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddLine_Boundary_XY.html#addline_boundary_xy",
        "title": "AddLine_Boundary_XY",
        "section": "AddLine_Boundary_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_line_boundary_xy()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetVariable",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetVariable.html#setvariable",
        "title": "SetVariable",
        "section": "SetVariable",
        "text": "Deprecated function. Replaced by MotorCAD.set_variable()."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_dxf",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region_dxf.html#get_region_dxf",
        "title": "get_region_dxf",
        "section": "get_region_dxf",
        "text": "Get Motor-CAD dxf geometry region.\nName of the region.\nMotor-CAD region object."
    },
    {
        "objectID": "methods/_autogen_Calculations",
        "href": "methods/_autogen_Calculations.html#calculations",
        "title": "Calculations",
        "section": "Calculations",
        "text": "calculate_force_harmonics_spatial()\nCalculate 1D force harmonics on the space axis.\ncalculate_force_harmonics_temporal()\nCalculate 1D force harmonics on the time axis.\ncalculate_im_saturation_model()\nCalculate saturation lookup tables for IM machines.\ncalculate_saturation_map()\nGenerate electromagnetic saturation and loss data.\ncalculate_torque_envelope()\nCalculate the torque envelope for the machine.\ncreate_winding_pattern()\nCreate winding pattern.\ndo_magnetic_calculation()\nRun the Motor-CAD magnetic calculation.\ndo_magnetic_thermal_calculation()\nRun coupled e-magnetic and thermal calculations.\ndo_mechanical_calculation()\nRun the Motor-CAD mechanical calculation.\ndo_multi_force_calculation()\nRun the multiforce operating point calculation.\ndo_steady_state_analysis()\nRun the thermal steady state analysis.\ndo_transient_analysis()\nRun the thermal transient analysis.\ndo_weight_calculation()\nRun the Motor-CAD weight calculation.\nget_force_frequency_domain_amplitude(row, ...)\nExport the matrix value from a force space time harmonics matrix for a 2D FFT.\nupdate_force_analysis_results(fft_data_type)\nUpdate force analysis results for the multiforce operating point."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_centre_start_end_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_centre_start_end_rt.html#add_arc_centre_start_end_rt",
        "title": "add_arc_centre_start_end_rt",
        "section": "add_arc_centre_start_end_rt",
        "text": "Add an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nThis method uses start, end, and center coordinates. Use degrees for angles.\nCenter position for the radial coordinate.\nCentre position for the angular coordinate in degrees.\nStart position for the radial coordinate.\nStart position for other angular coordinate in degrees.\nend position radial coordinate\nEnd position for the angular coordinate in degrees.\nadd_arc_centre_start_end_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_from_file",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_from_file.html#load_from_file",
        "title": "load_from_file",
        "section": "load_from_file",
        "text": "Load a MOT file into the Motor-CAD instance.\nFull path to the MOT file, including the file name.\nUse the r'filepath' syntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.BuildModel_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.BuildModel_Lab.html#buildmodel_lab",
        "title": "BuildModel_Lab",
        "section": "BuildModel_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.build_model_lab()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_magnetic_calculation",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_magnetic_calculation.html#do_magnetic_calculation",
        "title": "do_magnetic_calculation",
        "section": "do_magnetic_calculation",
        "text": "Run the Motor-CAD magnetic calculation."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ModifyNode",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ModifyNode.html#modifynode",
        "title": "ModifyNode",
        "section": "ModifyNode",
        "text": "Deprecated function. Replaced by MotorCAD.modify_node()."
    },
    {
        "objectID": "methods/_autogen_Geometry",
        "href": "methods/_autogen_Geometry.html#geometry",
        "title": "Geometry",
        "section": "Geometry",
        "text": "check_if_geometry_is_valid(edit_geometry)\nCheck if the Motor-CAD geometry is valid.\nget_winding_coil(phase, path, coil)\nGet the go and return slots, positions, and turns for the winding coil.\nset_winding_coil(phase, path, coil, go_slot, ...)\nSet go and return slots, positions, and turns for the winding coil."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.centre",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.centre.html#centre",
        "title": "centre",
        "section": "centre",
        "text": "Get centre point of circle defining arc."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_RT.html#addpoint_rt",
        "title": "AddPoint_RT",
        "section": "AddPoint_RT",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_array_variable",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_array_variable.html#set_array_variable",
        "title": "set_array_variable",
        "section": "set_array_variable",
        "text": "Set a Motor-CAD array variable.\nName of the array.\nIndex in the array.\nValue to set the variable to."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.end_angle",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.end_angle.html#end_angle",
        "title": "end_angle",
        "section": "end_angle",
        "text": "Get angle of end point from centre point coordinates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathArc",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathArc.html#setfeapatharc",
        "title": "SetFEAPathArc",
        "section": "SetFEAPathArc",
        "text": "Deprecated function. Replaced by MotorCAD.set_fea_path_arc()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.length",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.length.html#length",
        "title": "length",
        "section": "length",
        "text": "Get length of line.\nLength of line"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetAllEmagCalculations",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetAllEmagCalculations.html#setallemagcalculations",
        "title": "SetAllEmagCalculations",
        "section": "SetAllEmagCalculations",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearDutyCycle",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearDutyCycle.html#cleardutycycle",
        "title": "ClearDutyCycle",
        "section": "ClearDutyCycle",
        "text": "Deprecated function. Replaced by MotorCAD.clear_duty_cycle()."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_line",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_line.html#set_fea_path_line",
        "title": "set_fea_path_line",
        "section": "set_fea_path_line",
        "text": "Add or edit a line in the path editor."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#adding-to-external-python-and-contributing",
        "title": "Adding to external python and contributing",
        "section": "Adding to external python and contributing",
        "text": ""
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#pymotorcad",
        "title": "Adding to external python and contributing > PyMotorCAD",
        "section": "PyMotorCAD",
        "text": "PyAnsys Python PyPI GH-CI Codecov MIT Black\nAnsys Motor-CAD is a dedicated design and analysis tool for electric motors. It enables rapid\nand accurate multiphysics design and analysis of electric machines across the full-operating\nspectrum.\nPyMotorCAD uses a Python JSON-RPC (remote procedure call) interface for\nMotor-CAD to launch or connect with a Motor-CAD instance, either locally or\nfrom a remote machine via HTTP. With PyMotorCAD, you can programmatically\ncreate, interact with, and control a Motor-CAD model, with or without using\nthe Motor-CAD GUI.\nDocumentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD documentation.\nIn the upper right corner of the documentation’s title bar, there is an option for switching from\nviewing the documentation for the latest stable release to viewing the documentation for the\ndevelopment version or previously released versions.\nYou can also view or\ndownload the\nPyMotorCAD cheat sheet. This one-page reference provides syntax rules and commands\nfor using PyMotorCAD.\nOn the PyMotorCAD Issues page, you can create\nissues to report bugs and request new features. On the Discussions\npage on the Ansys Developer portal, you can post questions, share ideas, and get community feedback.\nTo reach the project support team, email pyansys.core@ansys.com.\nPyMotorCAD has two installation modes: user and developer.\nBefore installing PyMotorCAD in user mode, run this command to ensure\nthat you have the latest version of pip:\nThen, run this command to install PyMotorCAD:\nInstalling PyMotorCAD in developer mode allows\nyou to modify the source and enhance it.\nNote: Before contributing to this project, ensure that you are familiar\nwith all guidelines in the PyAnsys Developer’s Guide.\nTo install in developer mode, complete these steps:\nClone the pymotorcad repository with this command:\nCreate a fresh-clean Python environment and then activate it with these\ncommands:\nEnsure that you have the latest required build system and\ndocumentation, testing, and CI tools with this command:\nInstall the project in editable mode with this command:\nVerify your development installation with this command:\nThis project takes advantage of tox. This tool allows you to automate common\ndevelopment tasks (similar to Makefile), but it is oriented towards Python\ndevelopment.\nWhile Makefile has rules, tox has environments. In fact, tox creates\nits own virtual environment to guarantee the project’s integrity by isolating\nanything being tested.\nHere are commands for running various checks in the  tox environment:\ntox -e style: Checks for coding style quality.\ntox -e py: Checks for unit tests.\ntox -e py-coverage: Checks for unit testing and code coverage.\ntox -e doc: Checks for the documentation-building process.\nIf required, you can call style commands, such as black, isort,\nand flake8, or unit testing commands, such as`pytest`_, from the command line.\nHowever, using these commands does not guarantee that your project is being\ntested in an isolated environment, which is why tools like tox exist.\nThe style checks take advantage of pre-commit. Developers are not forced but\nencouraged to install this tool by running this command:\nTo build documentation, you can run the usual rules provided in the\nSphinx Makefile with a command like this:\nHowever, the recommended way of checking documentation integrity is to use\na tox command like this:\nIf you would like to create either source or wheel files, run the following\ncommands to install the building requirements and execute the build module:\nPyMotorCAD is licensed under the MIT license. For more information, see the\nLICENSE file.\nPyMotorCAD makes no commercial claim over Ansys whatsoever. This library\nextends the capability of Ansys Motor-CAD by adding a Python interface\nto Motor-CAD without changing the core behaviour or license of the original\nsoftware. Using PyMotorCAD for interactive control of Motor-CAD requires\na legally licensed copy of Motor-CAD.\nFor more information on Motor-CAD, see the Ansys Motor-CAD\npage on the Ansys website.\npython -m pip install -U pip\npython -m pip install ansys-motorcad-core\ngit clone https://github.com/ansys/pymotorcad\n# Create a virtual environment\npython -m venv .venv\n\n# Activate it in a POSIX system\nsource .venv/bin/activate\n\n# Activate it in Windows CMD environment\n.venv\\Scripts\\activate.bat\n\n# Activate it in Windows Powershell\n.venv\\Scripts\\Activate.ps1\npython -m pip install -U pip tox\npython -m pip install --editable ansys-motorcad-core\ntox\npython -m pip install pre-commit && pre-commit install\nmake -C doc/ html && your_browser_name doc/html/index.html\ntox -e doc && your_browser_name .tox/doc_out/index.html\npython -m pip install -U pip\npython -m build\npython -m twine check dist/*"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#overview",
        "title": "Adding to external python and contributing > Overview",
        "section": "Overview",
        "text": "Ansys Motor-CAD is a dedicated design and analysis tool for electric motors. It enables rapid\nand accurate multiphysics design and analysis of electric machines across the full-operating\nspectrum.\nPyMotorCAD uses a Python JSON-RPC (remote procedure call) interface for\nMotor-CAD to launch or connect with a Motor-CAD instance, either locally or\nfrom a remote machine via HTTP. With PyMotorCAD, you can programmatically\ncreate, interact with, and control a Motor-CAD model, with or without using\nthe Motor-CAD GUI."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#documentation-and-issues",
        "title": "Adding to external python and contributing > Documentation and issues",
        "section": "Documentation and issues",
        "text": "Documentation for the latest stable release of PyMotorCAD is hosted at\nPyMotorCAD documentation.\nIn the upper right corner of the documentation’s title bar, there is an option for switching from\nviewing the documentation for the latest stable release to viewing the documentation for the\ndevelopment version or previously released versions.\nYou can also view or\ndownload the\nPyMotorCAD cheat sheet. This one-page reference provides syntax rules and commands\nfor using PyMotorCAD.\nOn the PyMotorCAD Issues page, you can create\nissues to report bugs and request new features. On the Discussions\npage on the Ansys Developer portal, you can post questions, share ideas, and get community feedback.\nTo reach the project support team, email pyansys.core@ansys.com."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#installation",
        "title": "Adding to external python and contributing > Installation",
        "section": "Installation",
        "text": "PyMotorCAD has two installation modes: user and developer.\nBefore installing PyMotorCAD in user mode, run this command to ensure\nthat you have the latest version of pip:\nThen, run this command to install PyMotorCAD:\nInstalling PyMotorCAD in developer mode allows\nyou to modify the source and enhance it.\nNote: Before contributing to this project, ensure that you are familiar\nwith all guidelines in the PyAnsys Developer’s Guide.\nTo install in developer mode, complete these steps:\nClone the pymotorcad repository with this command:\nCreate a fresh-clean Python environment and then activate it with these\ncommands:\nEnsure that you have the latest required build system and\ndocumentation, testing, and CI tools with this command:\nInstall the project in editable mode with this command:\nVerify your development installation with this command:\npython -m pip install -U pip\npython -m pip install ansys-motorcad-core\ngit clone https://github.com/ansys/pymotorcad\n# Create a virtual environment\npython -m venv .venv\n\n# Activate it in a POSIX system\nsource .venv/bin/activate\n\n# Activate it in Windows CMD environment\n.venv\\Scripts\\activate.bat\n\n# Activate it in Windows Powershell\n.venv\\Scripts\\Activate.ps1\npython -m pip install -U pip tox\npython -m pip install --editable ansys-motorcad-core\ntox"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#install-in-user-mode",
        "title": "Adding to external python and contributing > Install in user mode",
        "section": "Install in user mode",
        "text": "Before installing PyMotorCAD in user mode, run this command to ensure\nthat you have the latest version of pip:\nThen, run this command to install PyMotorCAD:\npython -m pip install -U pip\npython -m pip install ansys-motorcad-core"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#install-in-developer-mode",
        "title": "Adding to external python and contributing > Install in developer mode",
        "section": "Install in developer mode",
        "text": "Installing PyMotorCAD in developer mode allows\nyou to modify the source and enhance it.\nNote: Before contributing to this project, ensure that you are familiar\nwith all guidelines in the PyAnsys Developer’s Guide.\nTo install in developer mode, complete these steps:\nClone the pymotorcad repository with this command:\nCreate a fresh-clean Python environment and then activate it with these\ncommands:\nEnsure that you have the latest required build system and\ndocumentation, testing, and CI tools with this command:\nInstall the project in editable mode with this command:\nVerify your development installation with this command:\ngit clone https://github.com/ansys/pymotorcad\n# Create a virtual environment\npython -m venv .venv\n\n# Activate it in a POSIX system\nsource .venv/bin/activate\n\n# Activate it in Windows CMD environment\n.venv\\Scripts\\activate.bat\n\n# Activate it in Windows Powershell\n.venv\\Scripts\\Activate.ps1\npython -m pip install -U pip tox\npython -m pip install --editable ansys-motorcad-core\ntox"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#testing",
        "title": "Adding to external python and contributing > Testing",
        "section": "Testing",
        "text": "This project takes advantage of tox. This tool allows you to automate common\ndevelopment tasks (similar to Makefile), but it is oriented towards Python\ndevelopment.\nWhile Makefile has rules, tox has environments. In fact, tox creates\nits own virtual environment to guarantee the project’s integrity by isolating\nanything being tested.\nHere are commands for running various checks in the  tox environment:\ntox -e style: Checks for coding style quality.\ntox -e py: Checks for unit tests.\ntox -e py-coverage: Checks for unit testing and code coverage.\ntox -e doc: Checks for the documentation-building process.\nIf required, you can call style commands, such as black, isort,\nand flake8, or unit testing commands, such as`pytest`_, from the command line.\nHowever, using these commands does not guarantee that your project is being\ntested in an isolated environment, which is why tools like tox exist."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#tox-commands",
        "title": "Adding to external python and contributing > tox commands",
        "section": "tox commands",
        "text": "Here are commands for running various checks in the  tox environment:\ntox -e style: Checks for coding style quality.\ntox -e py: Checks for unit tests.\ntox -e py-coverage: Checks for unit testing and code coverage.\ntox -e doc: Checks for the documentation-building process."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#raw-testing",
        "title": "Adding to external python and contributing > Raw testing",
        "section": "Raw testing",
        "text": "If required, you can call style commands, such as black, isort,\nand flake8, or unit testing commands, such as`pytest`_, from the command line.\nHowever, using these commands does not guarantee that your project is being\ntested in an isolated environment, which is why tools like tox exist."
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#style-checks",
        "title": "Adding to external python and contributing > Style checks",
        "section": "Style checks",
        "text": "The style checks take advantage of pre-commit. Developers are not forced but\nencouraged to install this tool by running this command:\npython -m pip install pre-commit && pre-commit install"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#documentation-builds",
        "title": "Adding to external python and contributing > Documentation builds",
        "section": "Documentation builds",
        "text": "To build documentation, you can run the usual rules provided in the\nSphinx Makefile with a command like this:\nHowever, the recommended way of checking documentation integrity is to use\na tox command like this:\nmake -C doc/ html && your_browser_name doc/html/index.html\ntox -e doc && your_browser_name .tox/doc_out/index.html"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#distribution",
        "title": "Adding to external python and contributing > Distribution",
        "section": "Distribution",
        "text": "If you would like to create either source or wheel files, run the following\ncommands to install the building requirements and execute the build module:\npython -m pip install -U pip\npython -m build\npython -m twine check dist/*"
    },
    {
        "objectID": "user_guide/external_scripting",
        "href": "user_guide/external_scripting.html#license-and-acknowledgements",
        "title": "Adding to external python and contributing > License and acknowledgements",
        "section": "License and acknowledgements",
        "text": "PyMotorCAD is licensed under the MIT license. For more information, see the\nLICENSE file.\nPyMotorCAD makes no commercial claim over Ansys whatsoever. This library\nextends the capability of Ansys Motor-CAD by adding a Python interface\nto Motor-CAD without changing the core behaviour or license of the original\nsoftware. Using PyMotorCAD for interactive control of Motor-CAD requires\na legally licensed copy of Motor-CAD.\nFor more information on Motor-CAD, see the Ansys Motor-CAD\npage on the Ansys website."
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#triangular-rotor-notches-for-ipm",
        "title": "Triangular Rotor Notches for IPM",
        "section": "Triangular Rotor Notches for IPM",
        "text": "This script applies the adaptive templates functionality to create triangular rotor notches to\nimprove NVH performance.\nFor more information on the use of Adaptive Templates in Motor-CAD, and how to create, modify\nand debug Adaptive Templates Scripts, see ref_adaptive_templates_UG in the\nref_user_guide.\nAdaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later and\nPyMotorCAD v0.4.1. To update PyMotorCAD in Motor-CAD, go to Scripting -> Settings -> PyMotorCAD\nupdates and select ‘Update to Latest Release’.\nThis script is designed to be run from Motor-CAD template “e9”. If no Motor-CAD file is open, the\ne9 template will be loaded.\nThis script uses the following adaptive parameters:\nNotch Angle (-4)\nNotch Sweep (5)\nNotch Depth (1)\nNotches per Pole (2)\nIf these parameters are not already set up in the Motor-CAD file, the parameters will be\nautomatically set, with the default values shown in brackets.\nTo set an adaptive geometry for a Motor-CAD file, a script must be loaded in to the Adaptive\nTemplates tab (Geometry -> Editor -> Adaptive Templates) in Motor-CAD and run. When the option\n‘Geometry Templates Type’ is set to ‘Adaptive’, this script is automatically run repeatedly to\nkeep the Adaptive Geometry set in Motor-CAD.\nThis Python script can also be executed externally. When executed externally, a Motor-CAD instance\nwill be launched and a file based on the “e9” template will be saved to a temporary folder. This\nscript will be loaded into the Adaptive Templates tab.\nImport the pymotorcad package to access Motor-CAD. Import the triangular_notch function to\ncreate the notch geometry region with Adaptive Templates geometry. Import the os, shutil,\nsys, and tempfile packages to open and save a temporary MOT file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e9 IPM motor template is loaded, and the file is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nFour Adaptive Parameters are required for this adaptive template. These are used to define the\nnumber of rotor notches to be added, their position and size.\nIf the Adaptive Parameters have already been set in the current Motor-CAD file, their current\nvalues will be used. Otherwise, the Adaptive Parameters will be defined and set to default values.\nThe function set_default_parameter is defined to check if a parameter exists, and if not,\ncreate it with a default value.\nUse the set_default_parameter to set the required parameters if undefined\nGet the Adaptive Parameters specified in Motor-CAD, and their values\nGet the standard template rotor region from Motor-CAD. Calculate the rotor radius and define the\nrotor centre coordinates.\nAdd an if statement to account for the case when a notch crosses the symmetry boundary. This\nresets notch_angle to half the notch_angular_width away from the boundary.\nAdd an if statement to account for the case when notches overlap at the centre of the pole.\nThis resets notch_angle to:\nHalf the notch_angular_width away from the pole centre when there are an even number of\nnotches\nThe full notch_angular_width away from the pole centre when there are an odd number of\nnotches\nFor each notch to be added:\nCalculate the angular position of the notch in mechanical degrees\nApply the offset angle. For notches on the left side of the pole, the position is shifted by\n+ notch_angle mechanical degrees. For notches on the right side of the pole, the position is\nshifted by - notch_angle mechanical degrees.\nCreate the notch Region using the triangular_notch() function, imported from\nansys.motorcad.core.geometry_shapes. The arguments for the function are:\nrotor_radius\nnotch_angular_width\nnotch_centre_angle\nnotch_depth\nDefine the properties for the notch region\nname\ncolour\nduplication angle\nmaterial\nset the notch’s parent to the rotor region. This will allow Motor-CAD to treat the notch as\na sub-region of the rotor and handle subtractions automatically.\nIf the notch is closed, set the region in Motor-CAD.\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 28.157 seconds)\nDownload Jupyter notebook: BPMTriangularRotorNotches.ipynb\nDownload Python source code: BPMTriangularRotorNotches.py\nDownload zipped: BPMTriangularRotorNotches.zip\nGallery generated by Sphinx-Gallery\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry_shapes import triangular_notch\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e9\")\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"BPMTriRotorNotches\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\nset_default_parameter(\"Notch Angle\", -4)\nset_default_parameter(\"Notch Sweep\", 5)\nset_default_parameter(\"Notch Depth\", 1)\nset_default_parameter(\"Notches per Pole\", 2)\nnotch_angle = mc.get_adaptive_parameter_value(\"notch angle\")\nnotch_angular_width = mc.get_adaptive_parameter_value(\"notch sweep\")\nnotch_depth = mc.get_adaptive_parameter_value(\"notch depth\")\nnumber_notches = int(mc.get_adaptive_parameter_value(\"notches per pole\"))\nrotor_region = mc.get_region(\"Rotor\")\n\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\nduplication_angle = 360 / rotor_region.duplications\nif notch_angle > (duplication_angle / (2 * number_notches)) - (notch_angular_width / 2):\n    # Limit so notch does not cross the symmetry boundary\n    notch_angle = (duplication_angle / (2 * number_notches)) - notch_angular_width / 2\n    mc.show_message(\"Adaptive Parameter: 'notch angle' not valid, reset to \" + str(notch_angle))\n    mc.set_adaptive_parameter_value(\"notch angle\", notch_angle)\nif number_notches % 2 == 0:\n    x = -1\nelse:\n    x = -2\n\nif notch_angle < -((duplication_angle / (2 * number_notches)) - (notch_angular_width / 2)):\n    # Limit so notches do not overlap at centre of pole\n    notch_angle = x * ((duplication_angle / (2 * number_notches)) - notch_angular_width / 2)\n    mc.show_message(\"Adaptive Parameter: 'notch angle' not valid, reset to \" + str(notch_angle))\n    mc.set_adaptive_parameter_value(\"notch angle\", notch_angle)\nfor notch_loop in range(0, number_notches):\n    notch_name = \"Rotor_Notch_\" + str(notch_loop + 1)\n\n    # angular position of notch\n    notch_centre_angle = ((2 * notch_loop) + 1) * (duplication_angle / (2 * number_notches))\n\n    # Offset angle by notch_angle\n    if notch_centre_angle < duplication_angle / 2:\n        notch_centre_angle = notch_centre_angle - notch_angle\n    if notch_centre_angle > duplication_angle / 2:\n        notch_centre_angle = notch_centre_angle + notch_angle\n\n    # generate a triangular notch region\n    notch = triangular_notch(rotor_radius, notch_angular_width, notch_centre_angle, notch_depth)\n\n    # notch properties\n    notch.name = notch_name\n    notch.colour = (255, 255, 255)\n    notch.duplications = rotor_region.duplications\n    notch.material = \"Air\"\n    notch.parent = rotor_region\n\n    if notch.is_closed():\n        mc.set_region(notch)\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#perform-required-imports",
        "title": "Triangular Rotor Notches for IPM > Perform Required imports",
        "section": "Perform Required imports",
        "text": "Import the pymotorcad package to access Motor-CAD. Import the triangular_notch function to\ncreate the notch geometry region with Adaptive Templates geometry. Import the os, shutil,\nsys, and tempfile packages to open and save a temporary MOT file if none is open.\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry_shapes import triangular_notch"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#connect-to-motor-cad",
        "title": "Triangular Rotor Notches for IPM > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e9 IPM motor template is loaded, and the file is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e9\")\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"BPMTriRotorNotches\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#set-adaptive-parameters-if-required",
        "title": "Triangular Rotor Notches for IPM > Set Adaptive Parameters if required",
        "section": "Set Adaptive Parameters if required",
        "text": "Four Adaptive Parameters are required for this adaptive template. These are used to define the\nnumber of rotor notches to be added, their position and size.\nIf the Adaptive Parameters have already been set in the current Motor-CAD file, their current\nvalues will be used. Otherwise, the Adaptive Parameters will be defined and set to default values.\nThe function set_default_parameter is defined to check if a parameter exists, and if not,\ncreate it with a default value.\nUse the set_default_parameter to set the required parameters if undefined\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\nset_default_parameter(\"Notch Angle\", -4)\nset_default_parameter(\"Notch Sweep\", 5)\nset_default_parameter(\"Notch Depth\", 1)\nset_default_parameter(\"Notches per Pole\", 2)"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#get-required-parameters-and-objects",
        "title": "Triangular Rotor Notches for IPM > Get required parameters and objects",
        "section": "Get required parameters and objects",
        "text": "Get the Adaptive Parameters specified in Motor-CAD, and their values\nGet the standard template rotor region from Motor-CAD. Calculate the rotor radius and define the\nrotor centre coordinates.\nAdd an if statement to account for the case when a notch crosses the symmetry boundary. This\nresets notch_angle to half the notch_angular_width away from the boundary.\nAdd an if statement to account for the case when notches overlap at the centre of the pole.\nThis resets notch_angle to:\nHalf the notch_angular_width away from the pole centre when there are an even number of\nnotches\nThe full notch_angular_width away from the pole centre when there are an odd number of\nnotches\nnotch_angle = mc.get_adaptive_parameter_value(\"notch angle\")\nnotch_angular_width = mc.get_adaptive_parameter_value(\"notch sweep\")\nnotch_depth = mc.get_adaptive_parameter_value(\"notch depth\")\nnumber_notches = int(mc.get_adaptive_parameter_value(\"notches per pole\"))\nrotor_region = mc.get_region(\"Rotor\")\n\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\nduplication_angle = 360 / rotor_region.duplications\nif notch_angle > (duplication_angle / (2 * number_notches)) - (notch_angular_width / 2):\n    # Limit so notch does not cross the symmetry boundary\n    notch_angle = (duplication_angle / (2 * number_notches)) - notch_angular_width / 2\n    mc.show_message(\"Adaptive Parameter: 'notch angle' not valid, reset to \" + str(notch_angle))\n    mc.set_adaptive_parameter_value(\"notch angle\", notch_angle)\nif number_notches % 2 == 0:\n    x = -1\nelse:\n    x = -2\n\nif notch_angle < -((duplication_angle / (2 * number_notches)) - (notch_angular_width / 2)):\n    # Limit so notches do not overlap at centre of pole\n    notch_angle = x * ((duplication_angle / (2 * number_notches)) - notch_angular_width / 2)\n    mc.show_message(\"Adaptive Parameter: 'notch angle' not valid, reset to \" + str(notch_angle))\n    mc.set_adaptive_parameter_value(\"notch angle\", notch_angle)"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#create-the-adaptive-templates-geometry",
        "title": "Triangular Rotor Notches for IPM > Create the Adaptive Templates geometry",
        "section": "Create the Adaptive Templates geometry",
        "text": "For each notch to be added:\nCalculate the angular position of the notch in mechanical degrees\nApply the offset angle. For notches on the left side of the pole, the position is shifted by\n+ notch_angle mechanical degrees. For notches on the right side of the pole, the position is\nshifted by - notch_angle mechanical degrees.\nCreate the notch Region using the triangular_notch() function, imported from\nansys.motorcad.core.geometry_shapes. The arguments for the function are:\nrotor_radius\nnotch_angular_width\nnotch_centre_angle\nnotch_depth\nDefine the properties for the notch region\nname\ncolour\nduplication angle\nmaterial\nset the notch’s parent to the rotor region. This will allow Motor-CAD to treat the notch as\na sub-region of the rotor and handle subtractions automatically.\nIf the notch is closed, set the region in Motor-CAD.\nfor notch_loop in range(0, number_notches):\n    notch_name = \"Rotor_Notch_\" + str(notch_loop + 1)\n\n    # angular position of notch\n    notch_centre_angle = ((2 * notch_loop) + 1) * (duplication_angle / (2 * number_notches))\n\n    # Offset angle by notch_angle\n    if notch_centre_angle < duplication_angle / 2:\n        notch_centre_angle = notch_centre_angle - notch_angle\n    if notch_centre_angle > duplication_angle / 2:\n        notch_centre_angle = notch_centre_angle + notch_angle\n\n    # generate a triangular notch region\n    notch = triangular_notch(rotor_radius, notch_angular_width, notch_centre_angle, notch_depth)\n\n    # notch properties\n    notch.name = notch_name\n    notch.colour = (255, 255, 255)\n    notch.duplications = rotor_region.duplications\n    notch.material = \"Air\"\n    notch.parent = rotor_region\n\n    if notch.is_closed():\n        mc.set_region(notch)"
    },
    {
        "objectID": "examples/adaptive_library/BPMTriangularRotorNotches",
        "href": "examples/adaptive_library/BPMTriangularRotorNotches.html#load-in-adaptive-templates-script-if-required",
        "title": "Triangular Rotor Notches for IPM > Load in Adaptive Templates script if required",
        "section": "Load in Adaptive Templates script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 28.157 seconds)\nDownload Jupyter notebook: BPMTriangularRotorNotches.ipynb\nDownload Python source code: BPMTriangularRotorNotches.py\nDownload zipped: BPMTriangularRotorNotches.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.set_component_material",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.set_component_material.html#set_component_material",
        "title": "set_component_material",
        "section": "set_component_material",
        "text": "Set the solid material properties of the component from the materials database.\nComponent name. In Motor-CAD, you can select Input Data -> Materials\nand view the Component column to see component names.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateForceHarmonics_Spatial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateForceHarmonics_Spatial.html#calculateforceharmonics_spatial",
        "title": "CalculateForceHarmonics_Spatial",
        "section": "CalculateForceHarmonics_Spatial",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_force_harmonics_spatial()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetResistanceValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetResistanceValue.html#setresistancevalue",
        "title": "SetResistanceValue",
        "section": "SetResistanceValue",
        "text": "Deprecated function. Replaced by MotorCAD.set_resistance_value()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.parent",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.parent.html#parent",
        "title": "parent",
        "section": "parent",
        "text": "Return parent region from Motor-CAD.\nlist of Motor-CAD region object"
    },
    {
        "objectID": "examples/basics/sg_execution_times",
        "href": "examples/basics/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "04:04.348 total execution time for 3 files from examplesbasics:\nExample\nTime\nMem (MB)\nsphx_glr_examples_basics_lab_basics.py (lab_basics.py)\n01:51.549\n0.0\nsphx_glr_examples_basics_emag_basics.py (emag_basics.py)\n01:06.501\n0.0\nsphx_glr_examples_basics_thermal_basics.py (thermal_basics.py)\n01:06.298\n0.0"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror entity about a line.\nLine entity to mirror entity about"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetOffsetNodeNumber",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetOffsetNodeNumber.html#getoffsetnodenumber",
        "title": "GetOffsetNodeNumber",
        "section": "GetOffsetNodeNumber",
        "text": "Deprecated function. Replaced by MotorCAD.get_offset_node_number()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetArrayVariable",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetArrayVariable.html#setarrayvariable",
        "title": "SetArrayVariable",
        "section": "SetArrayVariable",
        "text": "Deprecated function. Replaced by MotorCAD.set_array_variable()."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.import_solid_material",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.import_solid_material.html#import_solid_material",
        "title": "import_solid_material",
        "section": "import_solid_material",
        "text": "Import the solid material from the materials database.\nName of the materials database.\nName of the solid material."
    },
    {
        "objectID": "examples/internal_scripting/index",
        "href": "examples/internal_scripting/index.html#internal-scripting-examples",
        "title": "Internal scripting examples",
        "section": "Internal scripting examples",
        "text": "These examples show you how to use the internal scripting functionality of PyMotorCAD.\nsphx_glr_examples_internal_scripting_emag.py\nsphx_glr_examples_internal_scripting_mechanical_force.py\nsphx_glr_examples_internal_scripting_mechanical_stress.py\nsphx_glr_examples_internal_scripting_thermal_steady_state.py\nsphx_glr_examples_internal_scripting_thermal_transient.py"
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_operating_point_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_operating_point_lab.html#calculate_operating_point_lab",
        "title": "calculate_operating_point_lab",
        "section": "calculate_operating_point_lab",
        "text": "Run the Lab operating point calculation."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.collides",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.collides.html#collides",
        "title": "collides",
        "section": "collides",
        "text": "Check whether any of the specified regions collide with self.\nMotor-CAD region object/list of objects"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadFromFile",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadFromFile.html#loadfromfile",
        "title": "LoadFromFile",
        "section": "LoadFromFile",
        "text": "Deprecated function. Replaced by MotorCAD.load_from_file()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetArrayVariable_2d",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetArrayVariable_2d.html#getarrayvariable_2d",
        "title": "GetArrayVariable_2d",
        "section": "GetArrayVariable_2d",
        "text": "Deprecated function. Replaced by MotorCAD.get_array_variable_2d()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.get_coordinate_from_percentage_distance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.get_coordinate_from_percentage_distance.html#get_coordinate_from_percentage_distance",
        "title": "get_coordinate_from_percentage_distance",
        "section": "get_coordinate_from_percentage_distance",
        "text": "Get the coordinate at the percentage distance along the arc from the reference coord.\nEntity reference coordinate.\nPercentage distance along Arc.\nCoordinate at percentage distance along Arc."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFluid",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFluid.html#setfluid",
        "title": "SetFluid",
        "section": "SetFluid",
        "text": "Deprecated function. Replaced by MotorCAD.set_fluid()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMagnetic3DGraphPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMagnetic3DGraphPoint.html#getmagnetic3dgraphpoint",
        "title": "GetMagnetic3DGraphPoint",
        "section": "GetMagnetic3DGraphPoint",
        "text": "Deprecated function. Replaced by MotorCAD.get_magnetic_3d_graph_point()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.html#entitylist",
        "title": "EntityList",
        "section": "EntityList",
        "text": "Generic class for list of Entities.\nEntityList.append(object, /)\nAppend object to the end of the list.\nEntityList.clear(/)\nRemove all items from list.\nEntityList.copy(/)\nReturn a shallow copy of the list.\nEntityList.count(value, /)\nReturn number of occurrences of value.\nEntityList.extend(iterable, /)\nExtend list by appending elements from the iterable.\nEntityList.index(value[, start, stop])\nReturn first index of value.\nEntityList.insert(index, object, /)\nInsert object before index.\nEntityList.pop([index])\nRemove and return item at index (default last).\nEntityList.remove(value, /)\nRemove first occurrence of value.\nEntityList.reverse()\nReverse EntityList, including entity start end coordinates.\nEntityList.sort(*[, key, reverse])\nSort the list in ascending order and return None.\nEntityList.points\nGet points of shape/region from Entity list."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DisplayScreen",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DisplayScreen.html#displayscreen",
        "title": "DisplayScreen",
        "section": "DisplayScreen",
        "text": "Deprecated function. Replaced by MotorCAD.display_screen()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate entity around a point for a given angle.\nCoordinate to rotate line around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_region",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_region.html#delete_region",
        "title": "delete_region",
        "section": "delete_region",
        "text": "Delete region from Motor-CAD geometry engine.\nMotor-CAD region object\nWhether to remove regions children"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CheckIfGeometryIsValid",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CheckIfGeometryIsValid.html#checkifgeometryisvalid",
        "title": "CheckIfGeometryIsValid",
        "section": "CheckIfGeometryIsValid",
        "text": "Deprecated function. Replaced by MotorCAD.check_if_geometry_is_valid()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportToAnsysElectronicsDesktop",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportToAnsysElectronicsDesktop.html#exporttoansyselectronicsdesktop",
        "title": "ExportToAnsysElectronicsDesktop",
        "section": "ExportToAnsysElectronicsDesktop",
        "text": "Deprecated function. Replaced by MotorCAD.export_to_ansys_electronics_desktop()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.find_entity_from_coordinates",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.find_entity_from_coordinates.html#find_entity_from_coordinates",
        "title": "find_entity_from_coordinates",
        "section": "find_entity_from_coordinates",
        "text": "Search through region to find an entity with start and end coordinates.\nOrder of coordinates does not matter."
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#getting-started",
        "title": "Getting started",
        "section": "Getting started",
        "text": "PyMotorCAD provides access to Ansys Motor-CAD via Python.\nTo run PyMotorCAD, there must be a licensed copy of Motor-CAD v2023R1 or later installed locally.\nFor more information on Motor-CAD, see the Ansys Motor-CAD page\non the Ansys website.\nPyMotorCAD is installed with Motor-CAD v2023R1 and later for internal Motor-CAD Scripting tab use. To install PyMotorCAD\nfor use outside of Motor-CAD, it may be downloaded from GitHub. PyMotorCAD is available for install via pip in the\nnear future.\nThe ansys.motorcad.core package currently supports Python 3.7 through Python 3.10 on Windows.\nInstall the latest release from\nPyPi with:\nAlternatively, install the latest from\nPyMotorCAD GitHub via:\nFor a local development version, install with:\nThis allows you to install the ansys-motorcad-core module, modify it locally and have the changes reflected in your\nsetup after restarting the Python kernel.\nFor the latest features, you must have a copy of Ansys Motor-CAD v2023R1\ninstalled locally.\nFor more information, see install_MotorCAD.\nCheck that Motor-CAD can be started from Python by running:\nIf successful, a Motor-CAD instance is launched, appearing on the taskbar. You are now ready to start using\nMotor-CAD with PyMotorCAD. For more information on the PyMotorCAD interface, see the ref_user_guide.\npip install ansys-motorcad-core\npip install git+https://github.com/ansys/pymotorcad.git\ngit clone https://github.com/ansys/pymotorcad.git\ncd pymotorcad\npip install -e .\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#installation",
        "title": "Getting started > Installation",
        "section": "Installation",
        "text": "The ansys.motorcad.core package currently supports Python 3.7 through Python 3.10 on Windows.\nInstall the latest release from\nPyPi with:\nAlternatively, install the latest from\nPyMotorCAD GitHub via:\nFor a local development version, install with:\nThis allows you to install the ansys-motorcad-core module, modify it locally and have the changes reflected in your\nsetup after restarting the Python kernel.\nFor the latest features, you must have a copy of Ansys Motor-CAD v2023R1\ninstalled locally.\nFor more information, see install_MotorCAD.\nCheck that Motor-CAD can be started from Python by running:\nIf successful, a Motor-CAD instance is launched, appearing on the taskbar. You are now ready to start using\nMotor-CAD with PyMotorCAD. For more information on the PyMotorCAD interface, see the ref_user_guide.\npip install ansys-motorcad-core\npip install git+https://github.com/ansys/pymotorcad.git\ngit clone https://github.com/ansys/pymotorcad.git\ncd pymotorcad\npip install -e .\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#python-module",
        "title": "Getting started > Python module",
        "section": "Python module",
        "text": "The ansys.motorcad.core package currently supports Python 3.7 through Python 3.10 on Windows.\nInstall the latest release from\nPyPi with:\nAlternatively, install the latest from\nPyMotorCAD GitHub via:\nFor a local development version, install with:\nThis allows you to install the ansys-motorcad-core module, modify it locally and have the changes reflected in your\nsetup after restarting the Python kernel.\npip install ansys-motorcad-core\npip install git+https://github.com/ansys/pymotorcad.git\ngit clone https://github.com/ansys/pymotorcad.git\ncd pymotorcad\npip install -e ."
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#ansys-software-requirements",
        "title": "Getting started > Ansys software requirements",
        "section": "Ansys software requirements",
        "text": "For the latest features, you must have a copy of Ansys Motor-CAD v2023R1\ninstalled locally.\nFor more information, see install_MotorCAD."
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#verify-your-installation",
        "title": "Getting started > Verify your installation",
        "section": "Verify your installation",
        "text": "Check that Motor-CAD can be started from Python by running:\nIf successful, a Motor-CAD instance is launched, appearing on the taskbar. You are now ready to start using\nMotor-CAD with PyMotorCAD. For more information on the PyMotorCAD interface, see the ref_user_guide.\n>>> import ansys.motorcad.core as pymotorcad\n>>> mcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetCapacitanceValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetCapacitanceValue.html#setcapacitancevalue",
        "title": "SetCapacitanceValue",
        "section": "SetCapacitanceValue",
        "text": "Deprecated function. Replaced by MotorCAD.set_capacitance_value()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_template",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_template.html#load_template",
        "title": "load_template",
        "section": "load_template",
        "text": "Load a motor template.\nName of the template, which is given in the Template column when\nselecting File -> Open Template in Motor-CAD. For example, \"a1\"\nor \"e9\"."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_Boundary_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_Boundary_XY.html#addarc_boundary_xy",
        "title": "AddArc_Boundary_XY",
        "section": "AddArc_Boundary_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_boundary_xy()."
    },
    {
        "objectID": "methods/_autosummary_Utility/ansys.motorcad.core.motorcad_methods.MotorCAD.is_file_loaded",
        "href": "methods/_autosummary_Utility/ansys.motorcad.core.motorcad_methods.MotorCAD.is_file_loaded.html#is_file_loaded",
        "title": "is_file_loaded",
        "section": "is_file_loaded",
        "text": "Check if a Motor-CAD file is loaded.\nTrue if a Motor-CAD file is loaded,\nFalse if no file is loaded in Motor-CAD."
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#motor-cad-adaptive-templates-scripting",
        "title": "Motor-CAD adaptive templates scripting",
        "section": "Motor-CAD adaptive templates scripting",
        "text": "Adaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later and\nPyMotorCAD v0.4.1. To update PyMotorCAD in Motor-CAD, go to Scripting -> Settings -> PyMotorCAD\nupdates and select ‘Update to Latest Release’.\nThis guide describes the Adaptive Templates feature. Motor-CAD provides the Adaptive Templates\nfeature for the design of models with geometries that cannot be modelled using the standard template\ngeometries. By using the Adaptive Templates feature, users can generate their own geometric\nparameterisations from scratch or based on the Standard Templates.\nUsing Adaptive Templates, custom geometric parameterisations are set up using a Python script.\nAdaptive Templates examples are available in the PyMotorCAD Documentation under\nref_examples_adaptive_templates_library. For the examples shown in this user guide, see\nref_BPM_Triangular_Rotor_Notches and ref_SYNC_Curve_Flux_Barriers.\nThose who are new to Motor-CAD Adaptive Templates should work through the tutorial supplied with\nMotor-CAD. The tutorial contains additional information and full workflow examples.\nThe Geometry -> Editor tab in Ansys Motor-CAD shows each geometry region currently in use in the\nmodel.\nThe interface is fully interactive. Individual geometry regions can be selected from the region tree\nor the diagram.\nMotor geometry components are grouped by Armature and Field and represented by regions. The Editor\ndisplays the geometry regions based on their spatial locations, such that a region’s sub-regions are\nshown as a descendant/child of their parent region.\nThe e9 IPM template in Motor-CAD is shown. In this example, the Magnet and Rotor Pocket regions\n(L1_1Magnet1, L2_1Magnet2, Rotor Pocket and Rotor Pocket_1) are shown in a branch\nunderneath the Rotor region. When a region is selected, region properties are displayed at the\nbottom-left of the screen and region entities at the bottom-right.\nRegion properties include the Name, Type, Material, Area (base and actual), Position (Centroid,\nRegion Coordinate) and Symmetry of the region. Region entities include all the Lines and Arcs that\ndefine the region. The Rotor region in the e9 IPM template is defined by two lines and two arcs.\nIf an individual entity is selected from the table, it is highlighted in the diagram.\nEither Cartesian or Polar coordinate systems can be used. The coordinate system can be changed by\ngoing to Input Data -> Settings -> Geometry.\nAdaptive Templates can be enabled by going to the Geometry -> Editor -> Adaptive Templates tab\nand setting the Geometry Templates Type from Standard to Adaptive. This means that the\nAdaptive Templates script is run every time the Motor-CAD geometry is created, and the scripting\ninterface enabled, which allows editing of the script.\nTo set an adaptive geometry for a Motor-CAD file, a script must be loaded in to the\nAdaptive Templates tab and run. Adaptive Templates Python scripts can also be executed\nexternally, but unless the script is loaded in to the Adaptive Templates tab in Motor-CAD, the\ngeometry is only defined temporarily.\nAdaptive Templates Scripts require PyMotorCAD to be imported. This Python package provides access to\nMotor-CAD.\nansys.motorcad.core provides access to the Motor-CAD geometry, such as the existing regions in\nthe model. It can be used to get an existing region from the Motor-CAD model (such as the Rotor)\nas an object in Python (rotor = mc.get_region(\"Rotor\")). It can also be used to set a Motor-CAD\nregion object in the Motor-CAD model (mc.set_region(rotor)).\nFor a Motor-CAD region object that has been obtained using PyMotorCAD, the region properties are\naccessible via Python. The region object created in Python contains all of the region properties\nshown in the Motor-CAD UI and all of the geometry entities that make up the region.\nProperties such as the material and colour can be edited with an Adaptive Templates Script:\nDetails on the Adaptive Geometry functions within ansys.motorcad.core that provide access to the\nMotor-CAD geometry are available in the ref_MotorCAD_object under\nref_Adaptive Geometry_API.\nAdaptive scripts also require the ansys.motorcad.core.geometry library to modify the model\ngeometry. This provides geometry capability in Python, such as regions and entities. It is required\nso that Lines and Arcs can be defined or modified by the script, and so that regions can be created\nfrom these entities.\nThe geometry package can be imported:\nAlternatively, specific functions (for example Line and Arc) can be imported from the package:\nansys.motorcad.core.geometry is required to edit the entities that belong to a region, such as\nchanging the Lines or Arcs that define the region geometry.\nDetails on the full list of Geometry objects and functions are available in the\nref_API_Reference under ref_geometry_functions. For examples on modifying a Motor-CAD\nmodel geometry, see ref_examples_adaptive_templates_library.\nAn Adaptive Templates script can be set based on the Standard Template parameters or based on custom\nAdaptive Parameters. Adaptive Parameters are shown in the\nGeometry -> Editor -> Adaptive Parameters tab.\nAny parameter can be defined, with a name, value, and description. Parameters can be added within\nthe Motor-CAD interface, or with a Python script by using the set_adaptive_parameter_value()\nmethod from ansys.motorcad.core:\nAdaptive Parameters also appear in the Geometry -> Radial tab, alongside the Standard Template\nparameters.\nAdaptive Parameters can be accessed with the Adaptive Templates script using the\nget_adaptive_parameter_value() method from ansys.motorcad.core, so that the geometry can be\ndefined by these Adaptive Parameters:\nAs well as the defined Adaptive Parameters, any parameter from Motor-CAD can be used in the Adaptive\nTemplates script by using the get_variable() method from PyMotorCAD. Any Motor-CAD API\naccessible by PyMotorCAD is available.\nFor example, when modifying the rotor geometry, it is often necessary to retrieve the rotor radius:\nTo add a new geometry feature to the Motor-CAD model, such as a notch, the workflow is as follows:\nA new region is created to represent the notch.\nThe region properties are defined (material, colour etc.).\nEntities are added to the region to define the geometry (shape and position).\nThe parent region is defined for the new region (for a rotor duct example, the parent would be\nset to the rotor region).\nThe new region is set in Motor-CAD.\nTo create a new region to represent the notch, use the Region object from\nansys.motorcad.core.geometry:\nRegion properties can be set using the appropriate field/property:\nIf the region object of the rotor has been created in Python (rotor = mc.get_region(\"Rotor\")),\nthe rotor region object’s properties can be obtained and set for the rotor notch.\nThe Region.duplications property represents the symmetry of the region. In the example shown\nusing the e9 IPM template, duplications = 8 because there are 8 rotor poles of 45 ° symmetry.\nIn this example, the notch would have the same symmetry as the rotor.\nThe parent region of the notch can be set to the rotor region so that the notch is set as a\nsub-region. Motor-CAD uses implicit subtractions so that the notch subtraction is handled\nautomatically. The notch appears as a sub-region of the rotor in tree shown in the\nGeometry -> Editor tab in Motor-CAD.\nTo add two Lines line_1, line_2 and an Arc airgap_arc to the notch region, use the\nRegion.add_entity() function from ansys.motorcad.core.geometry:\nLine and Arc entities can be defined using Motor-CAD Coordinate objects.\nTo set the notch in the Motor-CAD model, the notch region is sent to Motor-CAD using the\nset_region() function from ansys.motorcad.core.\nRegion.is_closed() can be used to ensure that the entities that were added to the region create\na closed region.\nLine and Arc entities are defined using Motor-CAD Coordinate objects. Calculating the coordinate\npositions can be time-consuming and can require many lines of Python script.\nFor commonly used shapes, ready made functions can be used to create a region, based on a few\nrequired parameters. These functions can be imported from the\nansys.motorcad.core.geometry_shapes library.\nA function for creating a triangular notch region can be imported:\nThe triangular_notch() function requires four arguments:\nradius: Radial position of the notch outer edge. (For a rotor notch, this is the rotor\nradius.)\nsweep - Sweep of the notch along the rotor airgap, in degrees. (This parameter defines the\nnotch width.)\ncentre_angle - Angular position of the notch centre.\ndepth - Depth of the notch\nA rotor notch can be defined using this function so that the coordinates for the notch entities do\nnot need to be calculated.\nTo use the triangular_notch() function to create a triangular rotor notch region:\nThe arguments, rotor_radius, notch_angular_width, notch_centre_angle and\nnotch_depth must be calculated in the Adaptive Templates script and specified.\nThe notch region properties can then be defined and the region can be set in Motor-CAD, as described\nearlier.\nFor a full Adaptive Templates example using the workflow described here, see\nref_BPM_Triangular_Rotor_Notches.\nDetails on the Geometry Shapes functions within ansys.motorcad.core.geometry_shapes are\navailable in the ref_API_Reference under ref_geometry_shapes.\nAdaptive Template Scripts should be created outside Motor-CAD, using a Python Integrated Development\nEnvironment (IDE) (such as PyCharm). Using an IDE allows for faster creation of the script, allowing\naccess to autocompletion, code correction and other features which are not available in the\nMotor-CAD scripting interface.\nThis is essential when writing complex scripts, allowing issues with the script to be fixed and the\ninspection of Python objects, such as geometry regions from Motor-CAD.\nFor more information on the Synchronous Reluctance machine geometry with curved flux barriers used\nfor this example, see ref_SYNC_Curve_Flux_Barriers.\nAdaptive Templates scripts can be edited from an external IDE (for example PyCharm, VSCode). When\nusing an external IDE, it is important to ensure that the script contains this method before\ngetting or setting any Motor-CAD geometry:\nWhen working on and debugging Adaptive Templates scripts, it is useful to use the geometry drawing\nfeature to plot the geometry objects and regions. ansys.motorcad.core.geometry_drawing contains\nthe draw_objects_debug() function, which can be used to plot any region that has been defined in\nPython. This function only plots regions when called from an external IDE to assist with debugging\nscripts. To plot regions from the Motor-CAD scripting interface, use the draw_objects()\nfunction.\nThe geometry drawing package can be imported:\nIn the ref_SYNC_Curve_Flux_Barriers example, curved flux barrier (rotor pockets) region\nobjects are added to a list, pockets_all_layers. The draw_objects_debug() function can be\nused to plot the regions:\nCustom geometry can be imported to Motor-CAD from a DXF file. For information on how to import\ncustom geometry from a DXF file, see the “Custom Machine Geometries” tutorial supplied with\nMotor-CAD.\nOnce a custom geometry is imported, it is automatically separated into regions, which appear under\nImport in the Geometry -> Editor tab. These imported geometry regions are accessed using\nthe get_region_dxf() method from the ansys.motorcad.core API. The geometry regions that are\ncurrently set in the Motor-CAD model are shown under Template in the tree.\nBy default, the imported regions are not displayed. To display an imported region, select the\ncheckbox.\nImported regions are not automatically set in the Motor-CAD model or used by the Motor-CAD\ncalculations. To customise the Motor-CAD template geometry with the imported geometry, use Adaptive\nTemplates.\nUse the get_region_dxf() method in an adaptive templates script to access an imported region.\nYou can then modify and interact with the region in the same way as for any other region object.\nThe name, properties, and parent regions of the imported region can be defined.\nTo replace an existing region with an imported DXF region, use the Region.replace() method.\nAs with any region object, it is set in the Motor-CAD model using the set_region() method. The\nimported region then appears under Template in the Geometry tree shown in the\nGeometry -> Editor -> Geometry tab in Motor-CAD.\nimport ansys.motorcad.core as pymotorcad\n# Connect to Motor-CAD\nmc = pymotorcad.MotorCAD()\n\n# Get rotor region from Motor-CAD\nrotor = mc.get_region(\"Rotor\")\n\n# Edit region properties\nrotor.colour = (186, 85, 211)\nrotor.material = \"M470-50A\"\nmc.set_region(rotor)\nimport ansys.motorcad.core.geometry as geometry\nfrom ansys.motorcad.core.geometry import Line, Arc\nmc.set_adaptive_parameter_value(\"Notches per Pole\", 2)\nnumber_notches = int(mc.get_adaptive_parameter_value(\"Notches per Pole\"))\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\nnotch = Region()\nnotch.name = \"Rotor_Notch_1\"\nnotch.colour = (255, 255, 255)\nnotch.material = \"Air\"\nnotch.duplications = rotor_region.duplications\nnotch.parent = rotor_region\nnotch.add_entity(line_1)\nnotch.add_entity(line_2)\nnotch.add_entity(airgap_arc)\nif notch.is_closed():\n    mc.set_region(notch)\nfrom ansys.motorcad.core.geometry_shapes import triangular_notch\nnotch = triangular_notch(\n    rotor_radius, notch_angular_width, notch_centre_angle, notch_depth\n)\nmc.reset_adaptive_geometry()\nfrom ansys.motorcad.core.geometry_drawing import draw_objects_debug\ndraw_objects_debug(pockets_all_layers)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#geometry-editor",
        "title": "Motor-CAD adaptive templates scripting > Geometry editor",
        "section": "Geometry editor",
        "text": "The Geometry -> Editor tab in Ansys Motor-CAD shows each geometry region currently in use in the\nmodel.\nThe interface is fully interactive. Individual geometry regions can be selected from the region tree\nor the diagram.\nMotor geometry components are grouped by Armature and Field and represented by regions. The Editor\ndisplays the geometry regions based on their spatial locations, such that a region’s sub-regions are\nshown as a descendant/child of their parent region.\nThe e9 IPM template in Motor-CAD is shown. In this example, the Magnet and Rotor Pocket regions\n(L1_1Magnet1, L2_1Magnet2, Rotor Pocket and Rotor Pocket_1) are shown in a branch\nunderneath the Rotor region. When a region is selected, region properties are displayed at the\nbottom-left of the screen and region entities at the bottom-right.\nRegion properties include the Name, Type, Material, Area (base and actual), Position (Centroid,\nRegion Coordinate) and Symmetry of the region. Region entities include all the Lines and Arcs that\ndefine the region. The Rotor region in the e9 IPM template is defined by two lines and two arcs.\nIf an individual entity is selected from the table, it is highlighted in the diagram.\nEither Cartesian or Polar coordinate systems can be used. The coordinate system can be changed by\ngoing to Input Data -> Settings -> Geometry."
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#adaptive-templates-script",
        "title": "Motor-CAD adaptive templates scripting > Adaptive templates script",
        "section": "Adaptive templates script",
        "text": "Adaptive Templates can be enabled by going to the Geometry -> Editor -> Adaptive Templates tab\nand setting the Geometry Templates Type from Standard to Adaptive. This means that the\nAdaptive Templates script is run every time the Motor-CAD geometry is created, and the scripting\ninterface enabled, which allows editing of the script.\nTo set an adaptive geometry for a Motor-CAD file, a script must be loaded in to the\nAdaptive Templates tab and run. Adaptive Templates Python scripts can also be executed\nexternally, but unless the script is loaded in to the Adaptive Templates tab in Motor-CAD, the\ngeometry is only defined temporarily.\nAdaptive Templates Scripts require PyMotorCAD to be imported. This Python package provides access to\nMotor-CAD.\nansys.motorcad.core provides access to the Motor-CAD geometry, such as the existing regions in\nthe model. It can be used to get an existing region from the Motor-CAD model (such as the Rotor)\nas an object in Python (rotor = mc.get_region(\"Rotor\")). It can also be used to set a Motor-CAD\nregion object in the Motor-CAD model (mc.set_region(rotor)).\nFor a Motor-CAD region object that has been obtained using PyMotorCAD, the region properties are\naccessible via Python. The region object created in Python contains all of the region properties\nshown in the Motor-CAD UI and all of the geometry entities that make up the region.\nProperties such as the material and colour can be edited with an Adaptive Templates Script:\nDetails on the Adaptive Geometry functions within ansys.motorcad.core that provide access to the\nMotor-CAD geometry are available in the ref_MotorCAD_object under\nref_Adaptive Geometry_API.\nAdaptive scripts also require the ansys.motorcad.core.geometry library to modify the model\ngeometry. This provides geometry capability in Python, such as regions and entities. It is required\nso that Lines and Arcs can be defined or modified by the script, and so that regions can be created\nfrom these entities.\nThe geometry package can be imported:\nAlternatively, specific functions (for example Line and Arc) can be imported from the package:\nansys.motorcad.core.geometry is required to edit the entities that belong to a region, such as\nchanging the Lines or Arcs that define the region geometry.\nDetails on the full list of Geometry objects and functions are available in the\nref_API_Reference under ref_geometry_functions. For examples on modifying a Motor-CAD\nmodel geometry, see ref_examples_adaptive_templates_library.\nimport ansys.motorcad.core as pymotorcad\n# Connect to Motor-CAD\nmc = pymotorcad.MotorCAD()\n\n# Get rotor region from Motor-CAD\nrotor = mc.get_region(\"Rotor\")\n\n# Edit region properties\nrotor.colour = (186, 85, 211)\nrotor.material = \"M470-50A\"\nmc.set_region(rotor)\nimport ansys.motorcad.core.geometry as geometry\nfrom ansys.motorcad.core.geometry import Line, Arc"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#using-the-geometry-objects-and-functions-library",
        "title": "Motor-CAD adaptive templates scripting > Using the geometry objects and functions library",
        "section": "Using the geometry objects and functions library",
        "text": "Adaptive scripts also require the ansys.motorcad.core.geometry library to modify the model\ngeometry. This provides geometry capability in Python, such as regions and entities. It is required\nso that Lines and Arcs can be defined or modified by the script, and so that regions can be created\nfrom these entities.\nThe geometry package can be imported:\nAlternatively, specific functions (for example Line and Arc) can be imported from the package:\nansys.motorcad.core.geometry is required to edit the entities that belong to a region, such as\nchanging the Lines or Arcs that define the region geometry.\nDetails on the full list of Geometry objects and functions are available in the\nref_API_Reference under ref_geometry_functions. For examples on modifying a Motor-CAD\nmodel geometry, see ref_examples_adaptive_templates_library.\nimport ansys.motorcad.core.geometry as geometry\nfrom ansys.motorcad.core.geometry import Line, Arc"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#adaptive-parameters",
        "title": "Motor-CAD adaptive templates scripting > Adaptive parameters",
        "section": "Adaptive parameters",
        "text": "An Adaptive Templates script can be set based on the Standard Template parameters or based on custom\nAdaptive Parameters. Adaptive Parameters are shown in the\nGeometry -> Editor -> Adaptive Parameters tab.\nAny parameter can be defined, with a name, value, and description. Parameters can be added within\nthe Motor-CAD interface, or with a Python script by using the set_adaptive_parameter_value()\nmethod from ansys.motorcad.core:\nAdaptive Parameters also appear in the Geometry -> Radial tab, alongside the Standard Template\nparameters.\nAdaptive Parameters can be accessed with the Adaptive Templates script using the\nget_adaptive_parameter_value() method from ansys.motorcad.core, so that the geometry can be\ndefined by these Adaptive Parameters:\nmc.set_adaptive_parameter_value(\"Notches per Pole\", 2)\nnumber_notches = int(mc.get_adaptive_parameter_value(\"Notches per Pole\"))"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#scripting-workflow",
        "title": "Motor-CAD adaptive templates scripting > Scripting workflow",
        "section": "Scripting workflow",
        "text": "As well as the defined Adaptive Parameters, any parameter from Motor-CAD can be used in the Adaptive\nTemplates script by using the get_variable() method from PyMotorCAD. Any Motor-CAD API\naccessible by PyMotorCAD is available.\nFor example, when modifying the rotor geometry, it is often necessary to retrieve the rotor radius:\nTo add a new geometry feature to the Motor-CAD model, such as a notch, the workflow is as follows:\nA new region is created to represent the notch.\nThe region properties are defined (material, colour etc.).\nEntities are added to the region to define the geometry (shape and position).\nThe parent region is defined for the new region (for a rotor duct example, the parent would be\nset to the rotor region).\nThe new region is set in Motor-CAD.\nTo create a new region to represent the notch, use the Region object from\nansys.motorcad.core.geometry:\nRegion properties can be set using the appropriate field/property:\nIf the region object of the rotor has been created in Python (rotor = mc.get_region(\"Rotor\")),\nthe rotor region object’s properties can be obtained and set for the rotor notch.\nThe Region.duplications property represents the symmetry of the region. In the example shown\nusing the e9 IPM template, duplications = 8 because there are 8 rotor poles of 45 ° symmetry.\nIn this example, the notch would have the same symmetry as the rotor.\nThe parent region of the notch can be set to the rotor region so that the notch is set as a\nsub-region. Motor-CAD uses implicit subtractions so that the notch subtraction is handled\nautomatically. The notch appears as a sub-region of the rotor in tree shown in the\nGeometry -> Editor tab in Motor-CAD.\nTo add two Lines line_1, line_2 and an Arc airgap_arc to the notch region, use the\nRegion.add_entity() function from ansys.motorcad.core.geometry:\nLine and Arc entities can be defined using Motor-CAD Coordinate objects.\nTo set the notch in the Motor-CAD model, the notch region is sent to Motor-CAD using the\nset_region() function from ansys.motorcad.core.\nRegion.is_closed() can be used to ensure that the entities that were added to the region create\na closed region.\nLine and Arc entities are defined using Motor-CAD Coordinate objects. Calculating the coordinate\npositions can be time-consuming and can require many lines of Python script.\nFor commonly used shapes, ready made functions can be used to create a region, based on a few\nrequired parameters. These functions can be imported from the\nansys.motorcad.core.geometry_shapes library.\nA function for creating a triangular notch region can be imported:\nThe triangular_notch() function requires four arguments:\nradius: Radial position of the notch outer edge. (For a rotor notch, this is the rotor\nradius.)\nsweep - Sweep of the notch along the rotor airgap, in degrees. (This parameter defines the\nnotch width.)\ncentre_angle - Angular position of the notch centre.\ndepth - Depth of the notch\nA rotor notch can be defined using this function so that the coordinates for the notch entities do\nnot need to be calculated.\nTo use the triangular_notch() function to create a triangular rotor notch region:\nThe arguments, rotor_radius, notch_angular_width, notch_centre_angle and\nnotch_depth must be calculated in the Adaptive Templates script and specified.\nThe notch region properties can then be defined and the region can be set in Motor-CAD, as described\nearlier.\nFor a full Adaptive Templates example using the workflow described here, see\nref_BPM_Triangular_Rotor_Notches.\nDetails on the Geometry Shapes functions within ansys.motorcad.core.geometry_shapes are\navailable in the ref_API_Reference under ref_geometry_shapes.\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\nnotch = Region()\nnotch.name = \"Rotor_Notch_1\"\nnotch.colour = (255, 255, 255)\nnotch.material = \"Air\"\nnotch.duplications = rotor_region.duplications\nnotch.parent = rotor_region\nnotch.add_entity(line_1)\nnotch.add_entity(line_2)\nnotch.add_entity(airgap_arc)\nif notch.is_closed():\n    mc.set_region(notch)\nfrom ansys.motorcad.core.geometry_shapes import triangular_notch\nnotch = triangular_notch(\n    rotor_radius, notch_angular_width, notch_centre_angle, notch_depth\n)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#adding-a-region-to-the-geometry",
        "title": "Motor-CAD adaptive templates scripting > Adding a region to the geometry",
        "section": "Adding a region to the geometry",
        "text": "To add a new geometry feature to the Motor-CAD model, such as a notch, the workflow is as follows:\nA new region is created to represent the notch.\nThe region properties are defined (material, colour etc.).\nEntities are added to the region to define the geometry (shape and position).\nThe parent region is defined for the new region (for a rotor duct example, the parent would be\nset to the rotor region).\nThe new region is set in Motor-CAD.\nTo create a new region to represent the notch, use the Region object from\nansys.motorcad.core.geometry:\nRegion properties can be set using the appropriate field/property:\nIf the region object of the rotor has been created in Python (rotor = mc.get_region(\"Rotor\")),\nthe rotor region object’s properties can be obtained and set for the rotor notch.\nThe Region.duplications property represents the symmetry of the region. In the example shown\nusing the e9 IPM template, duplications = 8 because there are 8 rotor poles of 45 ° symmetry.\nIn this example, the notch would have the same symmetry as the rotor.\nThe parent region of the notch can be set to the rotor region so that the notch is set as a\nsub-region. Motor-CAD uses implicit subtractions so that the notch subtraction is handled\nautomatically. The notch appears as a sub-region of the rotor in tree shown in the\nGeometry -> Editor tab in Motor-CAD.\nTo add two Lines line_1, line_2 and an Arc airgap_arc to the notch region, use the\nRegion.add_entity() function from ansys.motorcad.core.geometry:\nLine and Arc entities can be defined using Motor-CAD Coordinate objects.\nTo set the notch in the Motor-CAD model, the notch region is sent to Motor-CAD using the\nset_region() function from ansys.motorcad.core.\nRegion.is_closed() can be used to ensure that the entities that were added to the region create\na closed region.\nnotch = Region()\nnotch.name = \"Rotor_Notch_1\"\nnotch.colour = (255, 255, 255)\nnotch.material = \"Air\"\nnotch.duplications = rotor_region.duplications\nnotch.parent = rotor_region\nnotch.add_entity(line_1)\nnotch.add_entity(line_2)\nnotch.add_entity(airgap_arc)\nif notch.is_closed():\n    mc.set_region(notch)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#creating-a-region",
        "title": "Motor-CAD adaptive templates scripting > Creating a region",
        "section": "Creating a region",
        "text": "To create a new region to represent the notch, use the Region object from\nansys.motorcad.core.geometry:\nnotch = Region()"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#defining-region-properties-and-parent",
        "title": "Motor-CAD adaptive templates scripting > Defining region properties and parent",
        "section": "Defining region properties and parent",
        "text": "Region properties can be set using the appropriate field/property:\nIf the region object of the rotor has been created in Python (rotor = mc.get_region(\"Rotor\")),\nthe rotor region object’s properties can be obtained and set for the rotor notch.\nThe Region.duplications property represents the symmetry of the region. In the example shown\nusing the e9 IPM template, duplications = 8 because there are 8 rotor poles of 45 ° symmetry.\nIn this example, the notch would have the same symmetry as the rotor.\nThe parent region of the notch can be set to the rotor region so that the notch is set as a\nsub-region. Motor-CAD uses implicit subtractions so that the notch subtraction is handled\nautomatically. The notch appears as a sub-region of the rotor in tree shown in the\nGeometry -> Editor tab in Motor-CAD.\nnotch.name = \"Rotor_Notch_1\"\nnotch.colour = (255, 255, 255)\nnotch.material = \"Air\"\nnotch.duplications = rotor_region.duplications\nnotch.parent = rotor_region"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#adding-entities-to-a-region",
        "title": "Motor-CAD adaptive templates scripting > Adding entities to a region",
        "section": "Adding entities to a region",
        "text": "To add two Lines line_1, line_2 and an Arc airgap_arc to the notch region, use the\nRegion.add_entity() function from ansys.motorcad.core.geometry:\nLine and Arc entities can be defined using Motor-CAD Coordinate objects.\nnotch.add_entity(line_1)\nnotch.add_entity(line_2)\nnotch.add_entity(airgap_arc)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#setting-a-region-in-motor-cad",
        "title": "Motor-CAD adaptive templates scripting > Setting a region in Motor-CAD",
        "section": "Setting a region in Motor-CAD",
        "text": "To set the notch in the Motor-CAD model, the notch region is sent to Motor-CAD using the\nset_region() function from ansys.motorcad.core.\nRegion.is_closed() can be used to ensure that the entities that were added to the region create\na closed region.\nif notch.is_closed():\n    mc.set_region(notch)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#using-the-geometry-shapes-library",
        "title": "Motor-CAD adaptive templates scripting > Using the geometry shapes library",
        "section": "Using the geometry shapes library",
        "text": "Line and Arc entities are defined using Motor-CAD Coordinate objects. Calculating the coordinate\npositions can be time-consuming and can require many lines of Python script.\nFor commonly used shapes, ready made functions can be used to create a region, based on a few\nrequired parameters. These functions can be imported from the\nansys.motorcad.core.geometry_shapes library.\nA function for creating a triangular notch region can be imported:\nThe triangular_notch() function requires four arguments:\nradius: Radial position of the notch outer edge. (For a rotor notch, this is the rotor\nradius.)\nsweep - Sweep of the notch along the rotor airgap, in degrees. (This parameter defines the\nnotch width.)\ncentre_angle - Angular position of the notch centre.\ndepth - Depth of the notch\nA rotor notch can be defined using this function so that the coordinates for the notch entities do\nnot need to be calculated.\nTo use the triangular_notch() function to create a triangular rotor notch region:\nThe arguments, rotor_radius, notch_angular_width, notch_centre_angle and\nnotch_depth must be calculated in the Adaptive Templates script and specified.\nThe notch region properties can then be defined and the region can be set in Motor-CAD, as described\nearlier.\nFor a full Adaptive Templates example using the workflow described here, see\nref_BPM_Triangular_Rotor_Notches.\nDetails on the Geometry Shapes functions within ansys.motorcad.core.geometry_shapes are\navailable in the ref_API_Reference under ref_geometry_shapes.\nfrom ansys.motorcad.core.geometry_shapes import triangular_notch\nnotch = triangular_notch(\n    rotor_radius, notch_angular_width, notch_centre_angle, notch_depth\n)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#create-and-modify-adaptive-templates-scripts",
        "title": "Motor-CAD adaptive templates scripting > Create and modify adaptive templates scripts",
        "section": "Create and modify adaptive templates scripts",
        "text": "Adaptive Template Scripts should be created outside Motor-CAD, using a Python Integrated Development\nEnvironment (IDE) (such as PyCharm). Using an IDE allows for faster creation of the script, allowing\naccess to autocompletion, code correction and other features which are not available in the\nMotor-CAD scripting interface.\nThis is essential when writing complex scripts, allowing issues with the script to be fixed and the\ninspection of Python objects, such as geometry regions from Motor-CAD.\nFor more information on the Synchronous Reluctance machine geometry with curved flux barriers used\nfor this example, see ref_SYNC_Curve_Flux_Barriers.\nAdaptive Templates scripts can be edited from an external IDE (for example PyCharm, VSCode). When\nusing an external IDE, it is important to ensure that the script contains this method before\ngetting or setting any Motor-CAD geometry:\nWhen working on and debugging Adaptive Templates scripts, it is useful to use the geometry drawing\nfeature to plot the geometry objects and regions. ansys.motorcad.core.geometry_drawing contains\nthe draw_objects_debug() function, which can be used to plot any region that has been defined in\nPython. This function only plots regions when called from an external IDE to assist with debugging\nscripts. To plot regions from the Motor-CAD scripting interface, use the draw_objects()\nfunction.\nThe geometry drawing package can be imported:\nIn the ref_SYNC_Curve_Flux_Barriers example, curved flux barrier (rotor pockets) region\nobjects are added to a list, pockets_all_layers. The draw_objects_debug() function can be\nused to plot the regions:\nmc.reset_adaptive_geometry()\nfrom ansys.motorcad.core.geometry_drawing import draw_objects_debug\ndraw_objects_debug(pockets_all_layers)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#working-on-the-adaptive-templates-script",
        "title": "Motor-CAD adaptive templates scripting > Working on the adaptive templates script",
        "section": "Working on the adaptive templates script",
        "text": "Adaptive Templates scripts can be edited from an external IDE (for example PyCharm, VSCode). When\nusing an external IDE, it is important to ensure that the script contains this method before\ngetting or setting any Motor-CAD geometry:\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#drawing-geometry-objects",
        "title": "Motor-CAD adaptive templates scripting > Drawing geometry objects",
        "section": "Drawing geometry objects",
        "text": "When working on and debugging Adaptive Templates scripts, it is useful to use the geometry drawing\nfeature to plot the geometry objects and regions. ansys.motorcad.core.geometry_drawing contains\nthe draw_objects_debug() function, which can be used to plot any region that has been defined in\nPython. This function only plots regions when called from an external IDE to assist with debugging\nscripts. To plot regions from the Motor-CAD scripting interface, use the draw_objects()\nfunction.\nThe geometry drawing package can be imported:\nIn the ref_SYNC_Curve_Flux_Barriers example, curved flux barrier (rotor pockets) region\nobjects are added to a list, pockets_all_layers. The draw_objects_debug() function can be\nused to plot the regions:\nfrom ansys.motorcad.core.geometry_drawing import draw_objects_debug\ndraw_objects_debug(pockets_all_layers)"
    },
    {
        "objectID": "user_guide/adaptive_templates",
        "href": "user_guide/adaptive_templates.html#add-imported-dxf-geometries-to-adaptive-templates",
        "title": "Motor-CAD adaptive templates scripting > Add imported DXF geometries to adaptive templates",
        "section": "Add imported DXF geometries to adaptive templates",
        "text": "Custom geometry can be imported to Motor-CAD from a DXF file. For information on how to import\ncustom geometry from a DXF file, see the “Custom Machine Geometries” tutorial supplied with\nMotor-CAD.\nOnce a custom geometry is imported, it is automatically separated into regions, which appear under\nImport in the Geometry -> Editor tab. These imported geometry regions are accessed using\nthe get_region_dxf() method from the ansys.motorcad.core API. The geometry regions that are\ncurrently set in the Motor-CAD model are shown under Template in the tree.\nBy default, the imported regions are not displayed. To display an imported region, select the\ncheckbox.\nImported regions are not automatically set in the Motor-CAD model or used by the Motor-CAD\ncalculations. To customise the Motor-CAD template geometry with the imported geometry, use Adaptive\nTemplates.\nUse the get_region_dxf() method in an adaptive templates script to access an imported region.\nYou can then modify and interact with the region in the same way as for any other region object.\nThe name, properties, and parent regions of the imported region can be defined.\nTo replace an existing region with an imported DXF region, use the Region.replace() method.\nAs with any region object, it is set in the Motor-CAD model using the set_region() method. The\nimported region then appears under Template in the Geometry tree shown in the\nGeometry -> Editor -> Geometry tab in Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetArrayVariable_2d",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetArrayVariable_2d.html#setarrayvariable_2d",
        "title": "SetArrayVariable_2d",
        "section": "SetArrayVariable_2d",
        "text": "Deprecated function. Replaced by MotorCAD.set_array_variable_2d()."
    },
    {
        "objectID": "examples/internal_scripting/emag",
        "href": "examples/internal_scripting/emag.html#e-magnetic",
        "title": "E-magnetic",
        "section": "E-magnetic",
        "text": "This example demonstrates internal scripting E-Mag functionality\nDisable pop-up messages\n(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 25.844 seconds)\nDownload Jupyter notebook: emag.ipynb\nDownload Python source code: emag.py\nDownload zipped: emag.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\n\nmc = pymotorcad.MotorCAD()\nmc.set_variable(\"MessageDisplayState\", 2)\n\n\n# This function is called when \"Run\" is pressed\ndef main():\n    pass\n\n\nclass emagnetic:\n    def initial(self):\n        mc.display_screen(\"Scripting\")\n        shaft_speed = mc.get_variable(\"ShaftSpeed\")\n        if shaft_speed > 1000:\n            print(\"Shaft speed is too high. Resetting to 500\")\n            mc.set_variable(\"ShaftSpeed\", 500)\n\n    def final(self):\n        loss_total = mc.get_variable(\"loss_total\")\n        # display total loss rounded to 2dp if available\n        print(\"total loss is: \" + str(round(loss_total, 2)))\n        mc.display_screen(\"Calculation\")\ntry:\n    from setup_scripts.setup_script import run_emag_demo\nexcept ImportError:\n    pass\nelse:\n    run_emag_demo(mc)\n\nmc.set_variable(\"MessageDisplayState\", 0)\n9:15:51 AM : Warning: Licences for different machine types are checked out.\nYou may wish to review your licence configuration.\n9:16:01 AM : Loaded script file: emag.py\n9:16:03 AM : Python script output: Shaft speed is too high. Resetting to 500\n9:16:08 AM : FEA Calculation Time: 3 Seconds\n9:16:08 AM : Solving completed\n9:16:08 AM : Python script output: total loss is: 144.05\nShaft speed:500"
    },
    {
        "objectID": "examples/internal_scripting/emag",
        "href": "examples/internal_scripting/emag.html#pymotorcad-documentation-example",
        "title": "E-magnetic > PyMotorCAD Documentation Example",
        "section": "PyMotorCAD Documentation Example",
        "text": "(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 25.844 seconds)\nDownload Jupyter notebook: emag.ipynb\nDownload Python source code: emag.py\nDownload zipped: emag.zip\nGallery generated by Sphinx-Gallery\ntry:\n    from setup_scripts.setup_script import run_emag_demo\nexcept ImportError:\n    pass\nelse:\n    run_emag_demo(mc)\n\nmc.set_variable(\"MessageDisplayState\", 0)\n9:15:51 AM : Warning: Licences for different machine types are checked out.\nYou may wish to review your licence configuration.\n9:16:01 AM : Loaded script file: emag.py\n9:16:03 AM : Python script output: Shaft speed is too high. Resetting to 500\n9:16:08 AM : FEA Calculation Time: 3 Seconds\n9:16:08 AM : Solving completed\n9:16:08 AM : Python script output: total loss is: 144.05\nShaft speed:500"
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_closed_region",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_closed_region.html#check_closed_region",
        "title": "check_closed_region",
        "section": "check_closed_region",
        "text": "Check region is closed using region detection.\nMotor-CAD region object."
    },
    {
        "objectID": "examples/sg_execution_times",
        "href": "examples/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 0 files from examples:\nExample\nTime\nMem (MB)\nN/A\nN/A\nN/A"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetRegionValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetRegionValue.html#getregionvalue",
        "title": "GetRegionValue",
        "section": "GetRegionValue",
        "text": "Deprecated function. Replaced by MotorCAD.get_region_value()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateOptimisedMesh_Thermal",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateOptimisedMesh_Thermal.html#createoptimisedmesh_thermal",
        "title": "CreateOptimisedMesh_Thermal",
        "section": "CreateOptimisedMesh_Thermal",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_boundary_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_boundary_rt.html#add_line_boundary_rt",
        "title": "add_line_boundary_rt",
        "section": "add_line_boundary_rt",
        "text": "Add a boundary condition line using r, t coordinates for the start and end points.\nDeprecated since version 0.6.0: add_line_boundary_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_transient_analysis",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_transient_analysis.html#do_transient_analysis",
        "title": "do_transient_analysis",
        "section": "do_transient_analysis",
        "text": "Run the thermal transient analysis."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.region_type",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.region_type.html#region_type",
        "title": "region_type",
        "section": "region_type",
        "text": "Get region type."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.html#motorcadcompatibility",
        "title": "MotorCADCompatibility",
        "section": "MotorCADCompatibility",
        "text": "Create a MotorCAD object that behaves the same as old ActiveX methods.\nThis class contains the old camelCase function names.\nIt can be used to run old scripts that were written for ActiveX.\nMotorCADCompatibility.AddArc_Boundary_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddArc_Boundary_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddArc_CentreStartEnd_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddArc_CentreStartEnd_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddArc_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddArc_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddCircularConductor_A(*args)\nDeprecated function.\nMotorCADCompatibility.AddLine_Boundary_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddLine_Boundary_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddLine_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddLine_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddMagnetRegion_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddMagnetRegion_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddPoint_CustomMaterial_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddPoint_Magnetic_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddPoint_Magnetic_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddPoint_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddPoint_XY(*args)\nDeprecated function.\nMotorCADCompatibility.AddRectangularConductor_A(*args)\nDeprecated function.\nMotorCADCompatibility.AddRegion_RT(*args)\nDeprecated function.\nMotorCADCompatibility.AddRegion_XY(*args)\nDeprecated function.\nMotorCADCompatibility.Add_Region_Thermal(*args)\nDeprecated function.\nMotorCADCompatibility.Add_Region_Thermal_A(*args)\nDeprecated function.\nMotorCADCompatibility.AvoidImmediateUpdate(*args)\nDeprecated function.\nMotorCADCompatibility.BuildModel_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateDutyCycle_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateForceHarmonics_Spatial()\nDeprecated function.\nMotorCADCompatibility.CalculateForceHarmonics_Temporal()\nDeprecated function.\nMotorCADCompatibility.CalculateGenerator_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateIMSaturationModel()\nDeprecated function.\nMotorCADCompatibility.CalculateIronLossCoefficients(*args)\nDeprecated function.\nMotorCADCompatibility.CalculateMagnetParameters(*args)\nDeprecated function.\nMotorCADCompatibility.CalculateMagnetic_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateOperatingPoint_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateSaturationMap()\nDeprecated function.\nMotorCADCompatibility.CalculateTestPerformance_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateThermal_Lab()\nDeprecated function.\nMotorCADCompatibility.CalculateTorqueEnvelope()\nDeprecated function.\nMotorCADCompatibility.CheckIfGeometryIsValid(*args)\nDeprecated function.\nMotorCADCompatibility.ClearAllData()\nDeprecated function.\nMotorCADCompatibility.ClearDutyCycle()\nDeprecated function.\nMotorCADCompatibility.ClearExternalCircuit()\nDeprecated function.\nMotorCADCompatibility.ClearFixedTemperatureValue(*args)\nDeprecated function.\nMotorCADCompatibility.ClearMessageLog()\nDeprecated function.\nMotorCADCompatibility.ClearModelBuild_Lab()\nDeprecated function.\nMotorCADCompatibility.CreateNewNode(*args)\nDeprecated function.\nMotorCADCompatibility.CreateOptimisedMesh()\nDeprecated function.\nMotorCADCompatibility.CreateOptimisedMesh_Thermal(*args)\nDeprecated function.\nMotorCADCompatibility.CreateReport(*args)\nDeprecated function.\nMotorCADCompatibility.DeleteRegions(*args)\nDeprecated function.\nMotorCADCompatibility.DeleteSolidMaterial(*args)\nDeprecated function.\nMotorCADCompatibility.DisableErrorMessages(*args)\nDeprecated function.\nMotorCADCompatibility.DisplayScreen(*args)\nDeprecated function.\nMotorCADCompatibility.DoMagneticCalculation()\nDeprecated function.\nMotorCADCompatibility.DoMagneticThermalCalculation()\nDeprecated function.\nMotorCADCompatibility.DoMechanicalCalculation()\nDeprecated function.\nMotorCADCompatibility.DoMultiForceCalculation()\nDeprecated function.\nMotorCADCompatibility.DoSlotFiniteElement()\nDeprecated function.\nMotorCADCompatibility.DoSteadyStateAnalysis()\nDeprecated function.\nMotorCADCompatibility.DoTransientAnalysis()\nDeprecated function.\nMotorCADCompatibility.DoWeightCalculation()\nDeprecated function.\nMotorCADCompatibility.EditMagnetRegion(*args)\nDeprecated function.\nMotorCADCompatibility.ExportDutyCycle_Lab()\nDeprecated function.\nMotorCADCompatibility.ExportFigure_Lab(*args)\nDeprecated function.\nMotorCADCompatibility.ExportForceAnimation(*args)\nDeprecated function.\nMotorCADCompatibility.ExportMatrices(*args)\nDeprecated function.\nMotorCADCompatibility.ExportMultiForceData(*args)\nDeprecated function.\nMotorCADCompatibility.ExportNVHResultsData(*args)\nDeprecated function.\nMotorCADCompatibility.ExportResults(*args)\nDeprecated function.\nMotorCADCompatibility.ExportSolidMaterial(*args)\nDeprecated function.\nMotorCADCompatibility.ExportToAnsysDiscovery(*args)\nDeprecated function.\nMotorCADCompatibility.ExportToAnsysElectronicsDesktop(*args)\nDeprecated function.\nMotorCADCompatibility.GeometryExport()\nDeprecated function.\nMotorCADCompatibility.GetArrayVariable(*args)\nDeprecated function.\nMotorCADCompatibility.GetArrayVariable_2d(*args)\nDeprecated function.\nMotorCADCompatibility.GetComponentMaterial(*args)\nDeprecated function.\nMotorCADCompatibility.GetFEAGraphPoint(*args)\nDeprecated function.\nMotorCADCompatibility.GetForceFrequencyDomainAmplitude(*args)\nDeprecated function.\nMotorCADCompatibility.GetIMIronLoss(*args)\nDeprecated function.\nMotorCADCompatibility.GetLicence()\nDeprecated function.\nMotorCADCompatibility.GetMagnetic3DGraphPoint(*args)\nDeprecated function.\nMotorCADCompatibility.GetMagneticGraphPoint(*args)\nDeprecated function.\nMotorCADCompatibility.GetMessages(*args)\nDeprecated function.\nMotorCADCompatibility.GetModelBuilt_Lab()\nDeprecated function.\nMotorCADCompatibility.GetNodeCapacitance(*args)\nDeprecated function.\nMotorCADCompatibility.GetNodeExists(*args)\nDeprecated function.\nMotorCADCompatibility.GetNodePower(*args)\nDeprecated function.\nMotorCADCompatibility.GetNodeTemperature(*args)\nDeprecated function.\nMotorCADCompatibility.GetNodeToNodeResistance(*args)\nDeprecated function.\nMotorCADCompatibility.GetOffsetNodeNumber(*args)\nDeprecated function.\nMotorCADCompatibility.GetPointValue(*args)\nDeprecated function.\nMotorCADCompatibility.GetPowerGraphPoint(*args)\nDeprecated function.\nMotorCADCompatibility.GetRegionLoss(*args)\nDeprecated function.\nMotorCADCompatibility.GetRegionValue(*args)\nDeprecated function.\nMotorCADCompatibility.GetTemperatureGraphPoint(*args)\nDeprecated function.\nMotorCADCompatibility.GetVariable(*args)\nDeprecated function.\nMotorCADCompatibility.GetWindingCoil(*args)\nDeprecated function.\nMotorCADCompatibility.ImportSolidMaterial(*args)\nDeprecated function.\nMotorCADCompatibility.InitialiseTabNames()\nDeprecated function.\nMotorCADCompatibility.InitiateGeometryFromScript()\nDeprecated function.\nMotorCADCompatibility.IsStopRequested()\nDeprecated function.\nMotorCADCompatibility.LoadCustomDriveCycle(*args)\nDeprecated function.\nMotorCADCompatibility.LoadDXFFile(*args)\nDeprecated function.\nMotorCADCompatibility.LoadDutyCycle(*args)\nDeprecated function.\nMotorCADCompatibility.LoadExternalCircuit(*args)\nDeprecated function.\nMotorCADCompatibility.LoadExternalModel_Lab(*args)\nDeprecated function.\nMotorCADCompatibility.LoadFEAResult(*args)\nDeprecated function.\nMotorCADCompatibility.LoadFromFile(*args)\nDeprecated function.\nMotorCADCompatibility.LoadMagnetisationCurves(*args)\nDeprecated function.\nMotorCADCompatibility.LoadReportStructure(*args)\nDeprecated function.\nMotorCADCompatibility.LoadReportTree()\nDeprecated function.\nMotorCADCompatibility.LoadResults(*args)\nDeprecated function.\nMotorCADCompatibility.LoadScript(*args)\nDeprecated function.\nMotorCADCompatibility.LoadTemplate(*args)\nDeprecated function.\nMotorCADCompatibility.LoadWindingPattern(*args)\nDeprecated function.\nMotorCADCompatibility.ModifyNode(*args)\nDeprecated function.\nMotorCADCompatibility.Quit()\nDeprecated function.\nMotorCADCompatibility.RemoveExternalComponent(*args)\nDeprecated function.\nMotorCADCompatibility.ResetRegions()\nDeprecated function.\nMotorCADCompatibility.RestoreCompatibilitySettings()\nDeprecated function.\nMotorCADCompatibility.RunScript()\nDeprecated function.\nMotorCADCompatibility.SaveDutyCycle(*args)\nDeprecated function.\nMotorCADCompatibility.SaveExternalCircuit(*args)\nDeprecated function.\nMotorCADCompatibility.SaveFEAData(*args)\nDeprecated function.\nMotorCADCompatibility.SaveIronLossCoefficients(*args)\nDeprecated function.\nMotorCADCompatibility.SaveMagnetParameters(*args)\nDeprecated function.\nMotorCADCompatibility.SaveMagnetisationCurves(*args)\nDeprecated function.\nMotorCADCompatibility.SaveMotorCADScreenToFile(*args)\nDeprecated function.\nMotorCADCompatibility.SaveResults(*args)\nDeprecated function.\nMotorCADCompatibility.SaveScreenToFile(*args)\nDeprecated function.\nMotorCADCompatibility.SaveScript(*args)\nDeprecated function.\nMotorCADCompatibility.SaveTemplate(*args)\nDeprecated function.\nMotorCADCompatibility.SaveToFile(*args)\nDeprecated function.\nMotorCADCompatibility.SaveTransientPowerValues(*args)\nDeprecated function.\nMotorCADCompatibility.SaveTransientTemperatures(*args)\nDeprecated function.\nMotorCADCompatibility.SaveWindingPattern(*args)\nDeprecated function.\nMotorCADCompatibility.Set3DComponentVisibility(*args)\nDeprecated function.\nMotorCADCompatibility.SetAllEmagCalculations(*args)\nDeprecated function.\nMotorCADCompatibility.SetArrayVariable(*args)\nDeprecated function.\nMotorCADCompatibility.SetArrayVariable_2d(*args)\nDeprecated function.\nMotorCADCompatibility.SetBndCond(*args)\nDeprecated function.\nMotorCADCompatibility.SetCapacitanceValue(*args)\nDeprecated function.\nMotorCADCompatibility.SetComponentMaterial(*args)\nDeprecated function.\nMotorCADCompatibility.SetFEAPathArc(*args)\nDeprecated function.\nMotorCADCompatibility.SetFEAPathLine(*args)\nDeprecated function.\nMotorCADCompatibility.SetFEAPathPoint(*args)\nDeprecated function.\nMotorCADCompatibility.SetFixedTemperatureValue(*args)\nDeprecated function.\nMotorCADCompatibility.SetFluid(*args)\nDeprecated function.\nMotorCADCompatibility.SetMeshGeneratorParam(*args)\nDeprecated function.\nMotorCADCompatibility.SetMotorLABContext()\nDeprecated function.\nMotorCADCompatibility.SetPowerInjectionValue(*args)\nDeprecated function.\nMotorCADCompatibility.SetPowerSourceValue(*args)\nDeprecated function.\nMotorCADCompatibility.SetRegionColour(*args)\nDeprecated function.\nMotorCADCompatibility.SetResistanceMultiplier(*args)\nDeprecated function.\nMotorCADCompatibility.SetResistanceValue(*args)\nDeprecated function.\nMotorCADCompatibility.SetVariable(*args)\nDeprecated function.\nMotorCADCompatibility.SetVisible(*args)\nDeprecated function.\nMotorCADCompatibility.SetWindingCoil(*args)\nDeprecated function.\nMotorCADCompatibility.ShowMagneticContext()\nDeprecated function.\nMotorCADCompatibility.ShowMechanicalContext()\nDeprecated function.\nMotorCADCompatibility.ShowMessage(*args)\nDeprecated function.\nMotorCADCompatibility.ShowResultsViewer_Lab(*args)\nDeprecated function.\nMotorCADCompatibility.ShowThermalContext()\nDeprecated function.\nMotorCADCompatibility.SolveProblem()\nDeprecated function.\nMotorCADCompatibility.StoreProblemData(*args)\nDeprecated function.\nMotorCADCompatibility.UpdateForceAnalysisResults(*args)\nDeprecated function.\nMotorCADCompatibility.UpdateInterface()\nDeprecated function.\nMotorCADCompatibility.set_free()\nDeprecated function."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.singular",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.singular.html#singular",
        "title": "singular",
        "section": "singular",
        "text": "Get linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.parent_name",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.parent_name.html#parent_name",
        "title": "parent_name",
        "section": "parent_name",
        "text": "Get region parent name."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_3d_graph_point",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_3d_graph_point.html#get_magnetic_3d_graph_point",
        "title": "get_magnetic_3d_graph_point",
        "section": "get_magnetic_3d_graph_point",
        "text": "Get a point from a Motor-CAD magnetic 3D graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nWhich skew slice to get results from. Slice 1 is the first.\nPoint number to get x and y coordinate values from.\nValue of the x coordinate from the graph.\nValue of the y coordinate from the graph."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.get_coordinate_from_distance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.get_coordinate_from_distance.html#get_coordinate_from_distance",
        "title": "get_coordinate_from_distance",
        "section": "get_coordinate_from_distance",
        "text": "Get the coordinate at the specified distance along the arc from the reference coordinate.\nEntity reference coordinate.\nDistance along arc.\nCoordinate at distance along Arc."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_force_animation",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_force_animation.html#export_force_animation",
        "title": "export_force_animation",
        "section": "export_force_animation",
        "text": "Export a force animation to a GIF file.\nAnimation is exported from the caption name. For example,\n\"Radial OL\" or \"Radial OL (12th harmonic)\".\nAnimation name.\nName for the GIF file. Use the r'filepath' syntax\nto force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveResults",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveResults.html#saveresults",
        "title": "SaveResults",
        "section": "SaveResults",
        "text": "Deprecated function. Replaced by MotorCAD.save_results()."
    },
    {
        "objectID": "methods/_autogen_Utility",
        "href": "methods/_autogen_Utility.html#utility",
        "title": "Utility",
        "section": "Utility",
        "text": "is_file_loaded()\nCheck if a Motor-CAD file is loaded.\nis_open()\nCheck if the Motor-CAD executable file is running."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_arc",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_arc.html#set_fea_path_arc",
        "title": "set_fea_path_arc",
        "section": "set_fea_path_arc",
        "text": "Add or edit an arc in the path editor."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_duty_cycle_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_duty_cycle_lab.html#calculate_duty_cycle_lab",
        "title": "calculate_duty_cycle_lab",
        "section": "calculate_duty_cycle_lab",
        "text": "Run the Lab duty cycle."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateTestPerformance_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateTestPerformance_Lab.html#calculatetestperformance_lab",
        "title": "CalculateTestPerformance_Lab",
        "section": "CalculateTestPerformance_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_test_performance_lab()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate Coordinate around a point for a given angle.\nPoint to rotate Coordinate around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_used",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_used.html#br_used",
        "title": "br_used",
        "section": "br_used",
        "text": "Br used after applying Br multiplier."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadExternalCircuit",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadExternalCircuit.html#loadexternalcircuit",
        "title": "LoadExternalCircuit",
        "section": "LoadExternalCircuit",
        "text": "Deprecated function. Replaced by MotorCAD.load_external_circuit()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.angle",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.angle.html#angle",
        "title": "angle",
        "section": "angle",
        "text": "Get angle of line vector."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_line_intersection",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_line_intersection.html#get_line_intersection",
        "title": "get_line_intersection",
        "section": "get_line_intersection",
        "text": "Get intersection Coordinate of line with another line.\nReturns None if intersection not found."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_test_performance_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_test_performance_lab.html#calculate_test_performance_lab",
        "title": "calculate_test_performance_lab",
        "section": "calculate_test_performance_lab",
        "text": "Calculate the test performance.\nResults are saved in the MOT file results folder as MotorLAB_caldata.mat."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_model_build_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_model_build_lab.html#clear_model_build_lab",
        "title": "clear_model_build_lab",
        "section": "clear_model_build_lab",
        "text": "Clear the Lab model build."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFixedTemperatureValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFixedTemperatureValue.html#setfixedtemperaturevalue",
        "title": "SetFixedTemperatureValue",
        "section": "SetFixedTemperatureValue",
        "text": "Deprecated function. Replaced by MotorCAD.set_fixed_temperature_value()."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.save_iron_loss_coefficients",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.save_iron_loss_coefficients.html#save_iron_loss_coefficients",
        "title": "save_iron_loss_coefficients",
        "section": "save_iron_loss_coefficients",
        "text": "Save the calculated iron loss coefficients to the materials database.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.parent",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.parent.html#parent",
        "title": "parent",
        "section": "parent",
        "text": "Return parent region from Motor-CAD.\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_visible",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_visible.html#set_visible",
        "title": "set_visible",
        "section": "set_visible",
        "text": "Set the visibility of the Motor-CAD UI.\nWhether to show the Motor-CAD UI. When True,\nthe UI is shown. When False, the UI is hidden."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.midpoint",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.midpoint.html#midpoint",
        "title": "midpoint",
        "section": "midpoint",
        "text": "Get midpoint of arc."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportMultiForceData",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportMultiForceData.html#exportmultiforcedata",
        "title": "ExportMultiForceData",
        "section": "ExportMultiForceData",
        "text": "Deprecated function. Replaced by MotorCAD.export_multi_force_data()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveDutyCycle",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveDutyCycle.html#savedutycycle",
        "title": "SaveDutyCycle",
        "section": "SaveDutyCycle",
        "text": "Deprecated function. Replaced by MotorCAD.save_duty_cycle()."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.initialise_tab_names",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.initialise_tab_names.html#initialise_tab_names",
        "title": "initialise_tab_names",
        "section": "initialise_tab_names",
        "text": "Initialize the available tabs in the Motor-CAD UI.\nCall this method prior to using the save_motorcad_screen_to_file or\ndisplay_screen method. The Motor-CAD UI must be visible."
    },
    {
        "objectID": "examples/internal_scripting/thermal_transient",
        "href": "examples/internal_scripting/thermal_transient.html#thermal-transient",
        "title": "Thermal transient",
        "section": "Thermal transient",
        "text": "This example demonstrates internal scripting thermal transient functionality\nPerform required imports\nLaunch Motor-CAD\nFor more information about transient thermal analysis, see the Scripting Control In\nDuty Cycle tutorial, installed under\nC:ANSYS_Motor-CADVersionNumberTutorialsScripting_Control_In_Duty_Cycle.\n(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (3 minutes 25.675 seconds)\nDownload Jupyter notebook: thermal_transient.ipynb\nDownload Python source code: thermal_transient.py\nDownload zipped: thermal_transient.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\nmc = pymotorcad.MotorCAD()\n\n\n# This function is called when \"Run\" is pressed\ndef main():\n    pass\n\n\nclass thermal_transient:\n    def initial(self):\n        # %%\n        # Disable pop-up messages\n        mc.set_variable(\"MessageDisplayState\", 2)\n        mc.display_screen(\"Scripting\")\n        # initialise water jacket and rotor cooling flow rate\n        mc.set_variable(\"Wet_Rotor_Fluid_Volume_Flow_Rate\", 0.1)\n        mc.set_variable(\"WJ_Fluid_Volume_Flow_Rate\", 0.1)\n\n    def main(self):\n        current_time = mc.get_variable(\"CurrentTime\")\n        if 1000 <= current_time < 1500:\n            # if between 1000 and 1500 s, stop water jacket coolant flow\n            mc.set_variable(\"WJ_Fluid_Volume_Flow_Rate\", 0)\n        else:\n            # if between 1000 and 1500 s, rotor coolant flow\n            mc.set_variable(\"Wet_Rotor_Fluid_Volume_Flow_Rate\", 0)\n\n    def final(self):\n        # Called after calculation\n        print(\"Thermal Transient - Final\")\n        mc.set_variable(\"MessageDisplayState\", 0)\ntry:\n    from setup_scripts.setup_script import run_thermal_transient_demo\nexcept ImportError:\n    pass\nelse:\n    run_thermal_transient_demo(mc)\n\nmc.set_variable(\"MessageDisplayState\", 0)"
    },
    {
        "objectID": "examples/internal_scripting/thermal_transient",
        "href": "examples/internal_scripting/thermal_transient.html#note",
        "title": "Thermal transient > Note",
        "section": "Note",
        "text": "For more information about transient thermal analysis, see the Scripting Control In\nDuty Cycle tutorial, installed under\nC:ANSYS_Motor-CADVersionNumberTutorialsScripting_Control_In_Duty_Cycle."
    },
    {
        "objectID": "examples/internal_scripting/thermal_transient",
        "href": "examples/internal_scripting/thermal_transient.html#pymotorcad-documentation-example",
        "title": "Thermal transient > PyMotorCAD Documentation Example",
        "section": "PyMotorCAD Documentation Example",
        "text": "(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (3 minutes 25.675 seconds)\nDownload Jupyter notebook: thermal_transient.ipynb\nDownload Python source code: thermal_transient.py\nDownload zipped: thermal_transient.zip\nGallery generated by Sphinx-Gallery\ntry:\n    from setup_scripts.setup_script import run_thermal_transient_demo\nexcept ImportError:\n    pass\nelse:\n    run_thermal_transient_demo(mc)\n\nmc.set_variable(\"MessageDisplayState\", 0)"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.y_intercept",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.y_intercept.html#y_intercept",
        "title": "y_intercept",
        "section": "y_intercept",
        "text": "Get y intercept of line - B in equation (y = Ax + B)."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetComponentMaterial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetComponentMaterial.html#setcomponentmaterial",
        "title": "SetComponentMaterial",
        "section": "SetComponentMaterial",
        "text": "Deprecated function. Replaced by MotorCAD.set_component_material()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRegion_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRegion_RT.html#addregion_rt",
        "title": "AddRegion_RT",
        "section": "AddRegion_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_region_rt()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetVisible",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetVisible.html#setvisible",
        "title": "SetVisible",
        "section": "SetVisible",
        "text": "Deprecated function. Replaced by MotorCAD.set_visible()."
    },
    {
        "objectID": "methods/_autosummary_geometry_drawing/ansys.motorcad.core.geometry_drawing.draw_objects_debug",
        "href": "methods/_autosummary_geometry_drawing/ansys.motorcad.core.geometry_drawing.draw_objects_debug.html#draw_objects_debug",
        "title": "draw_objects_debug",
        "section": "draw_objects_debug",
        "text": "Draw regions on plot if not being run in Motor-CAD.\nentities to draw"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.remove_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.remove_entity.html#remove_entity",
        "title": "remove_entity",
        "section": "remove_entity",
        "text": "Remove the entity from the region.\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.points",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Get points that exist in region."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.save_magnet_parameters",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.save_magnet_parameters.html#save_magnet_parameters",
        "title": "save_magnet_parameters",
        "section": "save_magnet_parameters",
        "text": "Save the calculated magnet parameters of the solid material to the materials database.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.set_free",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.set_free.html#set_free",
        "title": "set_free",
        "section": "set_free",
        "text": "Free the Motor-CAD instance."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_graph_point",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_magnetic_graph_point.html#get_magnetic_graph_point",
        "title": "get_magnetic_graph_point",
        "section": "get_magnetic_graph_point",
        "text": "Get a point from a Motor-CAD magnetic graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nPoint number to retrieve the x and y coordinate values from.\nValue of the x coordinate from the graph.\nValue of the y coordinate from the graph."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate Region around a point for a given angle.\npoint to rotate Coordinate around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_CentreStartEnd_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_CentreStartEnd_RT.html#addarc_centrestartend_rt",
        "title": "AddArc_CentreStartEnd_RT",
        "section": "AddArc_CentreStartEnd_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_centre_start_end_rt()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_XY.html#addpoint_xy",
        "title": "AddPoint_XY",
        "section": "AddPoint_XY",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.from_coordinates",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.from_coordinates.html#from_coordinates",
        "title": "from_coordinates",
        "section": "from_coordinates",
        "text": "Take three coordinates and converts to an arc.\nStart coordinate of Arc.\nCoordinate which arc will intersect.\nEnd coordinate of Arc."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.singular",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.singular.html#singular",
        "title": "singular",
        "section": "singular",
        "text": "Get linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_temperature_graph_point",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_temperature_graph_point.html#get_temperature_graph_point",
        "title": "get_temperature_graph_point",
        "section": "get_temperature_graph_point",
        "text": "Get a point from a Motor-CAD thermal graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nPoint number to get the x and y coordinate values from.\nValue of the x coordinate from the graph.\nValue of the y coordinate from the graph."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearMessageLog",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearMessageLog.html#clearmessagelog",
        "title": "ClearMessageLog",
        "section": "ClearMessageLog",
        "text": "Deprecated function. Replaced by MotorCAD.clear_message_log()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_license",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_license.html#get_license",
        "title": "get_license",
        "section": "get_license",
        "text": "Check if a license is available for the current context and machine type.\nThis method is deprecated. Use the MotorCAD.get_licence() method."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.html#region",
        "title": "Region",
        "section": "Region",
        "text": "Python representation of Motor-CAD geometry region.\nRegion.add_entity(entity)\nAdd entity to list of region entities.\nRegion.add_point(point)\nAdd a new point into region on an existing Line/Arc.\nRegion.collides(regions)\nCheck whether any of the specified regions collide with self.\nRegion.edit_point(old_coordinates, ...)\nEdit a point in the region and update entities.\nRegion.find_entity_from_coordinates(...)\nSearch through region to find an entity with start and end coordinates.\nRegion.from_coordinate_list()\nWork in progress.\nRegion.insert_entity(index, entity)\nInsert entity to list of region entities at given index.\nRegion.insert_polyline(index, polyline)\nInsert polyline at given index, polyline can be made up of line/arc entities.\nRegion.is_closed()\nCheck whether region entities create a closed region.\nRegion.mirror(mirror_line[, unique_name])\nMirror region along entity.\nRegion.remove_entity(entity_remove)\nRemove the entity from the region.\nRegion.replace(replacement_region)\nReplace self with another region.\nRegion.rotate(centre_point, angle)\nRotate Region around a point for a given angle.\nRegion.subtract(region)\nSubtract region from self, returning any additional regions.\nRegion.translate(x, y)\nTranslate Region by specified x,y distances.\nRegion.unite(regions)\nUnite one or more other regions with self.\nRegion.update(region)\nUpdate class fields from another region.\nRegion.child_names\nProperty for child names list.\nRegion.children\nReturn list of child regions from Motor-CAD.\nRegion.lamination_type\nReturn lamination type of region from Motor-CAD.\nRegion.linked_region\nGet linked duplication/unite region.\nRegion.motorcad_instance\nGet linked Motor-CAD instance.\nRegion.parent\nReturn parent region from Motor-CAD.\nRegion.parent_name\nGet region parent name.\nRegion.points\nGet points that exist in region.\nRegion.region_type\nGet region type.\nRegion.singular\nGet linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.restore_compatibility_settings",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.restore_compatibility_settings.html#restore_compatibility_settings",
        "title": "restore_compatibility_settings",
        "section": "restore_compatibility_settings",
        "text": "Restore model compatibility settings to default values to use the latest methods."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveToFile",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveToFile.html#savetofile",
        "title": "SaveToFile",
        "section": "SaveToFile",
        "text": "Deprecated function. Replaced by MotorCAD.save_to_file()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetLicence",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetLicence.html#getlicence",
        "title": "GetLicence",
        "section": "GetLicence",
        "text": "Deprecated function. Replaced by MotorCAD.get_licence()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMessage",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMessage.html#showmessage",
        "title": "ShowMessage",
        "section": "ShowMessage",
        "text": "Deprecated function. Replaced by MotorCAD.show_message()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_coordinate_from_percentage_distance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_coordinate_from_percentage_distance.html#get_coordinate_from_percentage_distance",
        "title": "get_coordinate_from_percentage_distance",
        "section": "get_coordinate_from_percentage_distance",
        "text": "Get the coordinate at the percentage distance along the line from the reference.\nEntity reference coordinate.\nPercentage distance along Line.\nCoordinate at percentage distance along Line."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetMotorLABContext",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetMotorLABContext.html#setmotorlabcontext",
        "title": "SetMotorLABContext",
        "section": "SetMotorLABContext",
        "text": "Deprecated function. Replaced by MotorCAD.set_motorlab_context()."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_point_custom_material_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_point_custom_material_xy.html#add_point_custom_material_xy",
        "title": "add_point_custom_material_xy",
        "section": "add_point_custom_material_xy",
        "text": "Add a region to the geometry and specify the material.\nDo not use this method to add a magnet. Use the add_magnet_region_xy method.\nRegion position for the x coordinate.\nRegion position for the y coordinate.\nName of the region.\nName of the material. In Motor-CAD, material names can be found in\nInput Data -> materials. The material type (laminated, solid,\nor air) is set automatically.\nVCL color. For more information, see https://wiki.freepascal.org/Colors.\nThe color can be designaed as a hexadecimal value, such as \"$008000\"\nor a color name such as \"clGreen\".\nadd_point_custom_material_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_CentreStartEnd_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_CentreStartEnd_XY.html#addarc_centrestartend_xy",
        "title": "AddArc_CentreStartEnd_XY",
        "section": "AddArc_CentreStartEnd_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_centre_start_end_xy()."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_boundary_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_line_boundary_xy.html#add_line_boundary_xy",
        "title": "add_line_boundary_xy",
        "section": "add_line_boundary_xy",
        "text": "Add a boundary condition line using x, y coordinates for the start and end points.\nDeprecated since version 0.6.0: add_line_boundary_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_duty_cycle",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_duty_cycle.html#clear_duty_cycle",
        "title": "clear_duty_cycle",
        "section": "clear_duty_cycle",
        "text": "Clear the duty cycle in both the lab and thermal contexts."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_power_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_power_graph.html#get_power_graph",
        "title": "get_power_graph",
        "section": "get_power_graph",
        "text": "Get graph points from a Motor-CAD transient power loss graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nvalue of x coordinates from graph\nvalue of y coordinates from graph"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadMagnetisationCurves",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadMagnetisationCurves.html#loadmagnetisationcurves",
        "title": "LoadMagnetisationCurves",
        "section": "LoadMagnetisationCurves",
        "text": "Deprecated function. Replaced by MotorCAD.load_magnetisation_curves()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_multi_force_calculation",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_multi_force_calculation.html#do_multi_force_calculation",
        "title": "do_multi_force_calculation",
        "section": "do_multi_force_calculation",
        "text": "Run the multiforce operating point calculation."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_fea_result",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_fea_result.html#load_fea_result",
        "title": "load_fea_result",
        "section": "load_fea_result",
        "text": "Load an existing FEA solution to allow viewing of FEA results.\nFilepath for loading the file with the existing FEA solution.\nUse the r'filepath' syntax to force Python to ignore\nspecial characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.copy",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Return a shallow copy of the list."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.coordinate_on_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.coordinate_on_entity.html#coordinate_on_entity",
        "title": "coordinate_on_entity",
        "section": "coordinate_on_entity",
        "text": "Get if a coordinate exists on this line.\nCheck if this coordinate is on the line"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveFEAData",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveFEAData.html#savefeadata",
        "title": "SaveFEAData",
        "section": "SaveFEAData",
        "text": "Deprecated function. Replaced by MotorCAD.save_fea_data()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_force_harmonics_spatial",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_force_harmonics_spatial.html#calculate_force_harmonics_spatial",
        "title": "calculate_force_harmonics_spatial",
        "section": "calculate_force_harmonics_spatial",
        "text": "Calculate 1D force harmonics on the space axis."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_centre_start_end_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_centre_start_end_xy.html#add_arc_centre_start_end_xy",
        "title": "add_arc_centre_start_end_xy",
        "section": "add_arc_centre_start_end_xy",
        "text": "Add an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nThis method uses start, end, and center coordinates. Use degrees for angles.\nCenter position for the x coordinate.\nCenter position for the y coordinate.\nStart position for the x coordinate.\nStart position for the y coordinate.\nEnd position for the x coordinate.\nEnd position for the y coordinate.\nadd_arc_centre_start_end_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Entity by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.parent_name",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.parent_name.html#parent_name",
        "title": "parent_name",
        "section": "parent_name",
        "text": "Get region parent name."
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#custom-dxf-geometry",
        "title": "Custom DXF Geometry",
        "section": "Custom DXF Geometry",
        "text": "This script applies the adaptive templates functionality to import custom rotor geometry from a\nDXF file.\nFor more information on how to add imported DXF geometries to Adaptive Templates in Motor-CAD,\nsee ref_adaptive_templates_UG in the ref_user_guide.\nDXF import for Adaptive Templates in Motor-CAD requires Motor-CAD 2024 R2 or later.\nThis script is designed to be run from Motor-CAD template “e8”. The “e8” template file contains an\nimported custom geometry from a DXF file. The template should be adjusted slightly to more\nclosely match the imported custom geometry before running the Adaptive Templates script.\nThe following Standard Template geometry changes should be made:\nSet L1 Mag Gap Inner and L2 Mag Gap Inner to 0 mm (for Magnet Layers 1 and 2).\nSet L2 Web Thickness to 18 mm (for Magnet Layer 2).\nSet L2 Pole Arc [ED] to 105 electrical degrees (for Magnet Layer 2).\nSet L2 RDuct Rad Dia to 123.8 mm (for Rotor Duct Layer 2).\nSet L2 RDuct Dia to 4.94 mm (for Rotor Duct Layer 2).\nIf no Motor-CAD file is open, the e8 template is loaded and the geometry is adjusted as\ndescribed earlier.\nImport the pymotorcad package to access Motor-CAD.\nImport the os, shutil, sys, and tempfile packages\nto open and save a temporary MOT file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e8 IPM motor template is loaded, the geometry changes described earlier are applied and the\nfile is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nGet the existing Standard Template regions, and imported regions that are required for the script.\nThis workflow replaces existing template regions with corresponding imported regions. For\nexample, the Standard Template geometry region RotorDuctFluidRegion_2 is replaced by a\ncustom region from the imported DXF file.\nFind the names of the corresponding DXF regions under Import in the Geometry tree on\nthe Geometry -> Editor -> Geometry tab in Motor-CAD. Imported regions are displayed by\nselecting the checkbox. For example, the corresponding imported DXF region for template region\nRotorDuctFluidRegion_2 is named DXFRegion_Rotor_14.\nThis script replaces the entities (lines and arcs) of RotorDuctFluidRegion_2 with entities\nfrom DXFRegion_Rotor_14. The geometry is replaced, while the properties of the region\nRotorDuctFluidRegion_2, such as name, material, colour are retained.\nThe regions in the existing template geometry to be replaced by custom regions from the\nimported DXF geometry will be stored in a list. Use the get_region() method to get the\nrequired regions and store these in the standard_regions list.\nThe imported DXF regions to replace the existing regions with will be stored in a list. Use the\nget_region_dxf() method to get the required regions and store in the replacement_regions\nlist. The indices of the regions in the standard_regions and replacement_regions lists\nmust match such that the corresponding standard and replacement regions share the same index.\nFor example, the RotorDuctFluidRegion_2 and DXFRegion_Rotor_14 regions are both the fifth\nelement of their respective lists.\nFor each standard region, use the Region.replace() method to replace the region with its\ncorresponding imported DXF region. The Region.replace() method replaces the entities\n(lines and arcs) of a region with entities from another region. The geometry entities are\nreplaced, while the properties, such as name, material, colour, of the original regions are\nretained.\nFor more information on the Region.replace() method, see the entry under Region in\nref_geometry_functions in the API reference documentation.\nOnce the entities have been replaced, use the set_region() method to set the modified region\nin Motor-CAD.\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 39.673 seconds)\nDownload Jupyter notebook: DXFImport.ipynb\nDownload Python source code: DXFImport.py\nDownload zipped: DXFImport.zip\nGallery generated by Sphinx-Gallery\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e8\")\n\n    # Set Standard Template geometry to closely match the imported DXF custom geometry\n    mc.set_array_variable(\n        \"VShape_Magnet_ClearanceInner\", 0, 0\n    )  # Set the Magnet Inner Gap to 0 mm for Layer 1\n    mc.set_array_variable(\n        \"VShape_Magnet_ClearanceInner\", 1, 0\n    )  # Set the Magnet Inner Gap to 0 mm for Layer 2\n    mc.set_array_variable(\"WebThickness_Array\", 1, 18)  # Set the Web Thickness to 18 mm for Layer 2\n    mc.set_array_variable(\"PoleArc_Array\", 1, 105)  # Set the Pole Arc to 105 ED for Layer 2\n    mc.set_array_variable(\n        \"RotorCircularDuctLayer_RadialDiameter\", 1, 123.8\n    )  # Set the Rotor Duct Radial Diameter to 123.8 mm for Layer 2\n    mc.set_array_variable(\n        \"RotorCircularDuctLayer_ChannelDiameter\", 1, 4.94\n    )  # Set the Rotor Duct Diameter to 4.94 mm for Layer 2\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"e8_DXF_Import\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\nstandard_regions = [\n    mc.get_region(\"Rotor Pocket_1\"),\n    mc.get_region(\"Rotor Pocket_2\"),\n    mc.get_region(\"Rotor Pocket_4\"),\n    mc.get_region(\"Rotor Pocket_5\"),\n    mc.get_region(\"RotorDuctFluidRegion_1\"),\n    mc.get_region(\"RotorDuctFluidRegion_2\"),\n]\nreplacement_regions = [\n    mc.get_region_dxf(\"DXFRegion_Rotor_6\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_7\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_10\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_11\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_14\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_12\"),\n]\nfor index in range(len(standard_regions)):\n    i = standard_regions[index]\n    i.replace(replacement_regions[index])\n    mc.set_region(i)\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#perform-required-imports",
        "title": "Custom DXF Geometry > Perform required imports",
        "section": "Perform required imports",
        "text": "Import the pymotorcad package to access Motor-CAD.\nImport the os, shutil, sys, and tempfile packages\nto open and save a temporary MOT file if none is open.\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#connect-to-motor-cad",
        "title": "Custom DXF Geometry > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e8 IPM motor template is loaded, the geometry changes described earlier are applied and the\nfile is saved to a temporary folder.\nTo keep a new Motor-CAD instance open after executing the script, use the\nMotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e8\")\n\n    # Set Standard Template geometry to closely match the imported DXF custom geometry\n    mc.set_array_variable(\n        \"VShape_Magnet_ClearanceInner\", 0, 0\n    )  # Set the Magnet Inner Gap to 0 mm for Layer 1\n    mc.set_array_variable(\n        \"VShape_Magnet_ClearanceInner\", 1, 0\n    )  # Set the Magnet Inner Gap to 0 mm for Layer 2\n    mc.set_array_variable(\"WebThickness_Array\", 1, 18)  # Set the Web Thickness to 18 mm for Layer 2\n    mc.set_array_variable(\"PoleArc_Array\", 1, 105)  # Set the Pole Arc to 105 ED for Layer 2\n    mc.set_array_variable(\n        \"RotorCircularDuctLayer_RadialDiameter\", 1, 123.8\n    )  # Set the Rotor Duct Radial Diameter to 123.8 mm for Layer 2\n    mc.set_array_variable(\n        \"RotorCircularDuctLayer_ChannelDiameter\", 1, 4.94\n    )  # Set the Rotor Duct Diameter to 4.94 mm for Layer 2\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"e8_DXF_Import\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#get-required-region-objects",
        "title": "Custom DXF Geometry > Get required region objects",
        "section": "Get required region objects",
        "text": "Get the existing Standard Template regions, and imported regions that are required for the script.\nThis workflow replaces existing template regions with corresponding imported regions. For\nexample, the Standard Template geometry region RotorDuctFluidRegion_2 is replaced by a\ncustom region from the imported DXF file.\nFind the names of the corresponding DXF regions under Import in the Geometry tree on\nthe Geometry -> Editor -> Geometry tab in Motor-CAD. Imported regions are displayed by\nselecting the checkbox. For example, the corresponding imported DXF region for template region\nRotorDuctFluidRegion_2 is named DXFRegion_Rotor_14.\nThis script replaces the entities (lines and arcs) of RotorDuctFluidRegion_2 with entities\nfrom DXFRegion_Rotor_14. The geometry is replaced, while the properties of the region\nRotorDuctFluidRegion_2, such as name, material, colour are retained.\nThe regions in the existing template geometry to be replaced by custom regions from the\nimported DXF geometry will be stored in a list. Use the get_region() method to get the\nrequired regions and store these in the standard_regions list.\nThe imported DXF regions to replace the existing regions with will be stored in a list. Use the\nget_region_dxf() method to get the required regions and store in the replacement_regions\nlist. The indices of the regions in the standard_regions and replacement_regions lists\nmust match such that the corresponding standard and replacement regions share the same index.\nFor example, the RotorDuctFluidRegion_2 and DXFRegion_Rotor_14 regions are both the fifth\nelement of their respective lists.\nstandard_regions = [\n    mc.get_region(\"Rotor Pocket_1\"),\n    mc.get_region(\"Rotor Pocket_2\"),\n    mc.get_region(\"Rotor Pocket_4\"),\n    mc.get_region(\"Rotor Pocket_5\"),\n    mc.get_region(\"RotorDuctFluidRegion_1\"),\n    mc.get_region(\"RotorDuctFluidRegion_2\"),\n]\nreplacement_regions = [\n    mc.get_region_dxf(\"DXFRegion_Rotor_6\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_7\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_10\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_11\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_14\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_12\"),\n]"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#identify-the-required-regions",
        "title": "Custom DXF Geometry > Identify the required regions",
        "section": "Identify the required regions",
        "text": "This workflow replaces existing template regions with corresponding imported regions. For\nexample, the Standard Template geometry region RotorDuctFluidRegion_2 is replaced by a\ncustom region from the imported DXF file.\nFind the names of the corresponding DXF regions under Import in the Geometry tree on\nthe Geometry -> Editor -> Geometry tab in Motor-CAD. Imported regions are displayed by\nselecting the checkbox. For example, the corresponding imported DXF region for template region\nRotorDuctFluidRegion_2 is named DXFRegion_Rotor_14.\nThis script replaces the entities (lines and arcs) of RotorDuctFluidRegion_2 with entities\nfrom DXFRegion_Rotor_14. The geometry is replaced, while the properties of the region\nRotorDuctFluidRegion_2, such as name, material, colour are retained."
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#get-existing-template-regions",
        "title": "Custom DXF Geometry > Get existing template regions",
        "section": "Get existing template regions",
        "text": "The regions in the existing template geometry to be replaced by custom regions from the\nimported DXF geometry will be stored in a list. Use the get_region() method to get the\nrequired regions and store these in the standard_regions list.\nstandard_regions = [\n    mc.get_region(\"Rotor Pocket_1\"),\n    mc.get_region(\"Rotor Pocket_2\"),\n    mc.get_region(\"Rotor Pocket_4\"),\n    mc.get_region(\"Rotor Pocket_5\"),\n    mc.get_region(\"RotorDuctFluidRegion_1\"),\n    mc.get_region(\"RotorDuctFluidRegion_2\"),\n]"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#get-imported-dxf-regions",
        "title": "Custom DXF Geometry > Get imported DXF regions",
        "section": "Get imported DXF regions",
        "text": "The imported DXF regions to replace the existing regions with will be stored in a list. Use the\nget_region_dxf() method to get the required regions and store in the replacement_regions\nlist. The indices of the regions in the standard_regions and replacement_regions lists\nmust match such that the corresponding standard and replacement regions share the same index.\nFor example, the RotorDuctFluidRegion_2 and DXFRegion_Rotor_14 regions are both the fifth\nelement of their respective lists.\nreplacement_regions = [\n    mc.get_region_dxf(\"DXFRegion_Rotor_6\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_7\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_10\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_11\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_14\"),\n    mc.get_region_dxf(\"DXFRegion_Rotor_12\"),\n]"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#replace-standard_regions-with-replacement_regions",
        "title": "Custom DXF Geometry > Replace standard_regions with replacement_regions",
        "section": "Replace standard_regions with replacement_regions",
        "text": "For each standard region, use the Region.replace() method to replace the region with its\ncorresponding imported DXF region. The Region.replace() method replaces the entities\n(lines and arcs) of a region with entities from another region. The geometry entities are\nreplaced, while the properties, such as name, material, colour, of the original regions are\nretained.\nFor more information on the Region.replace() method, see the entry under Region in\nref_geometry_functions in the API reference documentation.\nOnce the entities have been replaced, use the set_region() method to set the modified region\nin Motor-CAD.\nfor index in range(len(standard_regions)):\n    i = standard_regions[index]\n    i.replace(replacement_regions[index])\n    mc.set_region(i)"
    },
    {
        "objectID": "examples/adaptive_library/DXFImport",
        "href": "examples/adaptive_library/DXFImport.html#load-in-adaptive-templates-script-if-required",
        "title": "Custom DXF Geometry > Load in Adaptive Templates Script if required",
        "section": "Load in Adaptive Templates Script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 39.673 seconds)\nDownload Jupyter notebook: DXFImport.ipynb\nDownload Python source code: DXFImport.py\nDownload zipped: DXFImport.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetArrayVariable",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetArrayVariable.html#getarrayvariable",
        "title": "GetArrayVariable",
        "section": "GetArrayVariable",
        "text": "Deprecated function. Replaced by MotorCAD.get_array_variable()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror Coordinate about a line entity.\nLine entity to mirror coordinate about"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.index",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.index.html#index",
        "title": "index",
        "section": "index",
        "text": "Return first index of value.\nRaises ValueError if the value is not present."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.sort",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.sort.html#sort",
        "title": "sort",
        "section": "sort",
        "text": "Sort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportForceAnimation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportForceAnimation.html#exportforceanimation",
        "title": "ExportForceAnimation",
        "section": "ExportForceAnimation",
        "text": "Deprecated function. Replaced by MotorCAD.export_force_animation()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMagneticCalculation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMagneticCalculation.html#domagneticcalculation",
        "title": "DoMagneticCalculation",
        "section": "DoMagneticCalculation",
        "text": "Deprecated function. Replaced by MotorCAD.do_magnetic_calculation()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadReportStructure",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadReportStructure.html#loadreportstructure",
        "title": "LoadReportStructure",
        "section": "LoadReportStructure",
        "text": "Deprecated function. Replaced by MotorCAD.load_report_structure()."
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_fea_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_fea_graph.html#get_fea_graph",
        "title": "get_fea_graph",
        "section": "get_fea_graph",
        "text": "Get graph points from a Motor-CAD FEA graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nWhich skew slice to get results from. Slice 1 is the first.\nPoint number to get x and y coordinate arrays from for\ntransient graphs.\nvalue of x coordinates from graph\nvalue of y coordinates from graph"
    },
    {
        "objectID": "examples/internal_scripting/sg_execution_times",
        "href": "examples/internal_scripting/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "06:39.601 total execution time for 5 files from examplesinternal_scripting:\nExample\nTime\nMem (MB)\nsphx_glr_examples_internal_scripting_thermal_transient.py (thermal_transient.py)\n03:25.675\n0.0\nsphx_glr_examples_internal_scripting_mechanical_force.py (mechanical_force.py)\n01:50.533\n0.0\nsphx_glr_examples_internal_scripting_mechanical_stress.py (mechanical_stress.py)\n00:28.797\n0.0\nsphx_glr_examples_internal_scripting_thermal_steady_state.py (thermal_steady_state.py)\n00:28.750\n0.0\nsphx_glr_examples_internal_scripting_emag.py (emag.py)\n00:25.844\n0.0"
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.display_screen",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.display_screen.html#display_screen",
        "title": "display_screen",
        "section": "display_screen",
        "text": "Display a screen within Motor-CAD.\nName of the screen."
    },
    {
        "objectID": "examples/internal_scripting/mechanical_stress",
        "href": "examples/internal_scripting/mechanical_stress.html#mechanical-stress",
        "title": "Mechanical stress",
        "section": "Mechanical stress",
        "text": "This example demonstrates internal scripting mechanical stress functionality\nPerform required imports\nLaunch Motor-CAD\n(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 28.797 seconds)\nDownload Jupyter notebook: mechanical_stress.ipynb\nDownload Python source code: mechanical_stress.py\nDownload zipped: mechanical_stress.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\nmc = pymotorcad.MotorCAD()\n\n\n# This function is called when \"Run\" is pressed\ndef main():\n    pass\n\n\nclass mechanical_stress:\n    def initial(self):\n        # %%\n        # Disable pop-up messages\n        mc.set_variable(\"MessageDisplayState\", 2)\n        # Called before calculation\n        mc.set_variable(\"ShaftSpeed\", 1500)\n\n    def final(self):\n        # Called after calculation\n        yield_stress = mc.get_variable(\"YieldStress_RotorLam\")\n        max_stress = mc.get_variable(\"MaxStress_RotorLam\")\n\n        print(\"Max Stress: \" + str(max_stress))\n\n        safety_factor = yield_stress / max_stress\n\n        print(\"Safety factor is: \" + str(round(safety_factor, 3)))\n\n        mc.set_variable(\"MessageDisplayState\", 0)\ntry:\n    from setup_scripts.setup_script import run_mech_stress_demo\nexcept ImportError:\n    pass\nelse:\n    run_mech_stress_demo(mc)\n9:18:25 AM : Loaded script file: mechanical_stress.py\n9:18:28 AM : Python script output: Max Stress: 5.36337772082974\nSafety factor is: 84.835"
    },
    {
        "objectID": "examples/internal_scripting/mechanical_stress",
        "href": "examples/internal_scripting/mechanical_stress.html#pymotorcad-documentation-example",
        "title": "Mechanical stress > PyMotorCAD Documentation Example",
        "section": "PyMotorCAD Documentation Example",
        "text": "(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 28.797 seconds)\nDownload Jupyter notebook: mechanical_stress.ipynb\nDownload Python source code: mechanical_stress.py\nDownload zipped: mechanical_stress.zip\nGallery generated by Sphinx-Gallery\ntry:\n    from setup_scripts.setup_script import run_mech_stress_demo\nexcept ImportError:\n    pass\nelse:\n    run_mech_stress_demo(mc)\n9:18:25 AM : Loaded script file: mechanical_stress.py\n9:18:28 AM : Python script output: Max Stress: 5.36337772082974\nSafety factor is: 84.835"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.find_entity_from_coordinates",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.find_entity_from_coordinates.html#find_entity_from_coordinates",
        "title": "find_entity_from_coordinates",
        "section": "find_entity_from_coordinates",
        "text": "Search through region to find an entity with start and end coordinates.\nOrder of coordinates does not matter."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMechanicalContext",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMechanicalContext.html#showmechanicalcontext",
        "title": "ShowMechanicalContext",
        "section": "ShowMechanicalContext",
        "text": "Deprecated function. Replaced by MotorCAD.show_mechanical_context()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ImportSolidMaterial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ImportSolidMaterial.html#importsolidmaterial",
        "title": "ImportSolidMaterial",
        "section": "ImportSolidMaterial",
        "text": "Deprecated function. Replaced by MotorCAD.import_solid_material()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_nvh_results_data",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_nvh_results_data.html#export_nvh_results_data",
        "title": "export_nvh_results_data",
        "section": "export_nvh_results_data",
        "text": "Export NVH results data to a file.\nName of the file. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/MotorCAD_object",
        "href": "methods/MotorCAD_object.html#motorcad-api",
        "title": "MotorCAD API",
        "section": "MotorCAD API",
        "text": "Connect to an existing Motor-CAD instance or open a new instance.\nPort to use for communication.\nOpen a new instance or try to connect to an existing instance.\nWhether to show Motor-CAD communication errors as Python exceptions.\nWhether Motor-CAD methods return a success variable (first object in tuple).\nWhether to reuse Motor-CAD instances when running in parallel. You must\nfree instances after use.\nWhether to keep the Motor-CAD instance open after the instance becomes free.\nFull url for Motor-CAD connection. Assumes we are connecting to existing instance."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_region",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_region.html#set_region",
        "title": "set_region",
        "section": "set_region",
        "text": "Set Motor-CAD geometry region.\nMotor-CAD region object."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Entity by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetRegionLoss",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetRegionLoss.html#getregionloss",
        "title": "GetRegionLoss",
        "section": "GetRegionLoss",
        "text": "Deprecated function. Replaced by MotorCAD.get_region_loss()."
    },
    {
        "objectID": "methods/_autogen_UI",
        "href": "methods/_autogen_UI.html#ui",
        "title": "UI",
        "section": "UI",
        "text": "clear_messages()\nClear messages in the message display window.\ndisable_error_messages(active)\nDisable the display of error messages.\ndisplay_screen(screen_name)\nDisplay a screen within Motor-CAD.\ninitialise_tab_names()\nInitialize the available tabs in the Motor-CAD UI.\nsave_motorcad_screen_to_file(screen_name, ...)\nSave the entire Motor-CAD screen of a tab to an image file.\nsave_screen_to_file(screen_name, file_name)\nSave a screen to an image file.\nset_3d_component_visibility(group_name, ...)\nSet the visibility of a component by group name and component name.\nset_motorlab_context()\nChange Motor-CAD to the lab context.\nset_visible(visible)\nSet the visibility of the Motor-CAD UI.\nshow_magnetic_context()\nShow the magnetic context in Motor-CAD.\nshow_mechanical_context()\nShow the mechanical context in Motor-CAD.\nshow_message(message)\nDisplay a message in the Motor-CAD message window.\nshow_thermal_context()\nShow the thermal context in Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_transient_temperatures",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.save_transient_temperatures.html#save_transient_temperatures",
        "title": "save_transient_temperatures",
        "section": "save_transient_temperatures",
        "text": "Save transient temperature results to a text file.\nText file separator defined using the\n\"ExportTextSeparator\" parameter (default is semicolon)."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.edit_point",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.edit_point.html#edit_point",
        "title": "edit_point",
        "section": "edit_point",
        "text": "Edit a point in the region and update entities.\nPosition of point to edit\nPosition to move the point to"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Coordinate.html#coordinate",
        "title": "Coordinate",
        "section": "Coordinate",
        "text": "Provides the Python representation of a coordinate in two-dimensional space.\nX value.\nY value.\nCoordinate.from_polar_coords(radius, theta)\nCreate Coordinate from polar coordinates.\nCoordinate.get_polar_coords_deg()\nGet coordinates as polar coordinates in degrees.\nCoordinate.mirror(mirror_line)\nMirror Coordinate about a line entity.\nCoordinate.rotate(centre_point, angle)\nRotate Coordinate around a point for a given angle.\nCoordinate.translate(x, y)\nTranslate Coordinate by specified x,y distances."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.build_model_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.build_model_lab.html#build_model_lab",
        "title": "build_model_lab",
        "section": "build_model_lab",
        "text": "Build the Lab model."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_coordinate_from_distance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.get_coordinate_from_distance.html#get_coordinate_from_distance",
        "title": "get_coordinate_from_distance",
        "section": "get_coordinate_from_distance",
        "text": "Get the coordinate at the specified distance along the line from the reference.\nEntity reference coordinate.\nDistance along Line.\nCoordinate at distance along Line."
    },
    {
        "objectID": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.eq_triangle_w",
        "href": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.eq_triangle_w.html#eq_triangle_w",
        "title": "eq_triangle_w",
        "section": "eq_triangle_w",
        "text": "Create an equilateral triangle of given width at a given set of coordinates.\nWidth value.\nRadial coordinate of the triangle centre.\nAngular coordinate of the triangle centre.\nRegion type with three Line entity types."
    },
    {
        "objectID": "methods/_autogen_Internal Scripting",
        "href": "methods/_autogen_Internal Scripting.html#internal-scripting",
        "title": "Internal Scripting",
        "section": "Internal Scripting",
        "text": "load_script(script_file)\nLoad a script file into Motor-CAD's internal scripting.\nrun_script()\nRun the script file in Motor-CAD's internal scripting.\nsave_script(file_path)\nSave the internal Python script to a Python file."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveWindingPattern",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveWindingPattern.html#savewindingpattern",
        "title": "SaveWindingPattern",
        "section": "SaveWindingPattern",
        "text": "Deprecated function. Replaced by MotorCAD.save_winding_pattern()."
    },
    {
        "objectID": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.triangular_notch",
        "href": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.triangular_notch.html#triangular_notch",
        "title": "triangular_notch",
        "section": "triangular_notch",
        "text": "Create a triangular notch for a rotor or stator at given angular position with given size.\nRadius value, radius of the Rotor or Stator for which the notch is being defined.\nSweep value, the angular distance (in degrees) that the notch spans.\nAngle value, angular coordinate of the notch centre.\nDepth value, depth of the notch.\nRegion type with two Line and one Arc entity types."
    },
    {
        "objectID": "methods/geometry_shapes",
        "href": "methods/geometry_shapes.html#geometry-shapes",
        "title": "Geometry shapes",
        "section": "Geometry shapes",
        "text": "Geometry shape functions are used to define and modify\nthe Motor-CAD Adaptive Templates geometry using PyMotorCAD.\nMore information on Adaptive Templates is available\nin the ref_user_guide under ref_adaptive_templates_UG.\nsquare(width, r_O, th_O)\nCreate a square of given width at a given set of coordinates.\neq_triangle_h(height, r_O, th_O)\nCreate an equilateral triangle of given height at a given set of coordinates.\neq_triangle_w(width, r_O, th_O)\nCreate an equilateral triangle of given width at a given set of coordinates.\ntriangular_notch(radius, sweep, ...)\nCreate a triangular notch for a rotor or stator at given angular position with given size."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.modify_node",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.modify_node.html#modify_node",
        "title": "modify_node",
        "section": "modify_node",
        "text": "Modify an existing node."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_collisions",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_collisions.html#check_collisions",
        "title": "check_collisions",
        "section": "check_collisions",
        "text": "Check region does not collide with other geometry regions.\nMotor-CAD region object.\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_power",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_power.html#get_node_power",
        "title": "get_node_power",
        "section": "get_node_power",
        "text": "Get the power of a thermal node.\nNumber of the thermal node.\nPower of the thermal node."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_Boundary_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_Boundary_RT.html#addarc_boundary_rt",
        "title": "AddArc_Boundary_RT",
        "section": "AddArc_Boundary_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_boundary_rt()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearModelBuild_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearModelBuild_Lab.html#clearmodelbuild_lab",
        "title": "ClearModelBuild_Lab",
        "section": "ClearModelBuild_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.clear_model_build_lab()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.total_angle",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.total_angle.html#total_angle",
        "title": "total_angle",
        "section": "total_angle",
        "text": "Get arc sweep angle."
    },
    {
        "objectID": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.save_script",
        "href": "methods/_autosummary_Internal Scripting/ansys.motorcad.core.motorcad_methods.MotorCAD.save_script.html#save_script",
        "title": "save_script",
        "section": "save_script",
        "text": "Save the internal Python script to a Python file.\nAbsolute filepath for the Python file, including the file\nname and a PY extension. The default filepath is the\nWindows directory on the C: drive. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.linked_region",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.linked_region.html#linked_region",
        "title": "linked_region",
        "section": "linked_region",
        "text": "Get linked duplication/unite region."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadScript",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadScript.html#loadscript",
        "title": "LoadScript",
        "section": "LoadScript",
        "text": "Deprecated function. Replaced by MotorCAD.load_script()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveScreenToFile",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveScreenToFile.html#savescreentofile",
        "title": "SaveScreenToFile",
        "section": "SaveScreenToFile",
        "text": "Deprecated function. Replaced by MotorCAD.save_screen_to_file()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.StoreProblemData",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.StoreProblemData.html#storeproblemdata",
        "title": "StoreProblemData",
        "section": "StoreProblemData",
        "text": "Deprecated function."
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#oblong-stator-ducts-with-thermal-adjustment",
        "title": "Oblong stator ducts with thermal adjustment",
        "section": "Oblong stator ducts with thermal adjustment",
        "text": "This script applies the adaptive templates functionality to modify rectangular ducts\ninto oblong ducts. Further, the thermal effect of modified duct is taken into account by modifying\nthe area adjustment under housing water jacket in thermal module.\nImport pymotorcad to access Motor-CAD.\nImport Arc, Line, Coordinate, rt_to_xy, xy_to_rt, math\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e9 IPM motor template is loaded and set up with rectangular stator ducts, and the file is\nsaved to a temporary folder. To keep a new Motor-CAD instance open after executing the script, use\nthe MotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nThe set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nThe rectangle consists of two lines of length equal to the rectangle width.\nOnly the top  and bottom lines requires modification.\nIt is necessary to check whether the line is closest to the origin. As this will affect the center\nof arcs needs to convert the lines. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\nTwo separate functions are needed depending  on full duct or half duct (due to symmetry) is\npresent under Geometry Editor\nFrom Motor-CAD, get the adaptive parameters and their values.\nUse the set_default_parameter() method to set the required Duct Arc Height parameter\nif undefined.\nSet required parameters for the oblong: height of arc Duct Arc Height, duct width and duct\nheight.\nGet the standard template stator region. This can be drawn for debugging if required.\nFor each child region of the stator region:\nCheck whether the region is a stator duct.\nFind the top and bottom lines that makes up the duct.\nModify the lines with respective arcs.\nSet the region in Motor-CAD.\nThe script accounts for whether ducts are full ducts or half ducts (the case when a duct spans the\nrotor pole boundary)\nThe oblong stator ducts can be used in the Motor-CAD Thermal model as channels for water jacket\ncooling. The Housing Water Jacket cooling model in Motor-CAD can be set up to use stator duct\nchannels when a housing type without channels is selected in the Geometry tab.\nAs of Motor-CAD v2024R2, the Housing Water Jacket calculations will use duct areas from the\nMotor-CAD Standard Template geometry - not the custom Adaptive Templates geometry. For example,\nwhen the stator duct geometry has been updated from rectangular to oblong shapes, the duct area\nhas increased. For this example, the area increases from 6 mm2 to 8.038522. This\ncan be seen in the Geometry -> Editor -> Geometry tab, or by using the area method for the\nduct region.\nTo account for this in the Housing Water Jacket cooling model, you can apply a cross section\narea adjustment. By default, this is set to 0. To see this in the Motor-CAD interface, go to the\nInput Data -> Housing Water Jacket -> Fluid FLow tab in the Thermal context.\nThe appropriate area adjustment is calculated and applied within the Adaptive Templates script.\nTo calculate the area adjustment, get the area of the stator duct regions using the area\nmethod. For the case where there are two half-ducts, it is necessary to get the area for all duct\nregions and to calculate the sum of the areas.\nThe area of the original rectangular duct was already calculated earlier (duct_area). The area\nadjustment is calculated by subtracting the rectangular duct area from the oblong duct area.\nSet the area adjustment value in Motor-CAD.\nThe area adjustment is applied by the Adaptive Templates script and is updated any time the\ngeometry is changed.\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 34.844 seconds)\nDownload Jupyter notebook: OblongStatorDuct.ipynb\nDownload Python source code: OblongStatorDuct.py\nDownload zipped: OblongStatorDuct.zip\nGallery generated by Sphinx-Gallery\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy, xy_to_rt\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e9\")\n    mc.set_variable(\"StatorDuctType\", 4)  # selected rectangular ducts\n    mc.set_variable(\"CircularDuctLayers\", 1)  # set number of duct layers\n    mc.set_variable(\"CircularDuctL1RadialDiameter\", 180)  # set number of duct radial diameter\n    mc.set_variable(\"CircularDuctL1ChannelWidth\", 2)  # set duct width\n    mc.set_variable(\"CircularDuctL1ChannelHeight\", 3)  # set duct height\n    mc.set_variable(\"CircularDuctL1Channels\", 48)  # set number of duct channels\n    mc.set_variable(\"HousingType\", 0)  # set housing type to 'Round'\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"Oblong_duct\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False\ndef get_arc_radius(entity_start, entity_end, height):\n    # Generate arc radius and center based on\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n    x = math.dist(start_point_xy, end_point_xy) / 2  # chord length/2\n    y = height\n    # conversion to polar coordinates\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    return r\n\n\ndef get_arc_radius_halfduct(entity_start, entity_end, height, Line_origin, Symm_angle):\n    # Generate arc radius, center, start and  end point based on for half duct\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n\n    x = math.dist(start_point_xy, end_point_xy)  # chord length\n    y = height\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    if Line_origin == True:\n        # line is closer to origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r - height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end  point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r - height, end_piont_t)\n    else:\n        # Line is far from origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r + height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r + height, end_piont_t)\n    new_start_point = Coordinate(new_start_x, new_start_y)\n    new_end_point = Coordinate(new_end_x, new_end_y)\n    return r, new_start_point, new_end_point\nset_default_parameter(\"Duct Arc Height\", 0.7)\nduct_arc_height = mc.get_adaptive_parameter_value(\"Duct Arc Height\")\nduct_height = mc.get_variable(\"CircularDuctL1ChannelHeight\")\nduct_width = mc.get_variable(\"CircularDuctL1ChannelWidth\")\nduct_area = duct_height * duct_width\nst_region = mc.get_region(\"stator\")  # get the stator region\nfor child_name in st_region.child_names:\n    if \"StatorDuctFluidRegion\" in child_name:\n        duct_region = mc.get_region(child_name)\n        if round(duct_region.area / duct_area, 2) == 1:  # check if  full duct is drawn\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / duct_width, 2) == 1:  # check if the line is duct width\n                    # additional check in case width = height\n                    _, angle_start_point_angle = xy_to_rt(entity.start.x, entity.start.y)\n                    _, angle_end_point_angle = xy_to_rt(entity.end.x, entity.end.y)\n                    if (\n                        abs(angle_end_point_angle - angle_start_point_angle) > 0.05\n                    ):  # 0.05 degree is tolerance\n                        # get radius and center\n                        # convert this line segment to Arc\n                        Line_origin = check_line_origin_distance(\n                            i, duct_region\n                        )  # line near of far from origin\n                        radius = get_arc_radius(entity.start, entity.end, duct_arc_height)\n                        Duct_Arc = Arc(entity.start, entity.end, radius=radius)\n                        duct_region.entities[i] = Duct_Arc\n\n        elif round(duct_region.area / duct_area, 2) == 0.5:  # if the half duct is drawn\n            Symm_angle = 360 / duct_region.duplications  # angle of symmetry\n            for i, entity in enumerate(duct_region.entities):\n                if (\n                    round(entity.length / duct_width, 2) == 0.5\n                ):  # check if  the line is half duct width\n                    # additional check in case width/2 = height\n                    _, angle_start_point_angle = xy_to_rt(entity.start.x, entity.start.y)\n                    _, angle_end_point_angle = xy_to_rt(entity.end.x, entity.end.y)\n                    if (\n                        abs(angle_end_point_angle - angle_start_point_angle) > 0.05\n                    ):  # 0.05 degree is tolerance\n                        # get radius and center\n                        # convert this line segment to Arc\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        radius, start_point, end_point = get_arc_radius_halfduct(\n                            entity.start, entity.end, duct_arc_height, Line_origin, Symm_angle\n                        )\n                        Duct_Arc = Arc(start_point, end_point, radius=radius)\n                        duct_region.entities[i] = Duct_Arc\n                elif round(entity.length / duct_height, 2) == 1:\n                    # modify the line on symmetry planes\n                    rad_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    rad_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if angle_start_point == 0 and angle_end_point == 0:\n                        # line located at x=0\n                        entity.start.x = entity.start.x - duct_arc_height\n                        entity.end.x = entity.end.x + duct_arc_height\n                    elif (\n                        round(angle_start_point / Symm_angle, 2) == 1\n                        and round(angle_end_point / Symm_angle, 2) == 1\n                    ):\n                        # line on symmetry plane\n                        # start and end point follow anticlockwise naming convention\n                        rad_start_point = rad_start_point + duct_arc_height\n                        rad_end_point = rad_end_point - duct_arc_height\n                        new_start_x, new_start_y = rt_to_xy(rad_start_point, angle_start_point)\n                        new_end_x, new_end_y = rt_to_xy(rad_end_point, angle_end_point)\n                        start_point = Coordinate(new_start_x, new_start_y)\n                        end_point = Coordinate(new_end_x, new_end_y)\n                        duct_region.entities[i] = Line(start_point, end_point)\n\n        mc.set_region(duct_region)\noblong_duct_areas = []\nnum_slots = mc.get_variable(\"Slot_Number\")\nnum_ducts = mc.get_variable(\"CircularDuctL1Channels\")\nducts_per_slot = num_ducts / num_slots\nfor child_name in st_region.child_names:\n    if \"StatorDuctFluidRegion\" in child_name:\n        oblong_duct_areas.append(mc.get_region(child_name).area)\noblong_duct_area = sum(oblong_duct_areas) / ducts_per_slot\narea_adjustment = oblong_duct_area - duct_area\nmc.set_array_variable(\"HousingWJ_Channel_CSArea_L1_A_Adjustment\", 0, area_adjustment)\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#perform-required-imports",
        "title": "Oblong stator ducts with thermal adjustment > Perform required imports",
        "section": "Perform required imports",
        "text": "Import pymotorcad to access Motor-CAD.\nImport Arc, Line, Coordinate, rt_to_xy, xy_to_rt, math\nto define the adaptive template geometry.\nImport os, shutil, sys, and tempfile\nto open and save a temporary .mot file if none is open.\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy, xy_to_rt"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#connect-to-motor-cad",
        "title": "Oblong stator ducts with thermal adjustment > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e9 IPM motor template is loaded and set up with rectangular stator ducts, and the file is\nsaved to a temporary folder. To keep a new Motor-CAD instance open after executing the script, use\nthe MotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e9\")\n    mc.set_variable(\"StatorDuctType\", 4)  # selected rectangular ducts\n    mc.set_variable(\"CircularDuctLayers\", 1)  # set number of duct layers\n    mc.set_variable(\"CircularDuctL1RadialDiameter\", 180)  # set number of duct radial diameter\n    mc.set_variable(\"CircularDuctL1ChannelWidth\", 2)  # set duct width\n    mc.set_variable(\"CircularDuctL1ChannelHeight\", 3)  # set duct height\n    mc.set_variable(\"CircularDuctL1Channels\", 48)  # set number of duct channels\n    mc.set_variable(\"HousingType\", 0)  # set housing type to 'Round'\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"Oblong_duct\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#define-necessary-functions",
        "title": "Oblong stator ducts with thermal adjustment > Define necessary functions",
        "section": "Define necessary functions",
        "text": "The set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nThe rectangle consists of two lines of length equal to the rectangle width.\nOnly the top  and bottom lines requires modification.\nIt is necessary to check whether the line is closest to the origin. As this will affect the center\nof arcs needs to convert the lines. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\nTwo separate functions are needed depending  on full duct or half duct (due to symmetry) is\npresent under Geometry Editor\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False\ndef get_arc_radius(entity_start, entity_end, height):\n    # Generate arc radius and center based on\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n    x = math.dist(start_point_xy, end_point_xy) / 2  # chord length/2\n    y = height\n    # conversion to polar coordinates\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    return r\n\n\ndef get_arc_radius_halfduct(entity_start, entity_end, height, Line_origin, Symm_angle):\n    # Generate arc radius, center, start and  end point based on for half duct\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n\n    x = math.dist(start_point_xy, end_point_xy)  # chord length\n    y = height\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    if Line_origin == True:\n        # line is closer to origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r - height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end  point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r - height, end_piont_t)\n    else:\n        # Line is far from origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r + height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r + height, end_piont_t)\n    new_start_point = Coordinate(new_start_x, new_start_y)\n    new_end_point = Coordinate(new_end_x, new_end_y)\n    return r, new_start_point, new_end_point"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#set-adaptive-parameter-if-required",
        "title": "Oblong stator ducts with thermal adjustment > Set adaptive parameter if required",
        "section": "Set adaptive parameter if required",
        "text": "The set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#check-line-distance-from-origin",
        "title": "Oblong stator ducts with thermal adjustment > Check line distance from origin",
        "section": "Check line distance from origin",
        "text": "The rectangle consists of two lines of length equal to the rectangle width.\nOnly the top  and bottom lines requires modification.\nIt is necessary to check whether the line is closest to the origin. As this will affect the center\nof arcs needs to convert the lines. Index i is\nthe line under investigation. Index j is the adjacent line. If the radius of midpoint of line\ni is less than that of line j , line i is closer to the origin.\ndef check_line_origin_distance(i, duct_region):\n    if i == 0:  # first index of rectangle duct\n        j = 1\n    else:\n        j = i - 1\n    rad_start_i, _ = xy_to_rt(duct_region.entities[i].start.x, duct_region.entities[i].start.y)\n    rad_end_i, _ = xy_to_rt(duct_region.entities[i].end.x, duct_region.entities[i].end.y)\n    rad_mid_i = (rad_start_i + rad_end_i) / 2\n    rad_start_j, _ = xy_to_rt(duct_region.entities[j].start.x, duct_region.entities[j].start.y)\n    rad_end_j, _ = xy_to_rt(duct_region.entities[j].end.x, duct_region.entities[j].end.y)\n    rad_mid_j = (rad_start_j + rad_end_j) / 2\n    if rad_mid_i < rad_mid_j:\n        return True\n    else:\n        return False"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#generate-arc-associated-with-oblong-duct",
        "title": "Oblong stator ducts with thermal adjustment > Generate arc associated with oblong duct",
        "section": "Generate arc associated with oblong duct",
        "text": "Two separate functions are needed depending  on full duct or half duct (due to symmetry) is\npresent under Geometry Editor\ndef get_arc_radius(entity_start, entity_end, height):\n    # Generate arc radius and center based on\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n    x = math.dist(start_point_xy, end_point_xy) / 2  # chord length/2\n    y = height\n    # conversion to polar coordinates\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    return r\n\n\ndef get_arc_radius_halfduct(entity_start, entity_end, height, Line_origin, Symm_angle):\n    # Generate arc radius, center, start and  end point based on for half duct\n    # line and arc height\n    start_point_xy = [entity_start.x, entity_start.y]\n    end_point_xy = [entity_end.x, entity_end.y]\n\n    x = math.dist(start_point_xy, end_point_xy)  # chord length\n    y = height\n    start_point_r, start_point_t = xy_to_rt(entity_start.x, entity_start.y)\n    end_point_r, end_piont_t = xy_to_rt(entity_end.x, entity_end.y)\n    r = (x**2 + y**2) / (2 * y)  # radius\n    if Line_origin == True:\n        # line is closer to origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r - height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end  point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r - height, end_piont_t)\n    else:\n        # Line is far from origin\n        if start_point_t == 0 or round(start_point_t / Symm_angle, 2) == 1:\n            # start point is on symmetry boundary of geometry\n            new_start_x, new_start_y = rt_to_xy(start_point_r + height, start_point_t)\n            new_end_x, new_end_y = entity_end.x, entity_end.y\n        elif end_piont_t == 0 or round(end_piont_t / Symm_angle, 2) == 1:\n            # end point is on symmetry boundary of geometry\n            new_start_x, new_start_y = entity_start.x, entity_start.y\n            new_end_x, new_end_y = rt_to_xy(end_point_r + height, end_piont_t)\n    new_start_point = Coordinate(new_start_x, new_start_y)\n    new_end_point = Coordinate(new_end_x, new_end_y)\n    return r, new_start_point, new_end_point"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#get-required-parameters-and-objects",
        "title": "Oblong stator ducts with thermal adjustment > Get required parameters and objects",
        "section": "Get required parameters and objects",
        "text": "From Motor-CAD, get the adaptive parameters and their values.\nUse the set_default_parameter() method to set the required Duct Arc Height parameter\nif undefined.\nSet required parameters for the oblong: height of arc Duct Arc Height, duct width and duct\nheight.\nGet the standard template stator region. This can be drawn for debugging if required.\nset_default_parameter(\"Duct Arc Height\", 0.7)\nduct_arc_height = mc.get_adaptive_parameter_value(\"Duct Arc Height\")\nduct_height = mc.get_variable(\"CircularDuctL1ChannelHeight\")\nduct_width = mc.get_variable(\"CircularDuctL1ChannelWidth\")\nduct_area = duct_height * duct_width\nst_region = mc.get_region(\"stator\")  # get the stator region"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#create-the-adaptive-templates-geometry",
        "title": "Oblong stator ducts with thermal adjustment > Create the Adaptive Templates geometry",
        "section": "Create the Adaptive Templates geometry",
        "text": "For each child region of the stator region:\nCheck whether the region is a stator duct.\nFind the top and bottom lines that makes up the duct.\nModify the lines with respective arcs.\nSet the region in Motor-CAD.\nThe script accounts for whether ducts are full ducts or half ducts (the case when a duct spans the\nrotor pole boundary)\nfor child_name in st_region.child_names:\n    if \"StatorDuctFluidRegion\" in child_name:\n        duct_region = mc.get_region(child_name)\n        if round(duct_region.area / duct_area, 2) == 1:  # check if  full duct is drawn\n            for i, entity in enumerate(duct_region.entities):\n                if round(entity.length / duct_width, 2) == 1:  # check if the line is duct width\n                    # additional check in case width = height\n                    _, angle_start_point_angle = xy_to_rt(entity.start.x, entity.start.y)\n                    _, angle_end_point_angle = xy_to_rt(entity.end.x, entity.end.y)\n                    if (\n                        abs(angle_end_point_angle - angle_start_point_angle) > 0.05\n                    ):  # 0.05 degree is tolerance\n                        # get radius and center\n                        # convert this line segment to Arc\n                        Line_origin = check_line_origin_distance(\n                            i, duct_region\n                        )  # line near of far from origin\n                        radius = get_arc_radius(entity.start, entity.end, duct_arc_height)\n                        Duct_Arc = Arc(entity.start, entity.end, radius=radius)\n                        duct_region.entities[i] = Duct_Arc\n\n        elif round(duct_region.area / duct_area, 2) == 0.5:  # if the half duct is drawn\n            Symm_angle = 360 / duct_region.duplications  # angle of symmetry\n            for i, entity in enumerate(duct_region.entities):\n                if (\n                    round(entity.length / duct_width, 2) == 0.5\n                ):  # check if  the line is half duct width\n                    # additional check in case width/2 = height\n                    _, angle_start_point_angle = xy_to_rt(entity.start.x, entity.start.y)\n                    _, angle_end_point_angle = xy_to_rt(entity.end.x, entity.end.y)\n                    if (\n                        abs(angle_end_point_angle - angle_start_point_angle) > 0.05\n                    ):  # 0.05 degree is tolerance\n                        # get radius and center\n                        # convert this line segment to Arc\n                        Line_origin = check_line_origin_distance(i, duct_region)\n                        radius, start_point, end_point = get_arc_radius_halfduct(\n                            entity.start, entity.end, duct_arc_height, Line_origin, Symm_angle\n                        )\n                        Duct_Arc = Arc(start_point, end_point, radius=radius)\n                        duct_region.entities[i] = Duct_Arc\n                elif round(entity.length / duct_height, 2) == 1:\n                    # modify the line on symmetry planes\n                    rad_start_point, angle_start_point = xy_to_rt(entity.start.x, entity.start.y)\n                    rad_end_point, angle_end_point = xy_to_rt(entity.end.x, entity.end.y)\n                    if angle_start_point == 0 and angle_end_point == 0:\n                        # line located at x=0\n                        entity.start.x = entity.start.x - duct_arc_height\n                        entity.end.x = entity.end.x + duct_arc_height\n                    elif (\n                        round(angle_start_point / Symm_angle, 2) == 1\n                        and round(angle_end_point / Symm_angle, 2) == 1\n                    ):\n                        # line on symmetry plane\n                        # start and end point follow anticlockwise naming convention\n                        rad_start_point = rad_start_point + duct_arc_height\n                        rad_end_point = rad_end_point - duct_arc_height\n                        new_start_x, new_start_y = rt_to_xy(rad_start_point, angle_start_point)\n                        new_end_x, new_end_y = rt_to_xy(rad_end_point, angle_end_point)\n                        start_point = Coordinate(new_start_x, new_start_y)\n                        end_point = Coordinate(new_end_x, new_end_y)\n                        duct_region.entities[i] = Line(start_point, end_point)\n\n        mc.set_region(duct_region)"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#apply-surface-area-correction-in-motor-cad-thermal",
        "title": "Oblong stator ducts with thermal adjustment > Apply surface area correction in Motor-CAD Thermal",
        "section": "Apply surface area correction in Motor-CAD Thermal",
        "text": "The oblong stator ducts can be used in the Motor-CAD Thermal model as channels for water jacket\ncooling. The Housing Water Jacket cooling model in Motor-CAD can be set up to use stator duct\nchannels when a housing type without channels is selected in the Geometry tab.\nAs of Motor-CAD v2024R2, the Housing Water Jacket calculations will use duct areas from the\nMotor-CAD Standard Template geometry - not the custom Adaptive Templates geometry. For example,\nwhen the stator duct geometry has been updated from rectangular to oblong shapes, the duct area\nhas increased. For this example, the area increases from 6 mm2 to 8.038522. This\ncan be seen in the Geometry -> Editor -> Geometry tab, or by using the area method for the\nduct region.\nTo account for this in the Housing Water Jacket cooling model, you can apply a cross section\narea adjustment. By default, this is set to 0. To see this in the Motor-CAD interface, go to the\nInput Data -> Housing Water Jacket -> Fluid FLow tab in the Thermal context.\nThe appropriate area adjustment is calculated and applied within the Adaptive Templates script.\nTo calculate the area adjustment, get the area of the stator duct regions using the area\nmethod. For the case where there are two half-ducts, it is necessary to get the area for all duct\nregions and to calculate the sum of the areas.\nThe area of the original rectangular duct was already calculated earlier (duct_area). The area\nadjustment is calculated by subtracting the rectangular duct area from the oblong duct area.\nSet the area adjustment value in Motor-CAD.\nThe area adjustment is applied by the Adaptive Templates script and is updated any time the\ngeometry is changed.\noblong_duct_areas = []\nnum_slots = mc.get_variable(\"Slot_Number\")\nnum_ducts = mc.get_variable(\"CircularDuctL1Channels\")\nducts_per_slot = num_ducts / num_slots\nfor child_name in st_region.child_names:\n    if \"StatorDuctFluidRegion\" in child_name:\n        oblong_duct_areas.append(mc.get_region(child_name).area)\noblong_duct_area = sum(oblong_duct_areas) / ducts_per_slot\narea_adjustment = oblong_duct_area - duct_area\nmc.set_array_variable(\"HousingWJ_Channel_CSArea_L1_A_Adjustment\", 0, area_adjustment)"
    },
    {
        "objectID": "examples/adaptive_library/OblongStatorDuct",
        "href": "examples/adaptive_library/OblongStatorDuct.html#load-in-adaptive-templates-script-if-required",
        "title": "Oblong stator ducts with thermal adjustment > Load in Adaptive Templates script if required",
        "section": "Load in Adaptive Templates script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 34.844 seconds)\nDownload Jupyter notebook: OblongStatorDuct.ipynb\nDownload Python source code: OblongStatorDuct.py\nDownload zipped: OblongStatorDuct.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#motor-cad-emag-twin-builder-ece",
        "title": "Motor-CAD EMag Twin Builder ECE",
        "section": "Motor-CAD EMag Twin Builder ECE",
        "text": "This example provides a Motor-CAD script for exporting\nan equivalent circuit extraction (ECE) model for permanent\nmagnet synchronous motors (PMSMs) from Motor-CAD to Ansys\nTwin Builder.\nSetting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and\nimporting the initial settings.\nImport the required packages.\nInitialize ActiveX automation and launch Motor-CAD.\nDisable all popup messages from Motor-CAD.\nYou use the read_parameters method to import initial settings\nfrom a JSON file:\nSpecify the working directory.\nOpen the JSON file and import the initial settings.\nSave input settings to a MCAD file.\nDetect alignment angles and run the simulation.\nPlot the flux linkage for the A phase.\nCalculate the torque points per cycle.\nDefine the factor function.\nCalculate the saturation map.\nLoad the saturation map.\nImplement the final table.\nPlot flux linkage in the A phase.\nPlot torque.\nPlot D-flux linkages versus the q-axis current.\nWrite the TXT text.\nWrite the SML file.\nExit Motor-CAD.\nTotal running time of the script: (9 minutes 16.291 seconds)\nDownload Jupyter notebook: ece_export_for_twinbuilder.ipynb\nDownload Python source code: ece_export_for_twinbuilder.py\nDownload zipped: ece_export_for_twinbuilder.zip\nGallery generated by Sphinx-Gallery\nimport json\nimport math\nimport os\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import io\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\ndef read_parameters(json_file):\n    \"\"\"Read input parameters.\"\"\"\n    with open(json_file, \"r\") as f:\n        param_dict = json.load(f)\n    return param_dict\nworking_folder = os.getcwd()\njson_file = os.path.join(working_folder, \"ece_config.json\")\nin_data = read_parameters(json_file)\nmot_file = in_data[\"mot_file\"]\nshaft_speed = in_data[\"shaft_speed\"]\ndc_bus_voltage = float(in_data[\"dc_bus_voltage\"])\nmachine_temp = float(in_data[\"machine_temp\"])\nId_max = float(in_data[\"Id_max\"])\ncurrent_step = float(in_data[\"current_step\"])\nmap_name = in_data[\"map_name\"]\ntxt_file = in_data[\"txt_file\"]\nsml_file = in_data[\"sml_file\"]\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name))\npoints_per_cycle = 30\nmcad.set_variable(\"DCBusVoltage\", dc_bus_voltage)\nmcad.set_variable(\"ArmatureConductor_Temperature\", machine_temp)\nmcad.set_variable(\"Magnet_Temperature\", machine_temp)\nmcad.set_variable(\"Shaft_Temperature\", machine_temp)\nmcad.set_variable(\"CurrentDefinition\", 0)\nmcad.set_variable(\"MagneticThermalCoupling\", 0)\nmcad.set_variable(\"BackEMFCalculation\", True)\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"ShaftSpeed\", shaft_speed)\nmcad.set_variable(\"PeakCurrent\", 0)\nmcad.set_variable(\"CoggingTorqueCalculation\", False)\nmcad.set_variable(\"TorqueCalculation\", False)\nmcad.set_variable(\"TorqueSpeedCalculation\", False)\ntry:\n    mcad.do_magnetic_calculation()\nexcept pymotorcad.MotorCADError:\n    print(\"Calculation failed.\")\ne_deg = []\nflux_a = []\nindexf = points_per_cycle\nfor n in range(indexf + 1):\n    xa, ya = mcad.get_magnetic_graph_point(\"FluxLinkageOCPh1\", n)\n    e_deg.append(xa)\n    flux_a.append(ya)\np = mcad.get_variable(\"Pole_Number\")\ndrive = mcad.get_variable(\"DriveOffsetAngleLoad\")\nphase_res = mcad.get_variable(\"ArmatureWindingResistancePh\")\nphase_l = mcad.get_variable(\"EndWdgInductance_Used\")\ndrive_offset = 90 + drive\np = p / 2\nmax_elec_degree = 120\nfac = []\nd = 2\nn = drive_offset\nwhile n >= d:\n    if n % d == 0:\n        fac.append(d)\n        n /= d\n    else:\n        d = d + 1\n\nfac_size = len(fac)\nelec_deg = fac[fac_size - 1]\ni = 1\nwhile (max_elec_degree / elec_deg) < 30:\n    elec_deg = fac[fac_size - 1 - i]\n    i = i + 1\nm_period = max_elec_degree / p\nmec_deg = float(float(elec_deg) / float(p))\npoints_per_cycle = 360 / elec_deg\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"SaturationMap_ExportFile\", map_name)\nmcad.set_variable(\"SaturationMap_InputDefinition\", 1)\nmcad.set_variable(\"SaturationMap_CalculationMethod\", 1)\nmcad.set_variable(\"SaturationMap_FEACalculationType\", 1)\nmcad.set_variable(\"SaturationMap_ResultType\", 1)\nmcad.set_variable(\"LossMap_Export\", False)\nmcad.set_variable(\"SaturationMap_Current_D_Max\", Id_max)\nmcad.set_variable(\"SaturationMap_Current_D_Step\", current_step)\nmcad.set_variable(\"SaturationMap_Current_D_Min\", -Id_max)\nmcad.set_variable(\"SaturationMap_Current_Q_Max\", Id_max)\nmcad.set_variable(\"SaturationMap_Current_Q_Step\", current_step)\nmcad.set_variable(\"SaturationMap_Current_Q_Min\", -Id_max)\n\ntry:\n    mcad.calculate_saturation_map()\nexcept pymotorcad.MotorCADError:\n    print(\"Map calculation failed.\")\nmat_file_data = io.loadmat(map_name)\n\nid_peak = mat_file_data[\"Id_Peak\"]\niq_peak = mat_file_data[\"Iq_Peak\"]\nangular_flux_linkage_d = mat_file_data[\"Angular_Flux_Linkage_D\"]\nangular_flux_linkage_q = mat_file_data[\"Angular_Flux_Linkage_Q\"]\nangular_flux_linkage_1 = mat_file_data[\"Angular_Flux_Linkage_Phase_1\"]\nangular_flux_linkage_2 = mat_file_data[\"Angular_Flux_Linkage_Phase_2\"]\nangular_flux_linkage_3 = mat_file_data[\"Angular_Flux_Linkage_Phase_3\"]\nangular_rotor_position = mat_file_data[\"Angular_Rotor_Position\"]\nangular_electromagnetic_torque = mat_file_data[\"Angular_Electromagnetic_Torque\"]\nphase_advance = mat_file_data[\"Phase_Advance\"]\nd_values = len(id_peak)\nq_values = len(id_peak[0])\ncomb = d_values * q_values\nmap_points = int((max_elec_degree / elec_deg) + 1)\nrot_pos = (max_elec_degree / p) + 1\nind = 0\nindex_1 = []\nflux_d_2 = []\nflux_q_3 = []\nflux_0_4 = []\ntorque_5 = []\nid_6 = []\niq_7 = []\nphase_ad_8 = []\nrotor_pos_9 = []\nfinal_table = []\nskip = math.ceil(drive_offset / elec_deg)\nfor i in range(d_values):\n    for j in range(q_values):\n        for k in range(int(skip), int(skip - map_points), (-1)):\n            ind = ind + 1\n            if k < 0:\n                kprimo = int(points_per_cycle + k)\n                index_1.append(ind - 1)\n                flux_d_2.append(angular_flux_linkage_d[i, j, kprimo])\n                flux_q_3.append(angular_flux_linkage_q[i, j, kprimo])\n                flux_0_4.append(0)\n                torque_5.append(-angular_electromagnetic_torque[i, j, kprimo])\n                id_6.append(id_peak[i, j])\n                iq_7.append(iq_peak[i, j])\n                phase_ad_8.append(phase_advance[i, j])\n                rotor_pos_9.append(angular_rotor_position[i, j, kprimo])\n            else:\n                index_1.append(ind - 1)\n                flux_d_2.append(angular_flux_linkage_d[i, j, k])\n                flux_q_3.append(angular_flux_linkage_q[i, j, k])\n                flux_0_4.append(0)\n                torque_5.append(-angular_electromagnetic_torque[i, j, k])\n                id_6.append(id_peak[i, j])\n                iq_7.append(iq_peak[i, j])\n                phase_ad_8.append(phase_advance[i, j])\n                rotor_pos_9.append(angular_rotor_position[i, j, k])\n\nfinal_table = np.array(\n    [index_1, flux_d_2, flux_q_3, flux_0_4, torque_5, id_6, iq_7, phase_ad_8, rotor_pos_9]\n)\nplt.figure(1)\nplt.plot(e_deg, flux_a)\nplt.xlabel(\"Position [EDeg]\")\nplt.ylabel(\"FluxLinkageA\")\nplt.title(\"A_Phase Flux Linkage\")\nplt.show()\n\n# Plot the D-Q flux.\nplt.figure(2)\nplt.plot(index_1, flux_d_2, \"r\", index_1, flux_q_3, \"b\", linewidth=1.0)\nplt.xlabel(\"Points\")\nplt.ylabel(\"Flux [Vs]\")\nplt.legend([\"Psid\", \"Psiq\"], loc=\"lower right\")\nplt.title(\"D-Q Flux\")\nplt.show()\nplt.figure(3)\nplt.plot(index_1, torque_5, \"r\", linewidth=2.0)\nplt.ylabel(\"Torque [Nm]\")\nplt.xlabel(\"Points\")\nplt.title(\"Torque\")\nplt.show()\nplt.figure(3)\nfor i in range(d_values):\n    plt.plot(\n        iq_peak[0, :], angular_flux_linkage_q[i, :, skip], label=\"Id=\" + str(id_peak[i, 0]) + \"A\"\n    )\nplt.ylabel(\"Flux [Vs]\")\nplt.xlabel(\"Iq [A]\")\nplt.legend(fontsize=8, loc=\"lower right\")\nplt.title(\"D-Flux vs Iq\")\nplt.show()\n\n# Plot Q-flux linkages versus the q-axis current.\nplt.figure(4)\nfor i in range(d_values):\n    plt.plot(\n        iq_peak[0, :], angular_flux_linkage_d[:, i, skip], label=\"Id=\" + str(id_peak[i, 0]) + \"A\"\n    )\nplt.legend(fontsize=8, loc=\"lower right\")\nplt.ylabel(\"Flux [Vs]\")\nplt.xlabel(\"Iq [A]\")\nplt.title(\"Q-Flux vs Iq\")\nplt.show()\nrows = len(index_1)\n\nfile_id = open(txt_file, \"w\")\nfile_id.write(\"%6s\\r\\n\" % \"B_BasicData\")\nfile_id.write(\"%6s\\r\\n\" % \"  Version   1.0\")\nfile_id.write(\"%6s %i\\r\\n\" % (\"  Poles\", p * 2))\nfile_id.write(\"%6s\\r\\n\\n\" % \"E_BasicData\")\n\nfile_id.write(\"%6s\\r\\n\" % \"B_PhaseImp 3\")\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph1\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph2\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph3\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s\\r\\n\\n\" % \"E_PhaseImp\")\n\nfile_id.write(\"%6s\\r\\n\\n\" % \"B_Sweepings\")\nfile_id.write(\"%s %i %s\" % (\"  Id_Iq     (\", d_values, \":\"))\nfor i in range(d_values):\n    file_id.write(\"%s %i\" % (\" \", id_peak[i, 0]))\nfile_id.write(\"%s\\n\" % \")\")\n\nfile_id.write(\"%s %i %s\" % (\"            (\", q_values, \":\"))\nfor i in range(q_values):\n    file_id.write(\"%s %i\" % (\" \", iq_peak[0, i]))\nfile_id.write(\"%s\\n\" % \")\")\n\nfile_id.write(\"%s %i %s\" % (\"  Rotate    (\", map_points, \":\"))\n\nfor i in range(map_points):\n    file_id.write(\"%s %6.3f\" % (\" \", i * mec_deg))\nfile_id.write(\"%s\\n\" % \")\")\nfile_id.write(\"%s\\n\\n\" % \"E_Sweepings\")\n\nfile_id.write(\"%s\\n\" % \"B_OutputMatrix DQ0\")\n\nfor i in range(rows):\n    file_id.write(\n        \"%10i %19.10e %19.10e %19.10e %19.10e\\r\\n\"\n        % (index_1[i], flux_d_2[i], flux_q_3[i], flux_0_4[i], torque_5[i])\n    )\nfile_id.write(\"%s\\n\" % \"E_OutputMatrix\")\n\nfile_id.close()\nfile_id = open(sml_file, \"w\")\nfile_id.write(\"%6s\\r\\n\" % \"MODELDEF ECER_Model1\")\nfile_id.write(\"%s\\r\\n\" % \"{\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: A0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: X0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: B0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: Y0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: C0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: Z0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT ROTATIONAL_V: ROT1;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT ROTATIONAL_V: ROT2;\")\n\nfile_id.write(\"%6s%4.3f%s\\r\\n\" % (\"PORT REAL IN: ra0 = \", phase_res, \";\"))\nfile_id.write(\"%6s%4.0e%s\\r\\n\" % (\"PORT REAL IN: la0 = \", phase_l, \";\"))\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIa0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIb0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIc0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxa0 = AM_Fluxa0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxb0 = AM_Fluxb0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxc0 = AM_Fluxc0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxd0 = AMFd.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxq0 = AMFq.I;\")\n\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN ANGLE[deg]: IniPos = 0;\")\nfile_id.write(\"%6s\\r\\n\\n\" % \"PORT REAL OUT ANGLE[deg]: Pos = VM_Mdeg.V;\")\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Ra0  N1:=A0, N2:=N_1  ( R:=ra0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        La0  N1:=N_1, N2:=N_2  ( L:=la0, I0:=IniIa0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMa0  N1:=N_2, N2:=N_3  ;\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  EV       Ema0  N1:=N_3, N2:=X0  ( QUANT:=VMa0.V, FACT:=-1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lma0  N1:=N_4, N2:=GND  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMa0  N1:=N_4, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxa0  N1:=N_5, N2:=N_4  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % \"INTERN  II       Fluxad  N1:=GND, N2:=N_5  ( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % \"INTERN  II       Fluxaq  N1:=GND, N2:=N_5  ( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V) ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  II       Fluxao  N1:=GND, N2:=N_5  ( QUANT:=AMFo.I, FACT:=1 ); \")\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxa0  N1:=GND, N2:=N_5  ( QUANT:=AMo.I, FACT:=0 ); \"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Rb0  N1:=B0, N2:=N_6  ( R:=ra0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lb0  N1:=N_6, N2:=N_7  ( L:=la0, I0:=IniIb0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMb0  N1:=N_7, N2:=N_8  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  EV       Emb0  N1:=N_8, N2:=Y0  ( QUANT:=VMb0.V, FACT:=-1 );  \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lmb0  N1:=N_9, N2:=GND  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMb0  N1:=N_9, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxb0  N1:=N_10, N2:=N_9  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxbd  N1:=GND, N2:=N_10  \"\n        \"( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V-2*PI/3) );\"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxbq  N1:=GND, N2:=N_10  \"\n        \"( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Fluxbo  N1:=GND, N2:=N_10\" \"  ( QUANT:=AMFo.I, FACT:=1 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxb0  N1:=GND, N2:=N_10\" \"  ( QUANT:=AMo.I, FACT:=0 ); \"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Rc0  N1:=C0, N2:=N_11  \" \"( R:=ra0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lc0  N1:=N_11, N2:=N_12\" \"  ( L:=la0, I0:=IniIc0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMc0  N1:=N_12, N2:=N_13\" \"  ;  \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  EV       Emc0  N1:=N_13, N2:=Z0\" \"  ( QUANT:=VMc0.V, FACT:=-1 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lmc0  N1:=N_14, N2:=GND\" \"  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMc0  N1:=N_14, N2:=GND\" \"  ;\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxc0  N1:=N_15,\" \" N2:=N_14  ;\")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxcd  N1:=GND, N2:=N_15  \"\n        \"( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxcq  N1:=GND, N2:=N_15\"\n        \"  ( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Fluxco  N1:=GND,\" \" N2:=N_15  ( QUANT:=AMFo.I, FACT:=1 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxc0  N1:=GND,\" \" N2:=N_15  ( QUANT:=AMo.I, FACT:=0 );\"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM\" \"       AMFd  N1:=N_16, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN\" \"  AM       AMFq  N1:=N_17, N2:=GND  ;\")\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN\" \"  AM       AMFo  N1:=N_18, N2:=GND  ; \")\n\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Id0  N1:=GND,\"\n    \" N2:=N_19  ( QUANT:=AMa0.I, FACT:=2/3*cos(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Id1  N1:=GND, N2:=N_19\"\n        \"  ( QUANT:=AMb0.I, FACT:=2/3*cos(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Id2  N1:=GND, N2:=N_19\"\n        \"  ( QUANT:=AMc0.I, FACT:=2/3*cos(VM_Erad.V-4*PI/3) );\"\n    )\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM0  N1:=N_19,\" \" N2:=GND  ;\")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Iq0  N1:=GND, N2:=N_20\"\n    \"  ( QUANT:=AMa0.I, FACT:=2/3*sin(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Iq1  N1:=GND, N2:=N_20\"\n        \"  ( QUANT:=AMb0.I, FACT:=2/3*sin(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Iq2  N1:=GND, N2:=N_20\"\n        \"  ( QUANT:=AMc0.I, FACT:=2/3*sin(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM1  N1:=N_20,\" \" N2:=GND  ; \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I00  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMa0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I01  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMb0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I02  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMc0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN  \" \"AM       AMo  N1:=N_21, N2:=GND  ; \")\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  \" \"VM       VM_Speed  N1:=N_23, N2:=N_22  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"UMODEL  D2D      \"\n        'D2D1 N1:=N_23, N2:=ROT1 ( NATURE_1:=\"electrical\",'\n        ' NATURE_2:=\"Rotational_V\" ) SRC: DLL( File:=\"Domains.dll\");'\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"UMODEL  D2D      \"\n        'D2D2 N1:=N_22, N2:=ROT2 ( NATURE_1:=\"electrical\",'\n        ' NATURE_2:=\"Rotational_V\" ) SRC: DLL( File:=\"Domains.dll\");'\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  IV       \"\n    \"Gx  N1:=GND,\"\n    \" N2:=N_24  ( QUANT:=VM_Speed.V, FACT:=57.29578 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  C\" \"        \" \"Cx  N1:=N_24, N2:=GND  ( C:=1, V0:=IniPos ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM\" \"\" \"       VM_Mdeg  N1:=N_24, N2:=GND  ; \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  IV\" \"\" \"       Ipos  N1:=GND, N2:=N_25  ( QUANT:=VM_Mdeg.V, FACT:=1 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM\" \"\" \"       AM2  N1:=N_25, N2:=N_26  ; \")\nfile_id.write(\n    \"%6s %8.7f %s\\r\\n\"\n    % (\"INTERN  R\" \"        Rpos  N1:=N_26, N2:=GND  ( R:=\", 0.0174533 * p, \" ); \")\n)\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN  VM\" \"\" \"       VM_Erad  N1:=N_26, N2:=GND  ;\")\n\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  NDSRC    PECER_Model1  N0:=GND,\"\n        \" N1:=N_16, N2:=GND, N3:=N_17,\"\n        \" N4:=GND, N5:=N_18, N6:=N_22, N7:=N_23 \\ \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \" ( QUANT:={ AM0.I, AM1.I, AM2.I },\"\n    ' SRC:={ isrc, isrc, isrc, isrc }, TableData:=\"\\ '\n)\nfile_id.write(\"%6s\" % \".MODEL ECER_Model1_table pwl TABLE=(\")\nfile_id.write(\"%s%u%s\" % (\" \", d_values, \",\"))\n\nindex = 0\n\nfor i in range(d_values):\n    file_id.write(\"%s%d\" % (\" \", id_peak[i, 0]))\n    file_id.write(\"%s\" % \",\")\n    if i == (d_values - 1):\n        file_id.write(\"%s\\n\" % \"\\ \")\n        file_id.write(\"%s\" % \" 0,\")\n\nfor r in range(d_values):\n    file_id.write(\"%s%u%s\" % (\" \", q_values, \",\"))\n    for i in range(q_values):\n        file_id.write(\"%s%d\" % (\" \", iq_peak[0, i]))\n        file_id.write(\"%s\" % \",\")\n        if i == (q_values - 1):\n            file_id.write(\"%s\\n\" % \"\\ \")\n            file_id.write(\"%s\" % \" 0,\")\n\n    for k in range(q_values):\n        file_id.write(\"%s%u%s\" % (\" \", map_points, \",\"))\n        for i in range(map_points):\n            file_id.write(\"%s%6.3f\" % (\" \", i * mec_deg))\n            file_id.write(\"%s\" % (\",\"))\n            if i == (map_points - 1):\n                file_id.write(\"%s\\n\" % \"\\ \")\n                file_id.write(\"%s\" % \" 4,\")\n\n        for j in range(1, 5):\n            for i in range(map_points):\n                file_id.write(\"%s%f\" % (\" \", final_table[int(j), int(index + i)]))\n                file_id.write(\"%s\" % (\",\"))\n                if r == (d_values - 1) and k == (q_values - 1) and j == 4 and i == (map_points - 1):\n                    file_id.write(\"%s\\r\\n\" % \") LINEAR LINEAR PERIODIC\\ \")\n                    file_id.write(\"%s\\r\\n\" % ' DEEPSPLINE\" );')\n                    file_id.write(\"%s\\r\\n\" % \"}\")\n                elif i == (map_points - 1):\n                    file_id.write(\"%s\\n\" % \"\\ \")\n        index = index + map_points\n\nfile_id.close()\nmcad.quit()"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#set-up-example",
        "title": "Motor-CAD EMag Twin Builder ECE > Set up example",
        "section": "Set up example",
        "text": "Setting up this example consists of performing imports, launching\nMotor-CAD, disabling all popup messages from Motor-CAD, and\nimporting the initial settings.\nImport the required packages.\nInitialize ActiveX automation and launch Motor-CAD.\nDisable all popup messages from Motor-CAD.\nimport json\nimport math\nimport os\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import io\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#perform-required-imports",
        "title": "Motor-CAD EMag Twin Builder ECE > Perform required imports",
        "section": "Perform required imports",
        "text": "Import the required packages.\nimport json\nimport math\nimport os\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import io\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\""
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#launch-motor-cad",
        "title": "Motor-CAD EMag Twin Builder ECE > Launch Motor-CAD",
        "section": "Launch Motor-CAD",
        "text": "Initialize ActiveX automation and launch Motor-CAD.\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization."
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#disable-popup-messages",
        "title": "Motor-CAD EMag Twin Builder ECE > Disable popup messages",
        "section": "Disable popup messages",
        "text": "Disable all popup messages from Motor-CAD.\nmcad.set_variable(\"MessageDisplayState\", 2)"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#import-and-save-initial-settings",
        "title": "Motor-CAD EMag Twin Builder ECE > Import and save initial settings",
        "section": "Import and save initial settings",
        "text": "You use the read_parameters method to import initial settings\nfrom a JSON file:\nSpecify the working directory.\nOpen the JSON file and import the initial settings.\nSave input settings to a MCAD file.\ndef read_parameters(json_file):\n    \"\"\"Read input parameters.\"\"\"\n    with open(json_file, \"r\") as f:\n        param_dict = json.load(f)\n    return param_dict\nworking_folder = os.getcwd()\njson_file = os.path.join(working_folder, \"ece_config.json\")\nin_data = read_parameters(json_file)\nmot_file = in_data[\"mot_file\"]\nshaft_speed = in_data[\"shaft_speed\"]\ndc_bus_voltage = float(in_data[\"dc_bus_voltage\"])\nmachine_temp = float(in_data[\"machine_temp\"])\nId_max = float(in_data[\"Id_max\"])\ncurrent_step = float(in_data[\"current_step\"])\nmap_name = in_data[\"map_name\"]\ntxt_file = in_data[\"txt_file\"]\nsml_file = in_data[\"sml_file\"]\nmcad.load_template(\"e8\")\nmcad_name = \"e8_mobility\"\nmcad.save_to_file(os.path.join(working_folder, mcad_name))"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#run-simulation",
        "title": "Motor-CAD EMag Twin Builder ECE > Run simulation",
        "section": "Run simulation",
        "text": "Detect alignment angles and run the simulation.\nPlot the flux linkage for the A phase.\nCalculate the torque points per cycle.\nDefine the factor function.\nCalculate the saturation map.\nLoad the saturation map.\nImplement the final table.\npoints_per_cycle = 30\nmcad.set_variable(\"DCBusVoltage\", dc_bus_voltage)\nmcad.set_variable(\"ArmatureConductor_Temperature\", machine_temp)\nmcad.set_variable(\"Magnet_Temperature\", machine_temp)\nmcad.set_variable(\"Shaft_Temperature\", machine_temp)\nmcad.set_variable(\"CurrentDefinition\", 0)\nmcad.set_variable(\"MagneticThermalCoupling\", 0)\nmcad.set_variable(\"BackEMFCalculation\", True)\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"ShaftSpeed\", shaft_speed)\nmcad.set_variable(\"PeakCurrent\", 0)\nmcad.set_variable(\"CoggingTorqueCalculation\", False)\nmcad.set_variable(\"TorqueCalculation\", False)\nmcad.set_variable(\"TorqueSpeedCalculation\", False)\ntry:\n    mcad.do_magnetic_calculation()\nexcept pymotorcad.MotorCADError:\n    print(\"Calculation failed.\")\ne_deg = []\nflux_a = []\nindexf = points_per_cycle\nfor n in range(indexf + 1):\n    xa, ya = mcad.get_magnetic_graph_point(\"FluxLinkageOCPh1\", n)\n    e_deg.append(xa)\n    flux_a.append(ya)\np = mcad.get_variable(\"Pole_Number\")\ndrive = mcad.get_variable(\"DriveOffsetAngleLoad\")\nphase_res = mcad.get_variable(\"ArmatureWindingResistancePh\")\nphase_l = mcad.get_variable(\"EndWdgInductance_Used\")\ndrive_offset = 90 + drive\np = p / 2\nmax_elec_degree = 120\nfac = []\nd = 2\nn = drive_offset\nwhile n >= d:\n    if n % d == 0:\n        fac.append(d)\n        n /= d\n    else:\n        d = d + 1\n\nfac_size = len(fac)\nelec_deg = fac[fac_size - 1]\ni = 1\nwhile (max_elec_degree / elec_deg) < 30:\n    elec_deg = fac[fac_size - 1 - i]\n    i = i + 1\nm_period = max_elec_degree / p\nmec_deg = float(float(elec_deg) / float(p))\npoints_per_cycle = 360 / elec_deg\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"SaturationMap_ExportFile\", map_name)\nmcad.set_variable(\"SaturationMap_InputDefinition\", 1)\nmcad.set_variable(\"SaturationMap_CalculationMethod\", 1)\nmcad.set_variable(\"SaturationMap_FEACalculationType\", 1)\nmcad.set_variable(\"SaturationMap_ResultType\", 1)\nmcad.set_variable(\"LossMap_Export\", False)\nmcad.set_variable(\"SaturationMap_Current_D_Max\", Id_max)\nmcad.set_variable(\"SaturationMap_Current_D_Step\", current_step)\nmcad.set_variable(\"SaturationMap_Current_D_Min\", -Id_max)\nmcad.set_variable(\"SaturationMap_Current_Q_Max\", Id_max)\nmcad.set_variable(\"SaturationMap_Current_Q_Step\", current_step)\nmcad.set_variable(\"SaturationMap_Current_Q_Min\", -Id_max)\n\ntry:\n    mcad.calculate_saturation_map()\nexcept pymotorcad.MotorCADError:\n    print(\"Map calculation failed.\")\nmat_file_data = io.loadmat(map_name)\n\nid_peak = mat_file_data[\"Id_Peak\"]\niq_peak = mat_file_data[\"Iq_Peak\"]\nangular_flux_linkage_d = mat_file_data[\"Angular_Flux_Linkage_D\"]\nangular_flux_linkage_q = mat_file_data[\"Angular_Flux_Linkage_Q\"]\nangular_flux_linkage_1 = mat_file_data[\"Angular_Flux_Linkage_Phase_1\"]\nangular_flux_linkage_2 = mat_file_data[\"Angular_Flux_Linkage_Phase_2\"]\nangular_flux_linkage_3 = mat_file_data[\"Angular_Flux_Linkage_Phase_3\"]\nangular_rotor_position = mat_file_data[\"Angular_Rotor_Position\"]\nangular_electromagnetic_torque = mat_file_data[\"Angular_Electromagnetic_Torque\"]\nphase_advance = mat_file_data[\"Phase_Advance\"]\nd_values = len(id_peak)\nq_values = len(id_peak[0])\ncomb = d_values * q_values\nmap_points = int((max_elec_degree / elec_deg) + 1)\nrot_pos = (max_elec_degree / p) + 1\nind = 0\nindex_1 = []\nflux_d_2 = []\nflux_q_3 = []\nflux_0_4 = []\ntorque_5 = []\nid_6 = []\niq_7 = []\nphase_ad_8 = []\nrotor_pos_9 = []\nfinal_table = []\nskip = math.ceil(drive_offset / elec_deg)\nfor i in range(d_values):\n    for j in range(q_values):\n        for k in range(int(skip), int(skip - map_points), (-1)):\n            ind = ind + 1\n            if k < 0:\n                kprimo = int(points_per_cycle + k)\n                index_1.append(ind - 1)\n                flux_d_2.append(angular_flux_linkage_d[i, j, kprimo])\n                flux_q_3.append(angular_flux_linkage_q[i, j, kprimo])\n                flux_0_4.append(0)\n                torque_5.append(-angular_electromagnetic_torque[i, j, kprimo])\n                id_6.append(id_peak[i, j])\n                iq_7.append(iq_peak[i, j])\n                phase_ad_8.append(phase_advance[i, j])\n                rotor_pos_9.append(angular_rotor_position[i, j, kprimo])\n            else:\n                index_1.append(ind - 1)\n                flux_d_2.append(angular_flux_linkage_d[i, j, k])\n                flux_q_3.append(angular_flux_linkage_q[i, j, k])\n                flux_0_4.append(0)\n                torque_5.append(-angular_electromagnetic_torque[i, j, k])\n                id_6.append(id_peak[i, j])\n                iq_7.append(iq_peak[i, j])\n                phase_ad_8.append(phase_advance[i, j])\n                rotor_pos_9.append(angular_rotor_position[i, j, k])\n\nfinal_table = np.array(\n    [index_1, flux_d_2, flux_q_3, flux_0_4, torque_5, id_6, iq_7, phase_ad_8, rotor_pos_9]\n)"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#plot-results",
        "title": "Motor-CAD EMag Twin Builder ECE > Plot results",
        "section": "Plot results",
        "text": "Plot flux linkage in the A phase.\nPlot torque.\nPlot D-flux linkages versus the q-axis current.\nplt.figure(1)\nplt.plot(e_deg, flux_a)\nplt.xlabel(\"Position [EDeg]\")\nplt.ylabel(\"FluxLinkageA\")\nplt.title(\"A_Phase Flux Linkage\")\nplt.show()\n\n# Plot the D-Q flux.\nplt.figure(2)\nplt.plot(index_1, flux_d_2, \"r\", index_1, flux_q_3, \"b\", linewidth=1.0)\nplt.xlabel(\"Points\")\nplt.ylabel(\"Flux [Vs]\")\nplt.legend([\"Psid\", \"Psiq\"], loc=\"lower right\")\nplt.title(\"D-Q Flux\")\nplt.show()\nplt.figure(3)\nplt.plot(index_1, torque_5, \"r\", linewidth=2.0)\nplt.ylabel(\"Torque [Nm]\")\nplt.xlabel(\"Points\")\nplt.title(\"Torque\")\nplt.show()\nplt.figure(3)\nfor i in range(d_values):\n    plt.plot(\n        iq_peak[0, :], angular_flux_linkage_q[i, :, skip], label=\"Id=\" + str(id_peak[i, 0]) + \"A\"\n    )\nplt.ylabel(\"Flux [Vs]\")\nplt.xlabel(\"Iq [A]\")\nplt.legend(fontsize=8, loc=\"lower right\")\nplt.title(\"D-Flux vs Iq\")\nplt.show()\n\n# Plot Q-flux linkages versus the q-axis current.\nplt.figure(4)\nfor i in range(d_values):\n    plt.plot(\n        iq_peak[0, :], angular_flux_linkage_d[:, i, skip], label=\"Id=\" + str(id_peak[i, 0]) + \"A\"\n    )\nplt.legend(fontsize=8, loc=\"lower right\")\nplt.ylabel(\"Flux [Vs]\")\nplt.xlabel(\"Iq [A]\")\nplt.title(\"Q-Flux vs Iq\")\nplt.show()"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#write-txt-and-sml-files",
        "title": "Motor-CAD EMag Twin Builder ECE > Write TXT and SML files",
        "section": "Write TXT and SML files",
        "text": "Write the TXT text.\nWrite the SML file.\nrows = len(index_1)\n\nfile_id = open(txt_file, \"w\")\nfile_id.write(\"%6s\\r\\n\" % \"B_BasicData\")\nfile_id.write(\"%6s\\r\\n\" % \"  Version   1.0\")\nfile_id.write(\"%6s %i\\r\\n\" % (\"  Poles\", p * 2))\nfile_id.write(\"%6s\\r\\n\\n\" % \"E_BasicData\")\n\nfile_id.write(\"%6s\\r\\n\" % \"B_PhaseImp 3\")\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph1\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph2\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s %12.10e %s %12.10e\\r\\n\" % (\"    WG_Ph3\", phase_res, \"    \", phase_l))\nfile_id.write(\"%6s\\r\\n\\n\" % \"E_PhaseImp\")\n\nfile_id.write(\"%6s\\r\\n\\n\" % \"B_Sweepings\")\nfile_id.write(\"%s %i %s\" % (\"  Id_Iq     (\", d_values, \":\"))\nfor i in range(d_values):\n    file_id.write(\"%s %i\" % (\" \", id_peak[i, 0]))\nfile_id.write(\"%s\\n\" % \")\")\n\nfile_id.write(\"%s %i %s\" % (\"            (\", q_values, \":\"))\nfor i in range(q_values):\n    file_id.write(\"%s %i\" % (\" \", iq_peak[0, i]))\nfile_id.write(\"%s\\n\" % \")\")\n\nfile_id.write(\"%s %i %s\" % (\"  Rotate    (\", map_points, \":\"))\n\nfor i in range(map_points):\n    file_id.write(\"%s %6.3f\" % (\" \", i * mec_deg))\nfile_id.write(\"%s\\n\" % \")\")\nfile_id.write(\"%s\\n\\n\" % \"E_Sweepings\")\n\nfile_id.write(\"%s\\n\" % \"B_OutputMatrix DQ0\")\n\nfor i in range(rows):\n    file_id.write(\n        \"%10i %19.10e %19.10e %19.10e %19.10e\\r\\n\"\n        % (index_1[i], flux_d_2[i], flux_q_3[i], flux_0_4[i], torque_5[i])\n    )\nfile_id.write(\"%s\\n\" % \"E_OutputMatrix\")\n\nfile_id.close()\nfile_id = open(sml_file, \"w\")\nfile_id.write(\"%6s\\r\\n\" % \"MODELDEF ECER_Model1\")\nfile_id.write(\"%s\\r\\n\" % \"{\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: A0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: X0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: B0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: Y0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: C0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT electrical: Z0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT ROTATIONAL_V: ROT1;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT ROTATIONAL_V: ROT2;\")\n\nfile_id.write(\"%6s%4.3f%s\\r\\n\" % (\"PORT REAL IN: ra0 = \", phase_res, \";\"))\nfile_id.write(\"%6s%4.0e%s\\r\\n\" % (\"PORT REAL IN: la0 = \", phase_l, \";\"))\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIa0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIb0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN: IniIc0 = 0;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxa0 = AM_Fluxa0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxb0 = AM_Fluxb0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxc0 = AM_Fluxc0.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxd0 = AMFd.I;\")\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL OUT: Fluxq0 = AMFq.I;\")\n\nfile_id.write(\"%6s\\r\\n\" % \"PORT REAL IN ANGLE[deg]: IniPos = 0;\")\nfile_id.write(\"%6s\\r\\n\\n\" % \"PORT REAL OUT ANGLE[deg]: Pos = VM_Mdeg.V;\")\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Ra0  N1:=A0, N2:=N_1  ( R:=ra0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        La0  N1:=N_1, N2:=N_2  ( L:=la0, I0:=IniIa0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMa0  N1:=N_2, N2:=N_3  ;\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  EV       Ema0  N1:=N_3, N2:=X0  ( QUANT:=VMa0.V, FACT:=-1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lma0  N1:=N_4, N2:=GND  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMa0  N1:=N_4, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxa0  N1:=N_5, N2:=N_4  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % \"INTERN  II       Fluxad  N1:=GND, N2:=N_5  ( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % \"INTERN  II       Fluxaq  N1:=GND, N2:=N_5  ( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V) ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  II       Fluxao  N1:=GND, N2:=N_5  ( QUANT:=AMFo.I, FACT:=1 ); \")\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxa0  N1:=GND, N2:=N_5  ( QUANT:=AMo.I, FACT:=0 ); \"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Rb0  N1:=B0, N2:=N_6  ( R:=ra0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lb0  N1:=N_6, N2:=N_7  ( L:=la0, I0:=IniIb0 );\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMb0  N1:=N_7, N2:=N_8  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  EV       Emb0  N1:=N_8, N2:=Y0  ( QUANT:=VMb0.V, FACT:=-1 );  \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lmb0  N1:=N_9, N2:=GND  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMb0  N1:=N_9, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxb0  N1:=N_10, N2:=N_9  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxbd  N1:=GND, N2:=N_10  \"\n        \"( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V-2*PI/3) );\"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxbq  N1:=GND, N2:=N_10  \"\n        \"( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Fluxbo  N1:=GND, N2:=N_10\" \"  ( QUANT:=AMFo.I, FACT:=1 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxb0  N1:=GND, N2:=N_10\" \"  ( QUANT:=AMo.I, FACT:=0 ); \"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  R        Rc0  N1:=C0, N2:=N_11  \" \"( R:=ra0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lc0  N1:=N_11, N2:=N_12\" \"  ( L:=la0, I0:=IniIc0 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AMc0  N1:=N_12, N2:=N_13\" \"  ;  \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  EV       Emc0  N1:=N_13, N2:=Z0\" \"  ( QUANT:=VMc0.V, FACT:=-1 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  L        Lmc0  N1:=N_14, N2:=GND\" \"  ( L:=1 ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM       VMc0  N1:=N_14, N2:=GND\" \"  ;\")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM_Fluxc0  N1:=N_15,\" \" N2:=N_14  ;\")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxcd  N1:=GND, N2:=N_15  \"\n        \"( QUANT:=AMFd.I, FACT:=cos(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Fluxcq  N1:=GND, N2:=N_15\"\n        \"  ( QUANT:=AMFq.I, FACT:=sin(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Fluxco  N1:=GND,\" \" N2:=N_15  ( QUANT:=AMFo.I, FACT:=1 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\\n\" % \"INTERN  II       Fluxc0  N1:=GND,\" \" N2:=N_15  ( QUANT:=AMo.I, FACT:=0 );\"\n)\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM\" \"       AMFd  N1:=N_16, N2:=GND  ; \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN\" \"  AM       AMFq  N1:=N_17, N2:=GND  ;\")\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN\" \"  AM       AMFo  N1:=N_18, N2:=GND  ; \")\n\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Id0  N1:=GND,\"\n    \" N2:=N_19  ( QUANT:=AMa0.I, FACT:=2/3*cos(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Id1  N1:=GND, N2:=N_19\"\n        \"  ( QUANT:=AMb0.I, FACT:=2/3*cos(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Id2  N1:=GND, N2:=N_19\"\n        \"  ( QUANT:=AMc0.I, FACT:=2/3*cos(VM_Erad.V-4*PI/3) );\"\n    )\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM0  N1:=N_19,\" \" N2:=GND  ;\")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       Iq0  N1:=GND, N2:=N_20\"\n    \"  ( QUANT:=AMa0.I, FACT:=2/3*sin(VM_Erad.V) ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Iq1  N1:=GND, N2:=N_20\"\n        \"  ( QUANT:=AMb0.I, FACT:=2/3*sin(VM_Erad.V-2*PI/3) ); \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  II       Iq2  N1:=GND, N2:=N_20\"\n        \"  ( QUANT:=AMc0.I, FACT:=2/3*sin(VM_Erad.V-4*PI/3) ); \"\n    )\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM       AM1  N1:=N_20,\" \" N2:=GND  ; \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I00  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMa0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I01  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMb0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  II       I02  N1:=GND,\" \" N2:=N_21  ( QUANT:=AMc0.I, FACT:=1/3 ); \"\n)\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN  \" \"AM       AMo  N1:=N_21, N2:=GND  ; \")\n\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  \" \"VM       VM_Speed  N1:=N_23, N2:=N_22  ; \")\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"UMODEL  D2D      \"\n        'D2D1 N1:=N_23, N2:=ROT1 ( NATURE_1:=\"electrical\",'\n        ' NATURE_2:=\"Rotational_V\" ) SRC: DLL( File:=\"Domains.dll\");'\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"UMODEL  D2D      \"\n        'D2D2 N1:=N_22, N2:=ROT2 ( NATURE_1:=\"electrical\",'\n        ' NATURE_2:=\"Rotational_V\" ) SRC: DLL( File:=\"Domains.dll\");'\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  IV       \"\n    \"Gx  N1:=GND,\"\n    \" N2:=N_24  ( QUANT:=VM_Speed.V, FACT:=57.29578 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  C\" \"        \" \"Cx  N1:=N_24, N2:=GND  ( C:=1, V0:=IniPos ); \")\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  VM\" \"\" \"       VM_Mdeg  N1:=N_24, N2:=GND  ; \")\nfile_id.write(\n    \"%6s\\r\\n\" % \"INTERN  IV\" \"\" \"       Ipos  N1:=GND, N2:=N_25  ( QUANT:=VM_Mdeg.V, FACT:=1 ); \"\n)\nfile_id.write(\"%6s\\r\\n\" % \"INTERN  AM\" \"\" \"       AM2  N1:=N_25, N2:=N_26  ; \")\nfile_id.write(\n    \"%6s %8.7f %s\\r\\n\"\n    % (\"INTERN  R\" \"        Rpos  N1:=N_26, N2:=GND  ( R:=\", 0.0174533 * p, \" ); \")\n)\nfile_id.write(\"%6s\\r\\n\\n\" % \"INTERN  VM\" \"\" \"       VM_Erad  N1:=N_26, N2:=GND  ;\")\n\nfile_id.write(\n    \"%6s\\r\\n\"\n    % (\n        \"INTERN  NDSRC    PECER_Model1  N0:=GND,\"\n        \" N1:=N_16, N2:=GND, N3:=N_17,\"\n        \" N4:=GND, N5:=N_18, N6:=N_22, N7:=N_23 \\ \"\n    )\n)\nfile_id.write(\n    \"%6s\\r\\n\" % \" ( QUANT:={ AM0.I, AM1.I, AM2.I },\"\n    ' SRC:={ isrc, isrc, isrc, isrc }, TableData:=\"\\ '\n)\nfile_id.write(\"%6s\" % \".MODEL ECER_Model1_table pwl TABLE=(\")\nfile_id.write(\"%s%u%s\" % (\" \", d_values, \",\"))\n\nindex = 0\n\nfor i in range(d_values):\n    file_id.write(\"%s%d\" % (\" \", id_peak[i, 0]))\n    file_id.write(\"%s\" % \",\")\n    if i == (d_values - 1):\n        file_id.write(\"%s\\n\" % \"\\ \")\n        file_id.write(\"%s\" % \" 0,\")\n\nfor r in range(d_values):\n    file_id.write(\"%s%u%s\" % (\" \", q_values, \",\"))\n    for i in range(q_values):\n        file_id.write(\"%s%d\" % (\" \", iq_peak[0, i]))\n        file_id.write(\"%s\" % \",\")\n        if i == (q_values - 1):\n            file_id.write(\"%s\\n\" % \"\\ \")\n            file_id.write(\"%s\" % \" 0,\")\n\n    for k in range(q_values):\n        file_id.write(\"%s%u%s\" % (\" \", map_points, \",\"))\n        for i in range(map_points):\n            file_id.write(\"%s%6.3f\" % (\" \", i * mec_deg))\n            file_id.write(\"%s\" % (\",\"))\n            if i == (map_points - 1):\n                file_id.write(\"%s\\n\" % \"\\ \")\n                file_id.write(\"%s\" % \" 4,\")\n\n        for j in range(1, 5):\n            for i in range(map_points):\n                file_id.write(\"%s%f\" % (\" \", final_table[int(j), int(index + i)]))\n                file_id.write(\"%s\" % (\",\"))\n                if r == (d_values - 1) and k == (q_values - 1) and j == 4 and i == (map_points - 1):\n                    file_id.write(\"%s\\r\\n\" % \") LINEAR LINEAR PERIODIC\\ \")\n                    file_id.write(\"%s\\r\\n\" % ' DEEPSPLINE\" );')\n                    file_id.write(\"%s\\r\\n\" % \"}\")\n                elif i == (map_points - 1):\n                    file_id.write(\"%s\\n\" % \"\\ \")\n        index = index + map_points\n\nfile_id.close()"
    },
    {
        "objectID": "examples/links/ece_export_for_twinbuilder",
        "href": "examples/links/ece_export_for_twinbuilder.html#exit-motor-cad",
        "title": "Motor-CAD EMag Twin Builder ECE > Exit Motor-CAD",
        "section": "Exit Motor-CAD",
        "text": "Exit Motor-CAD.\nTotal running time of the script: (9 minutes 16.291 seconds)\nDownload Jupyter notebook: ece_export_for_twinbuilder.ipynb\nDownload Python source code: ece_export_for_twinbuilder.py\nDownload zipped: ece_export_for_twinbuilder.zip\nGallery generated by Sphinx-Gallery\nmcad.quit()"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_to_file",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_to_file.html#save_to_file",
        "title": "save_to_file",
        "section": "save_to_file",
        "text": "Save the MOT file.\nFull path to file, including file name. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.unite",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite one or more other regions with self.\nMotor-CAD region object/list of objects"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeExists",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeExists.html#getnodeexists",
        "title": "GetNodeExists",
        "section": "GetNodeExists",
        "text": "Deprecated function. Replaced by MotorCAD.get_node_exists()."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_magnet_parameters",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_magnet_parameters.html#calculate_magnet_parameters",
        "title": "calculate_magnet_parameters",
        "section": "calculate_magnet_parameters",
        "text": "Calculate parameters for the nonlinear demagnetization model.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetComponentMaterial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetComponentMaterial.html#getcomponentmaterial",
        "title": "GetComponentMaterial",
        "section": "GetComponentMaterial",
        "text": "Deprecated function. Replaced by MotorCAD.get_component_material()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.set_free",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.set_free.html#set_free",
        "title": "set_free",
        "section": "set_free",
        "text": "Deprecated function. Replaced by MotorCAD.set_free()."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_variable",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_variable.html#get_variable",
        "title": "get_variable",
        "section": "get_variable",
        "text": "Get a Motor-CAD variable.\nName of the variable.\nValue of the Motor-CAD variable."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Region by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateIMSaturationModel",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateIMSaturationModel.html#calculateimsaturationmodel",
        "title": "CalculateIMSaturationModel",
        "section": "CalculateIMSaturationModel",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_im_saturation_model()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetWindingCoil",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetWindingCoil.html#getwindingcoil",
        "title": "GetWindingCoil",
        "section": "GetWindingCoil",
        "text": "Deprecated function. Replaced by MotorCAD.get_winding_coil()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateForceHarmonics_Temporal",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateForceHarmonics_Temporal.html#calculateforceharmonics_temporal",
        "title": "CalculateForceHarmonics_Temporal",
        "section": "CalculateForceHarmonics_Temporal",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_force_harmonics_temporal()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.create_new_node",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.create_new_node.html#create_new_node",
        "title": "create_new_node",
        "section": "create_new_node",
        "text": "Create a node."
    },
    {
        "objectID": "user_guide/Motor-CAD_setup",
        "href": "user_guide/Motor-CAD_setup.html#motor-cad-setup",
        "title": "Motor-CAD setup",
        "section": "Motor-CAD setup",
        "text": "This section covers PyMotor-CAD options which are accessed from the Motor-CAD UI.\nBefore you can run any scripts to interact with Motor-CAD, you must first verify the current version of Motor-CAD is\nregistered for automation.\nTo do this, select Defaults -> Automation to open the registration window and click Update to current version.\nIf the current version is already registered, this is greyed out as in the image below. Click OK.\nPyMotorCAD creates and runs from a new instance of Motor-CAD unless otherwise specified in the creation of the\nMotor-CAD object. If the Motor-CAD object is set to not open a new instance, then it connects with any open\nMotor-CAD window regardless of version number and without preference for any particular one.\nScripting in Motor-CAD usually involves setting parameters (for example: geometry, operating point definition, cooling,\ncalculation options), running calculations, and then retrieving results (for example: torque, efficiency, losses).\nTo do this, the correct Motor-CAD parameter name must be known.\nA list of all Motor-CAD parameters available via automation can be found under Help -> automation Parameter Names.\nThe list can be filtered to find the required parameter. Typically, the automation parameter names are the same as\nthe displayed name in the Motor-CAD interface, with spaces replaced by underscores for example: for Pole Number the\nautomation name is Pole_Number.\nFor most parameters, the automation name can also be found by hovering the mouse over the input control or the parameter\nrow in the output data sheet. The status bar shows a description of the parameter, followed by its automation name\nin curly brackets.\nFor example, here the mouse is hovered over the magnetization radio group in the calculation tab,\nshowing that the parameter name is Magnetization.\nYou can also press F2 with the control in focus and the automation parameter list is shown with\nthe correct parameter name automatically entered in the search box.\nCtrl + F2 copies the automation name of the control which is currently selected.\nIf a parameter cannot be found in this way, an alternative method is to set the parameter to a distinctive value\nthrough the user interface, for example: 1234. You can then find the parameter by filtering the Automation Parameters\nlist by this value.\nIf Motor-CAD is launched by an external script then by default the GUI is not shown. This improves the speed of startup\nand decrease the memory usage while scripting. If the GUI is required during scripting, for example for troubleshooting\nor to script UI commands (for example: taking screenshots from Motor-CAD), this option can be enabled.\nThis setting applies to all instances of this Motor-CAD version.\nRegardless of this option, during a script the Motor-CAD GUI can be shown or hidden at any time using the\ncommand set_visible().\nSome scripting commands require the GUI to be shown, for example display_screen(), save_screen_to_file()\nWhen changing model parameters via automation with the GUI visible, Motor-CAD does not update the user interface\nwith the new parameter value at every step, to speed up the scripting. However, this means that you should\nnever change a parameter which is shown on the currently displayed tab. It is best practice to run all scripts with\nthe Scripting tab visible. This should be set before changing any parameters with the command\nThis needS to be called after loading any files or setting context, before any calls to set_variable().\nIn Motor-CAD, the units can be changed under Defaults -> Units, this displays values in the interface in the\nselected units.\nHowever, variables are not be converted for use in automation and so values are always given in the Motor-CAD default\nunits. This applies both when setting input variables and retrieving output results. To see what these default values\nare, navigate to Help -> Automation Parameter Names (or press F2) where the parameters are displayed with their\ndefault units.\nAs an example, go the thermal context and navigate to Input Data -> Cooling\nChange the default temperature units in the interface to Fahrenheit:\nSearch for T_ambient in the Automation Parameters list and change the value to 100:\nIt can be seen that the current value is given in the units specified in the automation parameters list and not the\ndefault units selected in the GUI. The displayed interface value is in ℉ and the set value in the list is in ℃.\nmcApp.display_screen(\"scripting\")"
    },
    {
        "objectID": "user_guide/Motor-CAD_setup",
        "href": "user_guide/Motor-CAD_setup.html#registering-motor-cad-for-automation",
        "title": "Motor-CAD setup > Registering Motor-CAD for automation",
        "section": "Registering Motor-CAD for automation",
        "text": "Before you can run any scripts to interact with Motor-CAD, you must first verify the current version of Motor-CAD is\nregistered for automation.\nTo do this, select Defaults -> Automation to open the registration window and click Update to current version.\nIf the current version is already registered, this is greyed out as in the image below. Click OK.\nPyMotorCAD creates and runs from a new instance of Motor-CAD unless otherwise specified in the creation of the\nMotor-CAD object. If the Motor-CAD object is set to not open a new instance, then it connects with any open\nMotor-CAD window regardless of version number and without preference for any particular one."
    },
    {
        "objectID": "user_guide/Motor-CAD_setup",
        "href": "user_guide/Motor-CAD_setup.html#automation-parameter-names",
        "title": "Motor-CAD setup > Automation parameter names",
        "section": "Automation parameter names",
        "text": "Scripting in Motor-CAD usually involves setting parameters (for example: geometry, operating point definition, cooling,\ncalculation options), running calculations, and then retrieving results (for example: torque, efficiency, losses).\nTo do this, the correct Motor-CAD parameter name must be known.\nA list of all Motor-CAD parameters available via automation can be found under Help -> automation Parameter Names.\nThe list can be filtered to find the required parameter. Typically, the automation parameter names are the same as\nthe displayed name in the Motor-CAD interface, with spaces replaced by underscores for example: for Pole Number the\nautomation name is Pole_Number.\nFor most parameters, the automation name can also be found by hovering the mouse over the input control or the parameter\nrow in the output data sheet. The status bar shows a description of the parameter, followed by its automation name\nin curly brackets.\nFor example, here the mouse is hovered over the magnetization radio group in the calculation tab,\nshowing that the parameter name is Magnetization.\nYou can also press F2 with the control in focus and the automation parameter list is shown with\nthe correct parameter name automatically entered in the search box.\nCtrl + F2 copies the automation name of the control which is currently selected.\nIf a parameter cannot be found in this way, an alternative method is to set the parameter to a distinctive value\nthrough the user interface, for example: 1234. You can then find the parameter by filtering the Automation Parameters\nlist by this value."
    },
    {
        "objectID": "user_guide/Motor-CAD_setup",
        "href": "user_guide/Motor-CAD_setup.html#gui-in-automation",
        "title": "Motor-CAD setup > GUI in automation",
        "section": "GUI in automation",
        "text": "If Motor-CAD is launched by an external script then by default the GUI is not shown. This improves the speed of startup\nand decrease the memory usage while scripting. If the GUI is required during scripting, for example for troubleshooting\nor to script UI commands (for example: taking screenshots from Motor-CAD), this option can be enabled.\nThis setting applies to all instances of this Motor-CAD version.\nRegardless of this option, during a script the Motor-CAD GUI can be shown or hidden at any time using the\ncommand set_visible().\nSome scripting commands require the GUI to be shown, for example display_screen(), save_screen_to_file()\nWhen changing model parameters via automation with the GUI visible, Motor-CAD does not update the user interface\nwith the new parameter value at every step, to speed up the scripting. However, this means that you should\nnever change a parameter which is shown on the currently displayed tab. It is best practice to run all scripts with\nthe Scripting tab visible. This should be set before changing any parameters with the command\nThis needS to be called after loading any files or setting context, before any calls to set_variable().\nmcApp.display_screen(\"scripting\")"
    },
    {
        "objectID": "user_guide/Motor-CAD_setup",
        "href": "user_guide/Motor-CAD_setup.html#units",
        "title": "Motor-CAD setup > Units",
        "section": "Units",
        "text": "In Motor-CAD, the units can be changed under Defaults -> Units, this displays values in the interface in the\nselected units.\nHowever, variables are not be converted for use in automation and so values are always given in the Motor-CAD default\nunits. This applies both when setting input variables and retrieving output results. To see what these default values\nare, navigate to Help -> Automation Parameter Names (or press F2) where the parameters are displayed with their\ndefault units.\nAs an example, go the thermal context and navigate to Input Data -> Cooling\nChange the default temperature units in the interface to Fahrenheit:\nSearch for T_ambient in the Automation Parameters list and change the value to 100:\nIt can be seen that the current value is given in the units specified in the automation parameters list and not the\ndefault units selected in the GUI. The displayed interface value is in ℉ and the set value in the list is in ℃."
    },
    {
        "objectID": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.xy_to_rt",
        "href": "methods/_autosummary_geometry_functions/ansys.motorcad.core.geometry.xy_to_rt.html#xy_to_rt",
        "title": "xy_to_rt",
        "section": "xy_to_rt",
        "text": "Convert Motor-CAD Cartesian coordinates to polar coordinates in degrees.\nX coordinate value.\nY coordinate value.\nRadial coordinate value.\nAngular coordinate value."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.InitialiseTabNames",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.InitialiseTabNames.html#initialisetabnames",
        "title": "InitialiseTabNames",
        "section": "InitialiseTabNames",
        "text": "Deprecated function. Replaced by MotorCAD.initialise_tab_names()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_capacitance_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_capacitance_value.html#set_capacitance_value",
        "title": "set_capacitance_value",
        "section": "set_capacitance_value",
        "text": "Set or create a capacitance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMagneticGraphPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMagneticGraphPoint.html#getmagneticgraphpoint",
        "title": "GetMagneticGraphPoint",
        "section": "GetMagneticGraphPoint",
        "text": "Deprecated function. Replaced by MotorCAD.get_magnetic_graph_point()."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_variable",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_variable.html#set_variable",
        "title": "set_variable",
        "section": "set_variable",
        "text": "Set a Motor-CAD variable.\nName of the variable.\nValue to set the variable to."
    },
    {
        "objectID": "methods/_autogen_Variables",
        "href": "methods/_autogen_Variables.html#variables",
        "title": "Variables",
        "section": "Variables",
        "text": "get_array_variable(array_name, array_index)\nGet a Motor-CAD array variable.\nget_array_variable_2d(array_name, ...)\nGet a value from a 2D array at element [array_index1,array_index2].\nget_file_name()\nGet current .mot file name and path.\nget_variable(variable_name)\nGet a Motor-CAD variable.\nrestore_compatibility_settings()\nRestore model compatibility settings to default values to use the latest methods.\nset_array_variable(array_name, array_index, ...)\nSet a Motor-CAD array variable.\nset_array_variable_2d(array_name, ...)\nSet the value of a 2D array at element [array_index1,array_index2].\nset_variable(variable_name, variable_value)\nSet a Motor-CAD variable."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_figure_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_figure_lab.html#export_figure_lab",
        "title": "export_figure_lab",
        "section": "export_figure_lab",
        "text": "Export an image of the Lab results graph.\nType of calculation. Options are \"Electromagnetic\", \"Thermal\",\n\"Generator\", \"Duty Cycle\", and \"Calibration\".\nVariable to plot on the Y axis (2D graphs) or Z axis (3D graphs). For\nexample, \"Shaft Torque\".\nName of the image file."
    },
    {
        "objectID": "examples/advanced/index",
        "href": "examples/advanced/index.html#advanced-examples",
        "title": "Advanced examples",
        "section": "Advanced examples",
        "text": "These examples show you how to use the basic functionality of PyMotorCAD.\nsphx_glr_examples_advanced_force_extraction.py"
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_duty_cycle_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_duty_cycle_lab.html#export_duty_cycle_lab",
        "title": "export_duty_cycle_lab",
        "section": "export_duty_cycle_lab",
        "text": "Export the calculated duty cycle data to the thermal model."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_region.html#get_region",
        "title": "get_region",
        "section": "get_region",
        "text": "Get Motor-CAD geometry region.\nname of region.\nMotor-CAD region object."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#motor-cad-e-magnetic-example-script",
        "title": "Motor-CAD E-magnetic example script",
        "section": "Motor-CAD E-magnetic example script",
        "text": "This example provides a Motor-CAD E-magnetic script. This script\ncreates a partial custom winding pattern to change\nparameter values, run the analysis, and plot results. To create\na full winding pattern, parameters must be specified\nfor all coils.\nSetting up this example consists of performing imports, specifying the\nworking directory, launching Motor-CAD, and disabling all popup\nmessages from Motor-CAD.\nCreating the analysis consists of showing the magnetic context, displaying\nthe Scripting tab, setting the geometry and parameters, and saving\nthe file.\nShow the magnetic context.\nDisplay the Scripting tab.\nSet the geometry.\nSet parameters for creating the custom winding pattern.\nThe following code creates only a partial winding pattern.\nSet the winding type to custom:\nmcad.set_variable('MagWindingType', 1)\nSet the path type to upper and lower:\nmcad.set_variable('MagPathType', 1)\nSet the number of phases:\nmcad.set_variable('MagPhases', 3)\nSet the number of parallel paths:\nmcad.set_variable('ParallelPaths', 1)\nSet the number of winding layers:\nmcad.set_variable('WindingLayers', 2)\nDefine a coil’s parameters:\nset_winding_coil(phase,\npath, coil, go_slot, go_position, return_slot, return_position, turns)\nSet the stator/rotor lamination materials.\nSet the torque calculation options.\nDisable all performance tests except the ones for transient torque.\nEnable transient torque.\nSet the operating point.\nSave the file.\nRun the simulation.\nExport results to a CSV file.\nGet torque and voltage data.\nGraph the torque data.\nGraph the airgap flux density data.\nKeep looking until you cannot find the point.\nGraph the harmonic data.\nPlot results from the simulation.\nExit Motor-CAD.\nIf you want to continue working with this instance of Motor-CAD, rather\nthan using the preceding command, use this command:\nmcad.set_variable('MessageDisplayState', 0)\nTotal running time of the script: (1 minutes 6.501 seconds)\nDownload Jupyter notebook: emag_basics.ipynb\nDownload Python source code: emag_basics.py\nDownload zipped: emag_basics.zip\nGallery generated by Sphinx-Gallery\nimport os\n\nimport matplotlib.pyplot as plt\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nworking_folder = os.getcwd()\n\nif os.path.isdir(working_folder) is False:\n    print(\"Working folder does not exist. Choose a folder that exists and try again.\")\n    print(working_folder)\n    exit()\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nprint(\"Initialization completed.\")\nprint(\"Running simulation.\")\nInitialization completed.\nRunning simulation.\nmcad.show_magnetic_context()\nmcad.display_screen(\"Scripting\")\nmcad.set_variable(\"Slot_Number\", 24)\nmcad.set_variable(\"Tooth_Width\", 6)\nmcad.set_variable(\"Magnet_Thickness\", 4.5)\nmcad.set_component_material(\"Stator Lam (Back Iron)\", \"M250-35A\")\nmcad.set_component_material(\"Rotor Lam (Back Iron)\", \"M250-35A\")\npoints_per_cycle = 30\nnumber_cycles = 1\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"TorqueNumberCycles\", number_cycles)\nmcad.set_variable(\"BackEMFCalculation\", False)\nmcad.set_variable(\"CoggingTorqueCalculation\", False)\nmcad.set_variable(\"ElectromagneticForcesCalc_OC\", False)\nmcad.set_variable(\"TorqueSpeedCalculation\", False)\nmcad.set_variable(\"DemagnetizationCalc\", False)\nmcad.set_variable(\"ElectromagneticForcesCalc_Load\", False)\nmcad.set_variable(\"InductanceCalc\", False)\nmcad.set_variable(\"BPMShortCircuitCalc\", False)\nmcad.set_variable(\"TorqueCalculation\", True)\nmcad.set_variable(\"Shaft_Speed_[RPM]\", 1000)\nmcad.set_variable(\"CurrentDefinition\", 0)\nmcad.set_variable(\"PeakCurrent\", 3)\nmcad.set_variable(\"DCBusVoltage\", 350)\nmcad.set_variable(\"PhaseAdvance\", 45)\nfilename = os.path.join(working_folder, \"../ActiveX_Scripting_EMagnetic.mot\")\nmcad.save_to_file(filename)\nmcad.do_magnetic_calculation()\nexportFile = os.path.join(working_folder, \"../Export_EMag_Results.csv\")\ntry:\n    mcad.export_results(\"EMagnetic\", exportFile)\n    print(\"Results successfully exported.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Results failed to export.\")\nResults successfully exported.\nshaft_torque = mcad.get_variable(\"ShaftTorque\")\nline_voltage = mcad.get_variable(\"PeakLineLineVoltage\")\nnum_torque_points = points_per_cycle * number_cycles\nrotor_position = []\ntorque_vw = []\n\nfor n in range(num_torque_points):\n    (x, y) = mcad.get_magnetic_graph_point(\"TorqueVW\", n)\n    rotor_position.append(x)\n    torque_vw.append(y)\nloop = 0\nsuccess = 0\nmech_angle = []\nairgap_flux_density = []\nwhile success == 0:\n    try:\n        (x, y) = mcad.get_fea_graph_point(\"B Gap (on load)\", 1, loop, 0)\n        mech_angle.append(x)\n        airgap_flux_density.append(y)\n        loop = loop + 1\n    except pymotorcad.MotorCADError:\n        success = 1\nmcad.initialise_tab_names()\nmcad.display_screen(\"Graphs;Harmonics;Torque\")\n\nnum_harmonic_points = (points_per_cycle * number_cycles) + 1\ndata_point = []\ntorque = []\nfor n in range(num_harmonic_points):\n    try:\n        (x, y) = mcad.get_magnetic_graph_point(\"HarmonicDataCycle\", n)\n        data_point.append(x)\n        torque.append(y)\n    except pymotorcad.MotorCADError:\n        print(\"Results failed to export.\")\n\n\nprint(\"Simulation completed.\")\nSimulation completed.\nplt.subplot(211)\nplt.plot(mech_angle, airgap_flux_density)\nplt.xlabel(\"Mech Angle\")\nplt.ylabel(\"Airgap Flux Density\")\nplt.subplot(212)\nplt.plot(rotor_position, torque_vw)\nplt.xlabel(\"Rotor Position\")\nplt.ylabel(\"TorqueVW\")\nplt.figure(2)\nplt.plot(data_point, torque)\nplt.xlabel(\"DataPoint\")\nplt.ylabel(\"Torque (Nm)\")\nplt.show()\nmcad.quit()"
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#set-up-example",
        "title": "Motor-CAD E-magnetic example script > Set up example",
        "section": "Set up example",
        "text": "Setting up this example consists of performing imports, specifying the\nworking directory, launching Motor-CAD, and disabling all popup\nmessages from Motor-CAD.\nimport os\n\nimport matplotlib.pyplot as plt\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\"\nworking_folder = os.getcwd()\n\nif os.path.isdir(working_folder) is False:\n    print(\"Working folder does not exist. Choose a folder that exists and try again.\")\n    print(working_folder)\n    exit()\nprint(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization.\nmcad.set_variable(\"MessageDisplayState\", 2)\nprint(\"Initialization completed.\")\nprint(\"Running simulation.\")\nInitialization completed.\nRunning simulation."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#perform-required-imports",
        "title": "Motor-CAD E-magnetic example script > Perform required imports",
        "section": "Perform required imports",
        "text": "import os\n\nimport matplotlib.pyplot as plt\n\nimport ansys.motorcad.core as pymotorcad\n\nif \"QT_API\" in os.environ:\n    os.environ[\"QT_API\"] = \"pyqt\""
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#specify-working-directory",
        "title": "Motor-CAD E-magnetic example script > Specify working directory",
        "section": "Specify working directory",
        "text": "working_folder = os.getcwd()\n\nif os.path.isdir(working_folder) is False:\n    print(\"Working folder does not exist. Choose a folder that exists and try again.\")\n    print(working_folder)\n    exit()"
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#launch-motor-cad",
        "title": "Motor-CAD E-magnetic example script > Launch Motor-CAD",
        "section": "Launch Motor-CAD",
        "text": "print(\"Starting initialization.\")\nmcad = pymotorcad.MotorCAD()\nStarting initialization."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#disable-popup-messages",
        "title": "Motor-CAD E-magnetic example script > Disable popup messages",
        "section": "Disable popup messages",
        "text": "mcad.set_variable(\"MessageDisplayState\", 2)\nprint(\"Initialization completed.\")\nprint(\"Running simulation.\")\nInitialization completed.\nRunning simulation."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#create-analysis",
        "title": "Motor-CAD E-magnetic example script > Create analysis",
        "section": "Create analysis",
        "text": "Creating the analysis consists of showing the magnetic context, displaying\nthe Scripting tab, setting the geometry and parameters, and saving\nthe file.\nShow the magnetic context.\nDisplay the Scripting tab.\nSet the geometry.\nSet parameters for creating the custom winding pattern.\nThe following code creates only a partial winding pattern.\nSet the winding type to custom:\nmcad.set_variable('MagWindingType', 1)\nSet the path type to upper and lower:\nmcad.set_variable('MagPathType', 1)\nSet the number of phases:\nmcad.set_variable('MagPhases', 3)\nSet the number of parallel paths:\nmcad.set_variable('ParallelPaths', 1)\nSet the number of winding layers:\nmcad.set_variable('WindingLayers', 2)\nDefine a coil’s parameters:\nset_winding_coil(phase,\npath, coil, go_slot, go_position, return_slot, return_position, turns)\nSet the stator/rotor lamination materials.\nSet the torque calculation options.\nDisable all performance tests except the ones for transient torque.\nEnable transient torque.\nSet the operating point.\nSave the file.\nmcad.show_magnetic_context()\nmcad.display_screen(\"Scripting\")\nmcad.set_variable(\"Slot_Number\", 24)\nmcad.set_variable(\"Tooth_Width\", 6)\nmcad.set_variable(\"Magnet_Thickness\", 4.5)\nmcad.set_component_material(\"Stator Lam (Back Iron)\", \"M250-35A\")\nmcad.set_component_material(\"Rotor Lam (Back Iron)\", \"M250-35A\")\npoints_per_cycle = 30\nnumber_cycles = 1\nmcad.set_variable(\"TorquePointsPerCycle\", points_per_cycle)\nmcad.set_variable(\"TorqueNumberCycles\", number_cycles)\nmcad.set_variable(\"BackEMFCalculation\", False)\nmcad.set_variable(\"CoggingTorqueCalculation\", False)\nmcad.set_variable(\"ElectromagneticForcesCalc_OC\", False)\nmcad.set_variable(\"TorqueSpeedCalculation\", False)\nmcad.set_variable(\"DemagnetizationCalc\", False)\nmcad.set_variable(\"ElectromagneticForcesCalc_Load\", False)\nmcad.set_variable(\"InductanceCalc\", False)\nmcad.set_variable(\"BPMShortCircuitCalc\", False)\nmcad.set_variable(\"TorqueCalculation\", True)\nmcad.set_variable(\"Shaft_Speed_[RPM]\", 1000)\nmcad.set_variable(\"CurrentDefinition\", 0)\nmcad.set_variable(\"PeakCurrent\", 3)\nmcad.set_variable(\"DCBusVoltage\", 350)\nmcad.set_variable(\"PhaseAdvance\", 45)\nfilename = os.path.join(working_folder, \"../ActiveX_Scripting_EMagnetic.mot\")\nmcad.save_to_file(filename)"
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#run-simulation",
        "title": "Motor-CAD E-magnetic example script > Run simulation",
        "section": "Run simulation",
        "text": "Run the simulation.\nmcad.do_magnetic_calculation()"
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#export-results-to-csv-file",
        "title": "Motor-CAD E-magnetic example script > Export results to CSV file",
        "section": "Export results to CSV file",
        "text": "Export results to a CSV file.\nexportFile = os.path.join(working_folder, \"../Export_EMag_Results.csv\")\ntry:\n    mcad.export_results(\"EMagnetic\", exportFile)\n    print(\"Results successfully exported.\")\nexcept pymotorcad.MotorCADError:\n    print(\"Results failed to export.\")\nResults successfully exported."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#get-and-analyze-results",
        "title": "Motor-CAD E-magnetic example script > Get and analyze results",
        "section": "Get and analyze results",
        "text": "Get torque and voltage data.\nGraph the torque data.\nGraph the airgap flux density data.\nKeep looking until you cannot find the point.\nGraph the harmonic data.\nshaft_torque = mcad.get_variable(\"ShaftTorque\")\nline_voltage = mcad.get_variable(\"PeakLineLineVoltage\")\nnum_torque_points = points_per_cycle * number_cycles\nrotor_position = []\ntorque_vw = []\n\nfor n in range(num_torque_points):\n    (x, y) = mcad.get_magnetic_graph_point(\"TorqueVW\", n)\n    rotor_position.append(x)\n    torque_vw.append(y)\nloop = 0\nsuccess = 0\nmech_angle = []\nairgap_flux_density = []\nwhile success == 0:\n    try:\n        (x, y) = mcad.get_fea_graph_point(\"B Gap (on load)\", 1, loop, 0)\n        mech_angle.append(x)\n        airgap_flux_density.append(y)\n        loop = loop + 1\n    except pymotorcad.MotorCADError:\n        success = 1\nmcad.initialise_tab_names()\nmcad.display_screen(\"Graphs;Harmonics;Torque\")\n\nnum_harmonic_points = (points_per_cycle * number_cycles) + 1\ndata_point = []\ntorque = []\nfor n in range(num_harmonic_points):\n    try:\n        (x, y) = mcad.get_magnetic_graph_point(\"HarmonicDataCycle\", n)\n        data_point.append(x)\n        torque.append(y)\n    except pymotorcad.MotorCADError:\n        print(\"Results failed to export.\")\n\n\nprint(\"Simulation completed.\")\nSimulation completed."
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#plot-results",
        "title": "Motor-CAD E-magnetic example script > Plot results",
        "section": "Plot results",
        "text": "Plot results from the simulation.\nplt.subplot(211)\nplt.plot(mech_angle, airgap_flux_density)\nplt.xlabel(\"Mech Angle\")\nplt.ylabel(\"Airgap Flux Density\")\nplt.subplot(212)\nplt.plot(rotor_position, torque_vw)\nplt.xlabel(\"Rotor Position\")\nplt.ylabel(\"TorqueVW\")\nplt.figure(2)\nplt.plot(data_point, torque)\nplt.xlabel(\"DataPoint\")\nplt.ylabel(\"Torque (Nm)\")\nplt.show()"
    },
    {
        "objectID": "examples/basics/emag_basics",
        "href": "examples/basics/emag_basics.html#exit-motor-cad",
        "title": "Motor-CAD E-magnetic example script > Exit Motor-CAD",
        "section": "Exit Motor-CAD",
        "text": "Exit Motor-CAD.\nIf you want to continue working with this instance of Motor-CAD, rather\nthan using the preceding command, use this command:\nmcad.set_variable('MessageDisplayState', 0)\nTotal running time of the script: (1 minutes 6.501 seconds)\nDownload Jupyter notebook: emag_basics.ipynb\nDownload Python source code: emag_basics.py\nDownload zipped: emag_basics.zip\nGallery generated by Sphinx-Gallery\nmcad.quit()"
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.load_external_model_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.load_external_model_lab.html#load_external_model_lab",
        "title": "load_external_model_lab",
        "section": "load_external_model_lab",
        "text": "Load an external model data file.\nThis parameter is used when the Lab link type is set to Custom or Ansys Maxwell.\nFull path to the data file, including the file name. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DeleteSolidMaterial",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DeleteSolidMaterial.html#deletesolidmaterial",
        "title": "DeleteSolidMaterial",
        "section": "DeleteSolidMaterial",
        "text": "Deprecated function. Replaced by MotorCAD.delete_solid_material()."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.load_adaptive_script",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.load_adaptive_script.html#load_adaptive_script",
        "title": "load_adaptive_script",
        "section": "load_adaptive_script",
        "text": "Load adaptive templates script file to Motor-CAD.\nfull file path of script"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Quit",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Quit.html#quit",
        "title": "Quit",
        "section": "Quit",
        "text": "Deprecated function. Replaced by MotorCAD.quit()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadTemplate",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadTemplate.html#loadtemplate",
        "title": "LoadTemplate",
        "section": "LoadTemplate",
        "text": "Deprecated function. Replaced by MotorCAD.load_template()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.append",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.append.html#append",
        "title": "append",
        "section": "append",
        "text": "Append object to the end of the list."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_3d_component_visibility",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_3d_component_visibility.html#set_3d_component_visibility",
        "title": "set_3d_component_visibility",
        "section": "set_3d_component_visibility",
        "text": "Set the visibility of a component by group name and component name.\nName of the group. Options are \"Machine\", \"Stator\", \"Rotor\",\nand \"Shaft Components\". If the component is in the thermal context,\n\"Mounting\" and \"Outer Casing\" are also options.\nName of the component. The component names that are available depend\non which model is used. Options include \"All\", \"Lamination\",\nand \"Wedge\".\nVisibility level. Values range from 0 (invisible) to 100 (solid)."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportResults",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportResults.html#exportresults",
        "title": "ExportResults",
        "section": "ExportResults",
        "text": "Deprecated function. Replaced by MotorCAD.export_results()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_message_log",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_message_log.html#clear_message_log",
        "title": "clear_message_log",
        "section": "clear_message_log",
        "text": "Clear the message log file for the model."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.extend",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.extend.html#extend",
        "title": "extend",
        "section": "extend",
        "text": "Extend list by appending elements from the iterable."
    },
    {
        "objectID": "methods/MotorCADCompatibility_object",
        "href": "methods/MotorCADCompatibility_object.html#motorcadcompatibility-api",
        "title": "MotorCADCompatibility API",
        "section": "MotorCADCompatibility API",
        "text": "MotorCADCompatibility([port, ...])\nCreate a MotorCAD object that behaves the same as old ActiveX methods."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_boundary_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_boundary_rt.html#add_arc_boundary_rt",
        "title": "add_arc_boundary_rt",
        "section": "add_arc_boundary_rt",
        "text": "Add a boundary condition arc using r, t coordinates for the center.\nDeprecated since version 0.6.0: add_arc_boundary_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "examples/links/index",
        "href": "examples/links/index.html#linking-examples",
        "title": "Linking examples",
        "section": "Linking examples",
        "text": "These examples show how you can link PyMotorCAD to other Ansys products.\nsphx_glr_examples_links_ece_export_for_twinbuilder.py"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.motorcad_instance",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.motorcad_instance.html#motorcad_instance",
        "title": "motorcad_instance",
        "section": "motorcad_instance",
        "text": "Get linked Motor-CAD instance."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_motorlab_context",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.set_motorlab_context.html#set_motorlab_context",
        "title": "set_motorlab_context",
        "section": "set_motorlab_context",
        "text": "Change Motor-CAD to the lab context."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.mirror",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.mirror.html#mirror",
        "title": "mirror",
        "section": "mirror",
        "text": "Mirror region along entity.\nLine entity to mirror region about\nWhether to apply a unique name to returned region"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearExternalCircuit",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearExternalCircuit.html#clearexternalcircuit",
        "title": "ClearExternalCircuit",
        "section": "ClearExternalCircuit",
        "text": "Deprecated function. Replaced by MotorCAD.clear_external_circuit()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Add_Region_Thermal",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Add_Region_Thermal.html#add_region_thermal",
        "title": "Add_Region_Thermal",
        "section": "Add_Region_Thermal",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.do_slot_finite_element",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.do_slot_finite_element.html#do_slot_finite_element",
        "title": "do_slot_finite_element",
        "section": "do_slot_finite_element",
        "text": "Run slot FEA."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_magnetic_thermal_calculation",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_magnetic_thermal_calculation.html#do_magnetic_thermal_calculation",
        "title": "do_magnetic_thermal_calculation",
        "section": "do_magnetic_thermal_calculation",
        "text": "Run coupled e-magnetic and thermal calculations."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearFixedTemperatureValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearFixedTemperatureValue.html#clearfixedtemperaturevalue",
        "title": "ClearFixedTemperatureValue",
        "section": "ClearFixedTemperatureValue",
        "text": "Deprecated function. Replaced by MotorCAD.clear_fixed_temperature_value()."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.load_external_circuit",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.load_external_circuit.html#load_external_circuit",
        "title": "load_external_circuit",
        "section": "load_external_circuit",
        "text": "Load an external circuit from a file."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowThermalContext",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowThermalContext.html#showthermalcontext",
        "title": "ShowThermalContext",
        "section": "ShowThermalContext",
        "text": "Deprecated function. Replaced by MotorCAD.show_thermal_context()."
    },
    {
        "objectID": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.square",
        "href": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.square.html#square",
        "title": "square",
        "section": "square",
        "text": "Create a square of given width at a given set of coordinates.\nWidth value.\nRadial coordinate of the square centre.\nAngular coordinate of the square centre.\nRegion type with four Line entity types."
    },
    {
        "objectID": "examples/internal_scripting/mechanical_force",
        "href": "examples/internal_scripting/mechanical_force.html#mechanical-force",
        "title": "Mechanical force",
        "section": "Mechanical force",
        "text": "This example demonstrates internal scripting mechanical force functionality\nThis will compute the operating conditions for some requested torque values\nand display the natural frequencies for the 0th and 8th modes.\nPerform required imports\nLaunch Motor-CAD\nCreate internal script.\nThis could also be saved in a separate file\nFor further details, please see the E-NVH tutorial.\n(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (1 minutes 50.533 seconds)\nDownload Jupyter notebook: mechanical_force.ipynb\nDownload Python source code: mechanical_force.py\nDownload zipped: mechanical_force.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\nmc = pymotorcad.MotorCAD()\nimport numpy as np\n\n\n# This function is called when \"Run\" is pressed\ndef main():\n    pass\n\n\nclass mechanical_forces:\n    def initial(self):\n        # %%\n        # Disable pop-up messages\n        mc.set_variable(\"MessageDisplayState\", 2)\n\n        # Called before calculation\n        # For each operating point, set requested torque and speed\n        # (using this mode requires that a Lab model has been built)\n        # Note that if a lab model isn't available, MultiForceLoadPointDefinition\n        # can be set to 1 (Current and Phase), and\n        # LoadPoint_Current_Array and LoadPoint_PhaseAdvance_Array set\n        # IM operating points are set with speed, current, and LoadPoint_Slip_Array\n        NVH_Duty_Speed = np.concatenate((250, 6000, 9000), axis=None)\n        NVH_Duty_Torque = np.concatenate((40, 20, 10), axis=None)\n        mc.set_variable(\"NumLoadPoints\", len(NVH_Duty_Speed))\n        for i in range(len(NVH_Duty_Speed)):\n            mc.set_array_variable(\"LoadPoint_Speed_Array\", i, float(NVH_Duty_Speed[i]))\n            mc.set_array_variable(\"LoadPoint_Torque_Array\", i, float(NVH_Duty_Torque[i]))\n\n        # Set number of steps per cycle - for speed just use 30 in this example. 90 would be\n        # a more usual minimum\n        # If calculating for an induction machine (IM), use IMSingleLoadPointsPerCycle instead\n        mc.set_variable(\"TorquePointsPerCycle\", 30)\n\n    def final(self):\n        # Called after calculation\n        # Example modal results\n        o_Natural_Freq_Mode_0 = mc.get_magnetic_graph_point(\"NVH_NaturalFrequency\", 0)\n        o_Natural_Freq_Mode_8 = mc.get_magnetic_graph_point(\"NVH_NaturalFrequency\", 8)\n\n        mc.show_message(\" Natural_Freq_Mode_0 \" + str(o_Natural_Freq_Mode_0))\n        mc.show_message(\" Natural_Freq_Mode_8 \" + str(o_Natural_Freq_Mode_8))\n\n        mc.set_variable(\"MessageDisplayState\", 0)\ntry:\n    from setup_scripts.setup_script import run_mech_force_demo\nexcept ImportError:\n    pass\nelse:\n    run_mech_force_demo(mc)\n9:17:59 AM :  Natural_Freq_Mode_0 (0, 6658.47007165279)\n9:17:59 AM :  Natural_Freq_Mode_8 (8, 8858.68125781642)"
    },
    {
        "objectID": "examples/internal_scripting/mechanical_force",
        "href": "examples/internal_scripting/mechanical_force.html#note",
        "title": "Mechanical force > Note",
        "section": "Note",
        "text": "For further details, please see the E-NVH tutorial."
    },
    {
        "objectID": "examples/internal_scripting/mechanical_force",
        "href": "examples/internal_scripting/mechanical_force.html#pymotorcad-documentation-example",
        "title": "Mechanical force > PyMotorCAD Documentation Example",
        "section": "PyMotorCAD Documentation Example",
        "text": "(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (1 minutes 50.533 seconds)\nDownload Jupyter notebook: mechanical_force.ipynb\nDownload Python source code: mechanical_force.py\nDownload zipped: mechanical_force.zip\nGallery generated by Sphinx-Gallery\ntry:\n    from setup_scripts.setup_script import run_mech_force_demo\nexcept ImportError:\n    pass\nelse:\n    run_mech_force_demo(mc)\n9:17:59 AM :  Natural_Freq_Mode_0 (0, 6658.47007165279)\n9:17:59 AM :  Natural_Freq_Mode_8 (8, 8858.68125781642)"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveIronLossCoefficients",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveIronLossCoefficients.html#saveironlosscoefficients",
        "title": "SaveIronLossCoefficients",
        "section": "SaveIronLossCoefficients",
        "text": "Deprecated function. Replaced by MotorCAD.save_iron_loss_coefficients()."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#api-reference",
        "title": "API reference",
        "section": "API reference",
        "text": "The MotorCAD object is used by default for PyMotorCAD scripting.\nFor descriptions of this object’s single class and its many methods,\nsee ref_MotorCAD_object.\nThe MotorCADCompatibility object is used for running old ActiveX\nscripts. For information on backwards compatibility, see\nref_backwards_compatibility. For descriptions of this\nobject, its single class, and its many methods, see\nref_MotorCADCompatibility_object.\nIn addition to giving the available methods, their replacement functions\nhave been commented.\nThe ansys.motorcad.core.geometry library contains geometry objects and functions\nthat provide geometry capability in Python.\nGeometry objects and functions are used for\ndefining and modifying Adaptive Templates geometries in Python.\nFor descriptions of the objects and functions, see ref_geometry_functions.\nThe ansys.motorcad.core.geometry_drawing library contains functions for drawing\ngeometry objects as static visualisations in Python. Geometry drawing is used for plotting\nobjects such as regions, lines, arcs and coordinates within the x-y plane. Drawing Motor-CAD\ngeometry objects can make it easier to test and create Adaptive Templates scripts.\nFor descriptions of the geometry drawing functions, see ref_geometry_drawing.\nThe ansys.motorcad.core.geometry_shapes library contains geometry functions\nthat provide geometry calculations in Python.\nGeometry shapes functions are used for\ndefining and modifying Adaptive Templates geometries in Python.\nFor descriptions of the functions, see ref_geometry_shapes."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#motor-cad-api",
        "title": "API reference > Motor-CAD API",
        "section": "Motor-CAD API",
        "text": "The MotorCAD object is used by default for PyMotorCAD scripting.\nFor descriptions of this object’s single class and its many methods,\nsee ref_MotorCAD_object."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#motor-cad-compatibility-api",
        "title": "API reference > Motor-CAD compatibility API",
        "section": "Motor-CAD compatibility API",
        "text": "The MotorCADCompatibility object is used for running old ActiveX\nscripts. For information on backwards compatibility, see\nref_backwards_compatibility. For descriptions of this\nobject, its single class, and its many methods, see\nref_MotorCADCompatibility_object.\nIn addition to giving the available methods, their replacement functions\nhave been commented."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#geometry-objects-and-functions",
        "title": "API reference > Geometry objects and functions",
        "section": "Geometry objects and functions",
        "text": "The ansys.motorcad.core.geometry library contains geometry objects and functions\nthat provide geometry capability in Python.\nGeometry objects and functions are used for\ndefining and modifying Adaptive Templates geometries in Python.\nFor descriptions of the objects and functions, see ref_geometry_functions."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#geometry-drawing",
        "title": "API reference > Geometry drawing",
        "section": "Geometry drawing",
        "text": "The ansys.motorcad.core.geometry_drawing library contains functions for drawing\ngeometry objects as static visualisations in Python. Geometry drawing is used for plotting\nobjects such as regions, lines, arcs and coordinates within the x-y plane. Drawing Motor-CAD\ngeometry objects can make it easier to test and create Adaptive Templates scripts.\nFor descriptions of the geometry drawing functions, see ref_geometry_drawing."
    },
    {
        "objectID": "methods/index",
        "href": "methods/index.html#geometry-shapes",
        "title": "API reference > Geometry shapes",
        "section": "Geometry shapes",
        "text": "The ansys.motorcad.core.geometry_shapes library contains geometry functions\nthat provide geometry calculations in Python.\nGeometry shapes functions are used for\ndefining and modifying Adaptive Templates geometries in Python.\nFor descriptions of the functions, see ref_geometry_shapes."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeCapacitance",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeCapacitance.html#getnodecapacitance",
        "title": "GetNodeCapacitance",
        "section": "GetNodeCapacitance",
        "text": "Deprecated function. Replaced by MotorCAD.get_node_capacitance()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearAllData",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ClearAllData.html#clearalldata",
        "title": "ClearAllData",
        "section": "ClearAllData",
        "text": "Deprecated function. Replaced by MotorCAD.clear_all_data()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTransientTemperatures",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveTransientTemperatures.html#savetransienttemperatures",
        "title": "SaveTransientTemperatures",
        "section": "SaveTransientTemperatures",
        "text": "Deprecated function. Replaced by MotorCAD.save_transient_temperatures()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.insert_polyline",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.insert_polyline.html#insert_polyline",
        "title": "insert_polyline",
        "section": "insert_polyline",
        "text": "Insert polyline at given index, polyline can be made up of line/arc entities.\nIndex of which to insert at\nlist of Line or list of Arc"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMagneticContext",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowMagneticContext.html#showmagneticcontext",
        "title": "ShowMagneticContext",
        "section": "ShowMagneticContext",
        "text": "Deprecated function. Replaced by MotorCAD.show_magnetic_context()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetWindingCoil",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetWindingCoil.html#setwindingcoil",
        "title": "SetWindingCoil",
        "section": "SetWindingCoil",
        "text": "Deprecated function. Replaced by MotorCAD.set_winding_coil()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_to_ansys_discovery",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_to_ansys_discovery.html#export_to_ansys_discovery",
        "title": "export_to_ansys_discovery",
        "section": "export_to_ansys_discovery",
        "text": "Export the model to a Python script file that can be run in Ansys Discovery.\nAbsolute filepath for the Python script file. The default\nfilepath is the Windows directory on the C: drive. The\nfilepath must include the name of the file. The extension\ndoes not need to be specified. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_messages",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_messages.html#get_messages",
        "title": "get_messages",
        "section": "get_messages",
        "text": "Get a list of the last N messages from the message history.\nNumber of last messages to get. If is parameter is set to\n0, all messages in the history are returned.\nList of messages."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.add_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.add_entity.html#add_entity",
        "title": "add_entity",
        "section": "add_entity",
        "text": "Add entity to list of region entities.\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.create_winding_pattern",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.create_winding_pattern.html#create_winding_pattern",
        "title": "create_winding_pattern",
        "section": "create_winding_pattern",
        "text": "Create winding pattern.\nRefreshes the UI to recreate winding pattern. Will be replaced by direct API call soon."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_region_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_region_rt.html#add_region_rt",
        "title": "add_region_rt",
        "section": "add_region_rt",
        "text": "Add a region to the Motor-CAD geometry with an r, t (polar) coordinate system.\nIf a region already exists, this method overwrites the existing region.\nUse degrees for angles.\nRegion position for the radial coordinate.\nRegion position for the angular coordinate in degrees.\nName of the region.\nadd_region_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMagnetisationCurves",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMagnetisationCurves.html#savemagnetisationcurves",
        "title": "SaveMagnetisationCurves",
        "section": "SaveMagnetisationCurves",
        "text": "Deprecated function. Replaced by MotorCAD.save_magnetisation_curves()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateMagnetParameters",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateMagnetParameters.html#calculatemagnetparameters",
        "title": "CalculateMagnetParameters",
        "section": "CalculateMagnetParameters",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_magnet_parameters()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_multi_force_data",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_multi_force_data.html#export_multi_force_data",
        "title": "export_multi_force_data",
        "section": "export_multi_force_data",
        "text": "Export calculated multiforce data to a file.\nName of the file. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_solid_material",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_solid_material.html#delete_solid_material",
        "title": "delete_solid_material",
        "section": "delete_solid_material",
        "text": "Delete the solid material from the materials database.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateOperatingPoint_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateOperatingPoint_Lab.html#calculateoperatingpoint_lab",
        "title": "CalculateOperatingPoint_Lab",
        "section": "CalculateOperatingPoint_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_operating_point_lab()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.reverse",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.reverse.html#reverse",
        "title": "reverse",
        "section": "reverse",
        "text": "Reverse Entity class."
    },
    {
        "objectID": "examples/advanced/sg_execution_times",
        "href": "examples/advanced/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "02:42.315 total execution time for 1 file from examplesadvanced:\nExample\nTime\nMem (MB)\nsphx_glr_examples_advanced_force_extraction.py (force_extraction.py)\n02:42.315\n0.0"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateDutyCycle_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateDutyCycle_Lab.html#calculatedutycycle_lab",
        "title": "CalculateDutyCycle_Lab",
        "section": "CalculateDutyCycle_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_duty_cycle_lab()."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_array_variable_2d",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_array_variable_2d.html#get_array_variable_2d",
        "title": "get_array_variable_2d",
        "section": "get_array_variable_2d",
        "text": "Get a value from a 2D array at element [array_index1,array_index2].\nName of the array.\nFirst index of the array.\nSecond index of the array.\nValue of the Motor-CAD variable."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.from_coordinate_list",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.from_coordinate_list.html#from_coordinate_list",
        "title": "from_coordinate_list",
        "section": "from_coordinate_list",
        "text": "Work in progress. Need to split up geometry first to avoid circular imports.\nUse geometry_fitting.return_entity_list for now"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AvoidImmediateUpdate",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AvoidImmediateUpdate.html#avoidimmediateupdate",
        "title": "AvoidImmediateUpdate",
        "section": "AvoidImmediateUpdate",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetFEAPathPoint.html#setfeapathpoint",
        "title": "SetFEAPathPoint",
        "section": "SetFEAPathPoint",
        "text": "Deprecated function. Replaced by MotorCAD.set_fea_path_point()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.is_closed",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.is_closed.html#is_closed",
        "title": "is_closed",
        "section": "is_closed",
        "text": "Check whether region entities create a closed region.\nWhether region is closed"
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_magnetic_context",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_magnetic_context.html#show_magnetic_context",
        "title": "show_magnetic_context",
        "section": "show_magnetic_context",
        "text": "Show the magnetic context in Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_lab_model",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.export_lab_model.html#export_lab_model",
        "title": "export_lab_model",
        "section": "export_lab_model",
        "text": "Export lab model.\nFile path including lab model file name and file extension (.lab)"
    },
    {
        "objectID": "user_guide/matlab_scripting",
        "href": "user_guide/matlab_scripting.html#pymotorcad-scripting-in-matlab",
        "title": "PyMotorCAD scripting in MATLAB",
        "section": "PyMotorCAD scripting in MATLAB",
        "text": "PyMotorCAD is available to use in MATLAB in the same way as other Python modules.\nIf the ansys.motorcad.core package is installed for a version of Python,\nthis version of Python can be used in MATLAB and the PyMotorCAD API can be called.\nThis means that MATLAB scripts can make use of PyMotorCAD for controlling Motor-CAD and automation.\nPython modules can be called in MATLAB as long as Python is installed on the system.\nPlease refer to the Mathworks website for detailed information on configuring your system to use Python\nand accessing Python Modules from MATLAB.\nBy default, MATLAB selects the version of Python based on the system path.\nTo view the system path in MATLAB, use the getenv('path') command.\nTo see which version of Python MATLAB is using, call the pyenv function in MATLAB.\nFor example, if version Python version 3.10 is installed and added to path, MATLAB outputs:\nIf the Python version that MATLAB is using has the ansys.motorcad.core package installed, PyMotorCAD is available to use in MATLAB.\nSee ref_getting_started for details on installing ansys.motorcad.core.\nTo import the ansys.motorcad.core module as pymotorcad for use in scripts, use:\nThen ref_MotorCAD_object commands can be used in MATLAB in the same way as in Python.\nTo start and connect to a Motor-CAD instance, access the MotorCAD() object:\nAn example of a MATLAB script using PyMotorCAD to change the motor geometry and materials,\nrun magnetic calculations and extract results for further analysis is presented.\nThis example is also included in the Automation tutorial supplied with Motor-CAD.\npe = pyenv;\npe.Version\nans =\n\n\"3.10\"\npymotorcad = py.importlib.import_module('ansys.motorcad.core');\nmcApp = pymotorcad.MotorCAD();\n% Use pymotorcad as an alias to access functionality in ansys.motorcad.core\npymotorcad = py.importlib.import_module('ansys.motorcad.core');\n\n% Launch an instance of Motor-CAD\nmcApp = pymotorcad.MotorCAD();\n\n% Turn off popups\nmcApp.set_variable('MessageDisplayState', 2)\n% Change tab to scripting so that there are no conflicts when changing\n% variables\nmcApp.show_magnetic_context()\nmcApp.display_screen('scripting')\n% change to default BPM motor\nmcApp.set_variable('Motor_Type', 0)\n% Geometry changes\nmcApp.set_variable('Slot_Number', 24)\nmcApp.set_variable('Tooth_Width', 6)\nmcApp.set_variable('Magnet_Thickness', 4.5)\n% Coil changes\nmcApp.set_variable('MagPhases',3);\nmcApp.set_variable('ParallelPaths',1);\nmcApp.set_variable('WindingLayers',2);\nmcApp.set_variable('MagWindingType',1);\nmcApp.set_variable('MagPathType',1);\nmcApp.set_winding_coil(int64(2), int64(1), int64(3), int64(4), 'b', int64(18), 'a', int64(60));\n% Material changes\nmcApp.set_component_material('Stator Lam (Back Iron)', 'M250-35A')\nmcApp.set_component_material('Rotor Lam (Back Iron)', 'M250-35A')\n% Set calculation preferences\nPointsPerCycle = 30;\nNumberCycles = 1;\nmcApp.set_variable('TorquePointsPerCycle', PointsPerCycle);\nmcApp.set_variable('TorqueNumberCycles', NumberCycles);\n% Turn off performance tests\nmcApp.set_variable('BackEMFCalculation', false);\nmcApp.set_variable('CoggingTorqueCalculation', false);\nmcApp.set_variable('ElectromagneticForcesCalc_OC', false);\nmcApp.set_variable('TorqueSpeedCalculation', false);\nmcApp.set_variable('DemagnetizationCalc', false);\nmcApp.set_variable('ElectromagneticForcesCalc_Load', false);\nmcApp.set_variable('InductanceCalc', false);\nmcApp.set_variable('BPMShortCircuitCalc', false);\n% Enable transient torque\nmcApp.set_variable('TorqueCalculation', true);\n% Emangetic calculation settings\nmcApp.set_variable('Shaft_Speed_[RPM]', 1000);\nmcApp.set_variable('CurrentDefinition', 0);\nmcApp.set_variable('PeakCurrent', 3);\nmcApp.set_variable('DCBusVoltage', 350);\nmcApp.set_variable('PhaseAdvance', 45);\n\n% Save file and calculate\nmcApp.save_to_file('C:\\ANSYS_Motor-CAD\\2023_1_1\\Motor-CAD Data\\MATLAB_Tutorial\\automation_scripting_MATLAB_EMagnetic.mot');\nmcApp.do_magnetic_calculation()\n\n% data retrieval and export\nmcApp.export_results('EMagnetic','C:\\ANSYS_Motor-CAD\\2023_1_1\\Motor-CAD Data\\MATLAB_Tutorial\\automation_scripting_MATLAB_EMagnetic\\Export EMag Results.csv');\n\nShaftTorque = mcApp.get_variable('ShaftTorque');\nLineVoltage = mcApp.get_variable('PeakLineLineVoltage');\n\nNumTorquePoints = (PointsPerCycle * NumberCycles) + 1;\n\nfor loop = 0:NumTorquePoints-1\n    params = mcApp.get_magnetic_graph_point('TorqueVW', int64(loop));\n    params = double(params);\n    x = params(1);\n    y = params(2);\n    RotorPosition(loop+1) = x;\n    TorqueVW(loop+1) = y;\nend\n\n\nloop = 0;\nsuccess = 0;\nwhile true\n    try\n        params = mcApp.get_fea_graph_point('B Gap (on load)', int64(1), int64(loop), int64(0));\n        params = double(params);\n        x = params(1);\n        y = params(2);\n        MechAngle(loop+1) = x;\n        AirgapFluxDensity(loop+1) = y;\n        loop = loop + 1;\n    catch\n        break\n    end\nend\n\nmcApp.initialise_tab_names();\nmcApp.display_screen('Graphs;Harmonics;Torque');\n\nNumHarmonicPoints = (PointsPerCycle * NumberCycles)+1 ;\nfor loop = 0:NumHarmonicPoints - 1\n    params = mcApp.get_magnetic_graph_point('HarmonicDataCycle',int64(loop));\n    params = double(params);\n    x = params(1);\n    y = params(2);\n    Datapoint(loop+1) = x;\n    Torque(loop+1) = y;\nend\n\nmcApp.quit();"
    },
    {
        "objectID": "user_guide/matlab_scripting",
        "href": "user_guide/matlab_scripting.html#using-python-modules-in-matlab",
        "title": "PyMotorCAD scripting in MATLAB > Using Python modules in MATLAB",
        "section": "Using Python modules in MATLAB",
        "text": "Python modules can be called in MATLAB as long as Python is installed on the system.\nPlease refer to the Mathworks website for detailed information on configuring your system to use Python\nand accessing Python Modules from MATLAB.\nBy default, MATLAB selects the version of Python based on the system path.\nTo view the system path in MATLAB, use the getenv('path') command.\nTo see which version of Python MATLAB is using, call the pyenv function in MATLAB.\nFor example, if version Python version 3.10 is installed and added to path, MATLAB outputs:\npe = pyenv;\npe.Version\nans =\n\n\"3.10\""
    },
    {
        "objectID": "user_guide/matlab_scripting",
        "href": "user_guide/matlab_scripting.html#using-pymotorcad-in-matlab",
        "title": "PyMotorCAD scripting in MATLAB > Using PyMotorCAD in MATLAB",
        "section": "Using PyMotorCAD in MATLAB",
        "text": "If the Python version that MATLAB is using has the ansys.motorcad.core package installed, PyMotorCAD is available to use in MATLAB.\nSee ref_getting_started for details on installing ansys.motorcad.core.\nTo import the ansys.motorcad.core module as pymotorcad for use in scripts, use:\nThen ref_MotorCAD_object commands can be used in MATLAB in the same way as in Python.\nTo start and connect to a Motor-CAD instance, access the MotorCAD() object:\npymotorcad = py.importlib.import_module('ansys.motorcad.core');\nmcApp = pymotorcad.MotorCAD();"
    },
    {
        "objectID": "user_guide/matlab_scripting",
        "href": "user_guide/matlab_scripting.html#example-motor-cad-e-magnetic-scripting-in-matlab",
        "title": "PyMotorCAD scripting in MATLAB > Example: Motor-CAD E-magnetic scripting in MATLAB",
        "section": "Example: Motor-CAD E-magnetic scripting in MATLAB",
        "text": "An example of a MATLAB script using PyMotorCAD to change the motor geometry and materials,\nrun magnetic calculations and extract results for further analysis is presented.\nThis example is also included in the Automation tutorial supplied with Motor-CAD.\n% Use pymotorcad as an alias to access functionality in ansys.motorcad.core\npymotorcad = py.importlib.import_module('ansys.motorcad.core');\n\n% Launch an instance of Motor-CAD\nmcApp = pymotorcad.MotorCAD();\n\n% Turn off popups\nmcApp.set_variable('MessageDisplayState', 2)\n% Change tab to scripting so that there are no conflicts when changing\n% variables\nmcApp.show_magnetic_context()\nmcApp.display_screen('scripting')\n% change to default BPM motor\nmcApp.set_variable('Motor_Type', 0)\n% Geometry changes\nmcApp.set_variable('Slot_Number', 24)\nmcApp.set_variable('Tooth_Width', 6)\nmcApp.set_variable('Magnet_Thickness', 4.5)\n% Coil changes\nmcApp.set_variable('MagPhases',3);\nmcApp.set_variable('ParallelPaths',1);\nmcApp.set_variable('WindingLayers',2);\nmcApp.set_variable('MagWindingType',1);\nmcApp.set_variable('MagPathType',1);\nmcApp.set_winding_coil(int64(2), int64(1), int64(3), int64(4), 'b', int64(18), 'a', int64(60));\n% Material changes\nmcApp.set_component_material('Stator Lam (Back Iron)', 'M250-35A')\nmcApp.set_component_material('Rotor Lam (Back Iron)', 'M250-35A')\n% Set calculation preferences\nPointsPerCycle = 30;\nNumberCycles = 1;\nmcApp.set_variable('TorquePointsPerCycle', PointsPerCycle);\nmcApp.set_variable('TorqueNumberCycles', NumberCycles);\n% Turn off performance tests\nmcApp.set_variable('BackEMFCalculation', false);\nmcApp.set_variable('CoggingTorqueCalculation', false);\nmcApp.set_variable('ElectromagneticForcesCalc_OC', false);\nmcApp.set_variable('TorqueSpeedCalculation', false);\nmcApp.set_variable('DemagnetizationCalc', false);\nmcApp.set_variable('ElectromagneticForcesCalc_Load', false);\nmcApp.set_variable('InductanceCalc', false);\nmcApp.set_variable('BPMShortCircuitCalc', false);\n% Enable transient torque\nmcApp.set_variable('TorqueCalculation', true);\n% Emangetic calculation settings\nmcApp.set_variable('Shaft_Speed_[RPM]', 1000);\nmcApp.set_variable('CurrentDefinition', 0);\nmcApp.set_variable('PeakCurrent', 3);\nmcApp.set_variable('DCBusVoltage', 350);\nmcApp.set_variable('PhaseAdvance', 45);\n\n% Save file and calculate\nmcApp.save_to_file('C:\\ANSYS_Motor-CAD\\2023_1_1\\Motor-CAD Data\\MATLAB_Tutorial\\automation_scripting_MATLAB_EMagnetic.mot');\nmcApp.do_magnetic_calculation()\n\n% data retrieval and export\nmcApp.export_results('EMagnetic','C:\\ANSYS_Motor-CAD\\2023_1_1\\Motor-CAD Data\\MATLAB_Tutorial\\automation_scripting_MATLAB_EMagnetic\\Export EMag Results.csv');\n\nShaftTorque = mcApp.get_variable('ShaftTorque');\nLineVoltage = mcApp.get_variable('PeakLineLineVoltage');\n\nNumTorquePoints = (PointsPerCycle * NumberCycles) + 1;\n\nfor loop = 0:NumTorquePoints-1\n    params = mcApp.get_magnetic_graph_point('TorqueVW', int64(loop));\n    params = double(params);\n    x = params(1);\n    y = params(2);\n    RotorPosition(loop+1) = x;\n    TorqueVW(loop+1) = y;\nend\n\n\nloop = 0;\nsuccess = 0;\nwhile true\n    try\n        params = mcApp.get_fea_graph_point('B Gap (on load)', int64(1), int64(loop), int64(0));\n        params = double(params);\n        x = params(1);\n        y = params(2);\n        MechAngle(loop+1) = x;\n        AirgapFluxDensity(loop+1) = y;\n        loop = loop + 1;\n    catch\n        break\n    end\nend\n\nmcApp.initialise_tab_names();\nmcApp.display_screen('Graphs;Harmonics;Torque');\n\nNumHarmonicPoints = (PointsPerCycle * NumberCycles)+1 ;\nfor loop = 0:NumHarmonicPoints - 1\n    params = mcApp.get_magnetic_graph_point('HarmonicDataCycle',int64(loop));\n    params = double(params);\n    x = params(1);\n    y = params(2);\n    Datapoint(loop+1) = x;\n    Torque(loop+1) = y;\nend\n\nmcApp.quit();"
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.edit_magnet_region",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.edit_magnet_region.html#edit_magnet_region",
        "title": "edit_magnet_region",
        "section": "edit_magnet_region",
        "text": "Edit a magnet region.\nName of the magnet region.\nMagnet material.\nBr angle of the magnet.\nBr multiplier for the magnet.\nedit_magnet_region will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_regions",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.delete_regions.html#delete_regions",
        "title": "delete_regions",
        "section": "delete_regions",
        "text": "Delete a comma-separated list of named regions or all regions.\nList of names for the regions to delete. If the list is empty,\nall regions are deleted. If the name of a region to delete contains\na space, enclose the name in double quotation marks. For example,\n\"Rotor Pocket\".\ndelete_regions will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoWeightCalculation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoWeightCalculation.html#doweightcalculation",
        "title": "DoWeightCalculation",
        "section": "DoWeightCalculation",
        "text": "Deprecated function. Replaced by MotorCAD.do_weight_calculation()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportToAnsysDiscovery",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportToAnsysDiscovery.html#exporttoansysdiscovery",
        "title": "ExportToAnsysDiscovery",
        "section": "ExportToAnsysDiscovery",
        "text": "Deprecated function. Replaced by MotorCAD.export_to_ansys_discovery()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Region by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_results",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_results.html#export_results",
        "title": "export_results",
        "section": "export_results",
        "text": "Export results from a solution to a CSV file.\nType of the solution. Options are 'EMagnetic' (E-Magnetic Solution),\n'Lab' (Lab Operating Point Solution), 'SteadyState' (Steady State\nThermal Solution), and 'Transient' (Transient Thermal Solution).\nAbsolute path for the CSV file. The default is the Windows\ndirectory on the C: drive. The file path must include the name\nof the file, with a CSV extension. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_saturation_map",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_saturation_map.html#calculate_saturation_map",
        "title": "calculate_saturation_map",
        "section": "calculate_saturation_map",
        "text": "Generate electromagnetic saturation and loss data.\nSaturation (flux linkages and inductances) and loss data can be used\nin other analysis and modeling tools. The default MAT file is saved in\nthe lab folder in the .mot directory."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetForceFrequencyDomainAmplitude",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetForceFrequencyDomainAmplitude.html#getforcefrequencydomainamplitude",
        "title": "GetForceFrequencyDomainAmplitude",
        "section": "GetForceFrequencyDomainAmplitude",
        "text": "Deprecated function. Replaced by MotorCAD.get_force_frequency_domain_amplitude()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadExternalModel_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadExternalModel_Lab.html#loadexternalmodel_lab",
        "title": "LoadExternalModel_Lab",
        "section": "LoadExternalModel_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.load_external_model_lab()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ResetRegions",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ResetRegions.html#resetregions",
        "title": "ResetRegions",
        "section": "ResetRegions",
        "text": "Deprecated function. Replaced by MotorCAD.reset_regions()."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_point_custom_material_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_point_custom_material_rt.html#add_point_custom_material_rt",
        "title": "add_point_custom_material_rt",
        "section": "add_point_custom_material_rt",
        "text": "Add a region to the geometry and specify the material.\nDo not use this method to add a magnet. Use the add_magnet_region_rt method.\nUse degrees for angles.\nRegion position for the radial coordinate.\nRegion position for the angular coordinate in degrees.\nName of the region.\nNName of the material. In Motor-CAD, material names can be found in\nInput Data -> materials. The material type (laminated, solid,\nor air) is set automatically.\nVCL color. For more information, see https://wiki.freepascal.org/Colors.\nThe color can be designaed as a hexadecimal value, such as \"$008000\"\nor a color name such as \"clGreen\".\nadd_point_custom_material_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_resistance_value",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_resistance_value.html#set_resistance_value",
        "title": "set_resistance_value",
        "section": "set_resistance_value",
        "text": "Set or create a resistance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetPowerSourceValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetPowerSourceValue.html#setpowersourcevalue",
        "title": "SetPowerSourceValue",
        "section": "SetPowerSourceValue",
        "text": "Deprecated function. Replaced by MotorCAD.set_power_source_value()."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.add_external_custom_loss",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.add_external_custom_loss.html#add_external_custom_loss",
        "title": "add_external_custom_loss",
        "section": "add_external_custom_loss",
        "text": "Add an external custom loss.\nName of lab external custom loss\nPower function for lab external custom loss\nFunction for voltage drop for lab external custom loss"
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_array_variable_2d",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.set_array_variable_2d.html#set_array_variable_2d",
        "title": "set_array_variable_2d",
        "section": "set_array_variable_2d",
        "text": "Set the value of a 2D array at element [array_index1,array_index2].\nName of the array.\nFirst index of the array.\nSecond index of the array.\nValue to set the Motor-CAD variable to."
    },
    {
        "objectID": "examples/adaptive_library/index",
        "href": "examples/adaptive_library/index.html#adaptive-templates-examples",
        "title": "Adaptive templates examples",
        "section": "Adaptive templates examples",
        "text": "Library of adaptive templates examples for setting up custom geometries in Motor-CAD.\nThese scripts can be loaded into the Motor-CAD Adaptive Templates tab.\nAdaptive Templates in Motor-CAD require v2024.1.2 (Motor-CAD 2024 R1 Update) or later.\nFor more information on the use of Adaptive Templates in Motor-CAD,\nand how to create, modify and debug Adaptive Templates Scripts,\nsee ref_adaptive_templates_UG in the ref_user_guide.\nsphx_glr_examples_adaptive_library_BPMTriangularRotorNotches.py\nsphx_glr_examples_adaptive_library_BezierCurveRotorPockets.py\nsphx_glr_examples_adaptive_library_DXFImport.py\nsphx_glr_examples_adaptive_library_OblongStatorDuct.py\nsphx_glr_examples_adaptive_library_TrapezoidalDuct.py\nsphx_glr_examples_adaptive_library_UShapeSYNCRELCurvedFluxBarriers.py"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.subtract",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract region from self, returning any additional regions.\nMotor-CAD region object\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_external_component",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_external_component.html#remove_external_component",
        "title": "remove_external_component",
        "section": "remove_external_component",
        "text": "Remove an external circuit component.\nType of the external circuit components. Options are \"Resistance\",\n\"Power Source\", and \"Power Injection\").\nNumber of the thermal node."
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#motor-cad-internal-scripting-tab",
        "title": "Motor-CAD internal Scripting tab",
        "section": "Motor-CAD internal Scripting tab",
        "text": "The Scripting tab in Motor-CAD facilitates creating, editing, loading, and\nsaving internal Python scripts within Motor-CAD.\nFrom the Scripting tab in Motor-CAD, you can connect from an internal script by\naccessing the MotorCAD() object with this code:\nWith the ref_MotorCAD_object, you can use PyMotorCAD methods to send commands\nto the current Motor-CAD instance. For example, you can set and get values before,\nduring, and after calculations. You can also create a script for Motor-CAD automation.\nIn the following image, the Scripting tab shows the demo script. You can use this\ndefault script as a starting point for scripting internally in Motor-CAD. However, you\ncan also add and run any Python script from this tab.\nThe demo script is shown by default on the Scripting tab in Moto-CAD to\nproviding examples of how you use PyMotorCAD methods and Motor-CAD automation\nparameters.\nFor more information, see the Motor-CAD Automation tutorial (section 2.iii),\nprovided with the Motor-CAD installation.\nImport pymotorcad to access Motor-CAD.\nConnect to Motor-CAD.\nThe main function is called when Run is pressed in the Motor-CAD GUI.\nYou can use the main function to test other functions before running a\ncalculation. For example, you can use it to run the thermal_steady() and\ninitial() functions. You can also use it to run calculations within another\ndefined function, such as the demo_func function.\nThe defined demo_func function sets the tooth_width function and\nruns thermal calculations.\nAll messages are set to display in a separate window using this PyMotorCAD method:\nmcApp.set_variable(\"MessageDisplayState\", 2)\nand overwrite data. Ensure that this is the desired behavior.\nThe demo_func function defines a range of values for the tooth_width\nfunction, runs a steady state thermal calculation, and gets the average winding\ntemperature for each. Results are shown in the message window.\nThe last line of the function resets the message window.\nThe previously described functions run only when the Run During Analysis option\nis selected from the Scripting -> Settings tab in Motor-CAD. (This option appears\nunder the Script Control heading.)\nIf the Run During Analysis option is selected, the script is imported.\nThis means that anything other than setting up the MotorCAD object should\nbe moved to a function or class to avoid unexpected behavior.\nFive classes are defined: thermal_steady, thermal_transient,\nemagnetic, mechanical_stress and mechanical_forces.\nEach of these classes contains the initial and final functions.\nThe thermal classes also contain the main function.\ninitial is called before the calculation.\nfinal is called after the calculation.\nmain is called before each time step in a calculation.\nThe thermal_steady class contains functions for steady-state\nthermal calculations:\nThe thermal_transient class contains functions for transient\nthermal calculations:\nThe emagnetic class contains functions for E-Magnetic calculations:\nThe mechanical_stress class contains functions for Mechanical stress calculations:\nThe mechanical_forces class contains functions for Mechanical force calculations:\nFor any scripts that are to be run before, during, or after a particular Motor-CAD\ncalculation, these functions can be added to the relevant functions.\nimport ansys.motorcad.core as pymotorcad\n\nmcApp = pymotorcad.MotorCAD()\nimport ansys.motorcad.core as pymotorcad\nmcApp = pymotorcad.MotorCAD()\ndef main():\n    user_func = thermal_steady()\n    user_func.initial()\n\n    demo_func()\ndef demo_func():\n    array_tooth_widths = [1, 1.5, 2.0]\n\n    mcApp.set_variable(\"MessageDisplayState\", 2)\n\n    for toothWidth in array_tooth_widths:\n        mcApp.show_message(\"Tooth width = \" + str(toothWidth))\n        mcApp.set_variable(\"Tooth_Width\", toothWidth)\n        mcApp.do_steady_state_analysis()\n        temperature = mcApp.get_variable(\n            \"T_[WINDING_AVERAGE]\",\n        )\n        mcApp.show_message(\"Winding temperature = \" + str(temperature))\n\n    mcApp.set_variable(\"MessageDisplayState\", 0)\nclass thermal_steady:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Steady State - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Steady State - Main\")\n\n    def final(self):\n        print(\"Thermal Steady State - Final\")\nclass thermal_transient:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Transient - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Transient State - Main\")\n\n    def final(self):\n        print(\"Thermal Transient - Final\")\nclass emagnetic:\n    def initial(self):\n        print(\"E-Magnetic - Initial\")\n\n    def final(self):\n        print(\"E-Magnetic - Final\")\nclass mechanical_stress:\n    def initial(self):\n        print(\"Mech Stress - Initial\")\n\n    def final(self):\n        print(\"Mech Stress - Final\")\nclass mechanical_forces:\n    def initial(self):\n        print(\"Mech Forces - Initial\")\n\n    def final(self):\n        print(\"Mech Forces - Final\")"
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#demo-script-example",
        "title": "Motor-CAD internal Scripting tab > Demo script example",
        "section": "Demo script example",
        "text": "The demo script is shown by default on the Scripting tab in Moto-CAD to\nproviding examples of how you use PyMotorCAD methods and Motor-CAD automation\nparameters.\nFor more information, see the Motor-CAD Automation tutorial (section 2.iii),\nprovided with the Motor-CAD installation.\nImport pymotorcad to access Motor-CAD.\nConnect to Motor-CAD.\nThe main function is called when Run is pressed in the Motor-CAD GUI.\nYou can use the main function to test other functions before running a\ncalculation. For example, you can use it to run the thermal_steady() and\ninitial() functions. You can also use it to run calculations within another\ndefined function, such as the demo_func function.\nThe defined demo_func function sets the tooth_width function and\nruns thermal calculations.\nAll messages are set to display in a separate window using this PyMotorCAD method:\nmcApp.set_variable(\"MessageDisplayState\", 2)\nand overwrite data. Ensure that this is the desired behavior.\nThe demo_func function defines a range of values for the tooth_width\nfunction, runs a steady state thermal calculation, and gets the average winding\ntemperature for each. Results are shown in the message window.\nThe last line of the function resets the message window.\nThe previously described functions run only when the Run During Analysis option\nis selected from the Scripting -> Settings tab in Motor-CAD. (This option appears\nunder the Script Control heading.)\nIf the Run During Analysis option is selected, the script is imported.\nThis means that anything other than setting up the MotorCAD object should\nbe moved to a function or class to avoid unexpected behavior.\nFive classes are defined: thermal_steady, thermal_transient,\nemagnetic, mechanical_stress and mechanical_forces.\nEach of these classes contains the initial and final functions.\nThe thermal classes also contain the main function.\ninitial is called before the calculation.\nfinal is called after the calculation.\nmain is called before each time step in a calculation.\nThe thermal_steady class contains functions for steady-state\nthermal calculations:\nThe thermal_transient class contains functions for transient\nthermal calculations:\nThe emagnetic class contains functions for E-Magnetic calculations:\nThe mechanical_stress class contains functions for Mechanical stress calculations:\nThe mechanical_forces class contains functions for Mechanical force calculations:\nFor any scripts that are to be run before, during, or after a particular Motor-CAD\ncalculation, these functions can be added to the relevant functions.\nimport ansys.motorcad.core as pymotorcad\nmcApp = pymotorcad.MotorCAD()\ndef main():\n    user_func = thermal_steady()\n    user_func.initial()\n\n    demo_func()\ndef demo_func():\n    array_tooth_widths = [1, 1.5, 2.0]\n\n    mcApp.set_variable(\"MessageDisplayState\", 2)\n\n    for toothWidth in array_tooth_widths:\n        mcApp.show_message(\"Tooth width = \" + str(toothWidth))\n        mcApp.set_variable(\"Tooth_Width\", toothWidth)\n        mcApp.do_steady_state_analysis()\n        temperature = mcApp.get_variable(\n            \"T_[WINDING_AVERAGE]\",\n        )\n        mcApp.show_message(\"Winding temperature = \" + str(temperature))\n\n    mcApp.set_variable(\"MessageDisplayState\", 0)\nclass thermal_steady:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Steady State - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Steady State - Main\")\n\n    def final(self):\n        print(\"Thermal Steady State - Final\")\nclass thermal_transient:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Transient - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Transient State - Main\")\n\n    def final(self):\n        print(\"Thermal Transient - Final\")\nclass emagnetic:\n    def initial(self):\n        print(\"E-Magnetic - Initial\")\n\n    def final(self):\n        print(\"E-Magnetic - Final\")\nclass mechanical_stress:\n    def initial(self):\n        print(\"Mech Stress - Initial\")\n\n    def final(self):\n        print(\"Mech Stress - Final\")\nclass mechanical_forces:\n    def initial(self):\n        print(\"Mech Forces - Initial\")\n\n    def final(self):\n        print(\"Mech Forces - Final\")"
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#setup",
        "title": "Motor-CAD internal Scripting tab > Setup",
        "section": "Setup",
        "text": "Import pymotorcad to access Motor-CAD.\nConnect to Motor-CAD.\nimport ansys.motorcad.core as pymotorcad\nmcApp = pymotorcad.MotorCAD()"
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#main-function",
        "title": "Motor-CAD internal Scripting tab > Main function",
        "section": "Main function",
        "text": "The main function is called when Run is pressed in the Motor-CAD GUI.\nYou can use the main function to test other functions before running a\ncalculation. For example, you can use it to run the thermal_steady() and\ninitial() functions. You can also use it to run calculations within another\ndefined function, such as the demo_func function.\ndef main():\n    user_func = thermal_steady()\n    user_func.initial()\n\n    demo_func()"
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#demo-function",
        "title": "Motor-CAD internal Scripting tab > Demo function",
        "section": "Demo function",
        "text": "The defined demo_func function sets the tooth_width function and\nruns thermal calculations.\nAll messages are set to display in a separate window using this PyMotorCAD method:\nmcApp.set_variable(\"MessageDisplayState\", 2)\nand overwrite data. Ensure that this is the desired behavior.\nThe demo_func function defines a range of values for the tooth_width\nfunction, runs a steady state thermal calculation, and gets the average winding\ntemperature for each. Results are shown in the message window.\nThe last line of the function resets the message window.\ndef demo_func():\n    array_tooth_widths = [1, 1.5, 2.0]\n\n    mcApp.set_variable(\"MessageDisplayState\", 2)\n\n    for toothWidth in array_tooth_widths:\n        mcApp.show_message(\"Tooth width = \" + str(toothWidth))\n        mcApp.set_variable(\"Tooth_Width\", toothWidth)\n        mcApp.do_steady_state_analysis()\n        temperature = mcApp.get_variable(\n            \"T_[WINDING_AVERAGE]\",\n        )\n        mcApp.show_message(\"Winding temperature = \" + str(temperature))\n\n    mcApp.set_variable(\"MessageDisplayState\", 0)"
    },
    {
        "objectID": "user_guide/internal_scripting",
        "href": "user_guide/internal_scripting.html#functions-run-during-calculations",
        "title": "Motor-CAD internal Scripting tab > Functions run during calculations",
        "section": "Functions run during calculations",
        "text": "The previously described functions run only when the Run During Analysis option\nis selected from the Scripting -> Settings tab in Motor-CAD. (This option appears\nunder the Script Control heading.)\nIf the Run During Analysis option is selected, the script is imported.\nThis means that anything other than setting up the MotorCAD object should\nbe moved to a function or class to avoid unexpected behavior.\nFive classes are defined: thermal_steady, thermal_transient,\nemagnetic, mechanical_stress and mechanical_forces.\nEach of these classes contains the initial and final functions.\nThe thermal classes also contain the main function.\ninitial is called before the calculation.\nfinal is called after the calculation.\nmain is called before each time step in a calculation.\nThe thermal_steady class contains functions for steady-state\nthermal calculations:\nThe thermal_transient class contains functions for transient\nthermal calculations:\nThe emagnetic class contains functions for E-Magnetic calculations:\nThe mechanical_stress class contains functions for Mechanical stress calculations:\nThe mechanical_forces class contains functions for Mechanical force calculations:\nFor any scripts that are to be run before, during, or after a particular Motor-CAD\ncalculation, these functions can be added to the relevant functions.\nclass thermal_steady:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Steady State - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Steady State - Main\")\n\n    def final(self):\n        print(\"Thermal Steady State - Final\")\nclass thermal_transient:\n    def initial(self):\n        self.step = 0\n        print(\"Thermal Transient - Initial\")\n\n    def main(self):\n        self.step = self.step + 1\n        print(\"Step: \" + str(self.step) + \". Thermal Transient State - Main\")\n\n    def final(self):\n        print(\"Thermal Transient - Final\")\nclass emagnetic:\n    def initial(self):\n        print(\"E-Magnetic - Initial\")\n\n    def final(self):\n        print(\"E-Magnetic - Final\")\nclass mechanical_stress:\n    def initial(self):\n        print(\"Mech Stress - Initial\")\n\n    def final(self):\n        print(\"Mech Stress - Final\")\nclass mechanical_forces:\n    def initial(self):\n        print(\"Mech Forces - Initial\")\n\n    def final(self):\n        print(\"Mech Forces - Final\")"
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_temperature",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_temperature.html#get_node_temperature",
        "title": "get_node_temperature",
        "section": "get_node_temperature",
        "text": "Get the temperature of a thermal node.\nNumber of the thermal node.\nTemperature of the thermal node."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.points",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Get points of shape/region from Entity list."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeTemperature",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeTemperature.html#getnodetemperature",
        "title": "GetNodeTemperature",
        "section": "GetNodeTemperature",
        "text": "Deprecated function. Replaced by MotorCAD.get_node_temperature()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_to_ansys_electronics_desktop",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_to_ansys_electronics_desktop.html#export_to_ansys_electronics_desktop",
        "title": "export_to_ansys_electronics_desktop",
        "section": "export_to_ansys_electronics_desktop",
        "text": "Export the model to a VBS script file that can run in Ansys Electronics Desktop.\nAbsolute filepath for the VSB script file. The default filepath\nis the Windows directory on the C: drive. The filepath must include\nthe name of the file. To specify a different filepath, use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.subtract",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract region from self, returning any additional regions.\nMotor-CAD region object\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetMeshGeneratorParam",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetMeshGeneratorParam.html#setmeshgeneratorparam",
        "title": "SetMeshGeneratorParam",
        "section": "SetMeshGeneratorParam",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.is_vertical",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.is_vertical.html#is_vertical",
        "title": "is_vertical",
        "section": "is_vertical",
        "text": "Check whether line is vertical."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_point_value",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.get_point_value.html#get_point_value",
        "title": "get_point_value",
        "section": "get_point_value",
        "text": "Get a point value from the Motor-CAD FEA.\nMotor-CAD shading function.\nValue for the x coordinate.\nValue for the y coordinate.\nValue from the FEA.\nUnits for parameter, which is the Motor-CAD shading function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateReport",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CreateReport.html#createreport",
        "title": "CreateReport",
        "section": "CreateReport",
        "text": "Deprecated function. Replaced by MotorCAD.create_report()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadReportTree",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadReportTree.html#loadreporttree",
        "title": "LoadReportTree",
        "section": "LoadReportTree",
        "text": "Deprecated function. Replaced by MotorCAD.load_report_tree()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMessages",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetMessages.html#getmessages",
        "title": "GetMessages",
        "section": "GetMessages",
        "text": "Deprecated function. Replaced by MotorCAD.get_messages()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_Magnetic_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_Magnetic_RT.html#addpoint_magnetic_rt",
        "title": "AddPoint_Magnetic_RT",
        "section": "AddPoint_Magnetic_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_point_magnetic_rt()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.coordinate_within_arc_radius",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.coordinate_within_arc_radius.html#coordinate_within_arc_radius",
        "title": "coordinate_within_arc_radius",
        "section": "coordinate_within_arc_radius",
        "text": "Check if coordinate exists within arc radius.\nCheck if this coordinate is on the Arc"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.insert_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.insert_entity.html#insert_entity",
        "title": "insert_entity",
        "section": "insert_entity",
        "text": "Insert entity to list of region entities at given index.\nIndex of which to insert at\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.get_force_frequency_domain_amplitude",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.get_force_frequency_domain_amplitude.html#get_force_frequency_domain_amplitude",
        "title": "get_force_frequency_domain_amplitude",
        "section": "get_force_frequency_domain_amplitude",
        "text": "Export the matrix value from a force space time harmonics matrix for a 2D FFT.\nRow index of the FFT matrix.\nColumn index of the FFT matrix."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_magnetisation_curves",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_magnetisation_curves.html#save_magnetisation_curves",
        "title": "save_magnetisation_curves",
        "section": "save_magnetisation_curves",
        "text": "Save the magnetisation curves to a text file.\nThis method is for switched reluctance machines (SRMs) only.\nFull path to the text file, including file name. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/geometry_functions",
        "href": "methods/geometry_functions.html#geometry-objects-and-functions",
        "title": "Geometry objects and functions",
        "section": "Geometry objects and functions",
        "text": "Geometry functions are used to define and modify\nthe Motor-CAD Adaptive Templates geometry using PyMotorCAD.\nMore information on Adaptive Templates is available\nin the ref_user_guide under ref_adaptive_templates_UG.\nRegion([motorcad_instance])\nPython representation of Motor-CAD geometry region.\nRegionMagnet([motorcad_instance])\nProvides the Python representation of a Motor-CAD magnet geometry region.\nCoordinate(x, y)\nProvides the Python representation of a coordinate in two-dimensional space.\nEntity(start, end)\nGeneric parent class for geometric entities based upon a start and end coordinate.\nEntityList([iterable])\nGeneric class for list of Entities.\nLine(start, end)\nPython representation of Motor-CAD line entity based upon start and end coordinates.\nArc(start, end[, centre, radius])\nPython representation of Motor-CAD arc entity based upon start, end, (centre or radius).\nget_entities_have_common_coordinate(...)\nCheck whether region entities create a closed region.\nxy_to_rt(x, y)\nConvert Motor-CAD Cartesian coordinates to polar coordinates in degrees.\nrt_to_xy(radius, theta)\nConvert Motor-CAD polar coordinates to Cartesian coordinates in degrees."
    },
    {
        "objectID": "methods/geometry_functions",
        "href": "methods/geometry_functions.html#geometry-objects",
        "title": "Geometry objects and functions > Geometry objects",
        "section": "Geometry objects",
        "text": "Region([motorcad_instance])\nPython representation of Motor-CAD geometry region.\nRegionMagnet([motorcad_instance])\nProvides the Python representation of a Motor-CAD magnet geometry region.\nCoordinate(x, y)\nProvides the Python representation of a coordinate in two-dimensional space.\nEntity(start, end)\nGeneric parent class for geometric entities based upon a start and end coordinate.\nEntityList([iterable])\nGeneric class for list of Entities.\nLine(start, end)\nPython representation of Motor-CAD line entity based upon start and end coordinates.\nArc(start, end[, centre, radius])\nPython representation of Motor-CAD arc entity based upon start, end, (centre or radius)."
    },
    {
        "objectID": "methods/geometry_functions",
        "href": "methods/geometry_functions.html#geometry-functions",
        "title": "Geometry objects and functions > Geometry functions",
        "section": "Geometry functions",
        "text": "get_entities_have_common_coordinate(...)\nCheck whether region entities create a closed region.\nxy_to_rt(x, y)\nConvert Motor-CAD Cartesian coordinates to polar coordinates in degrees.\nrt_to_xy(radius, theta)\nConvert Motor-CAD polar coordinates to Cartesian coordinates in degrees."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_point",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fea_path_point.html#set_fea_path_point",
        "title": "set_fea_path_point",
        "section": "set_fea_path_point",
        "text": "Add or edit a point in the path editor."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_mechanical_context",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_mechanical_context.html#show_mechanical_context",
        "title": "show_mechanical_context",
        "section": "show_mechanical_context",
        "text": "Show the mechanical context in Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_XY.html#addarc_xy",
        "title": "AddArc_XY",
        "section": "AddArc_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_xy()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_Magnetic_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_Magnetic_XY.html#addpoint_magnetic_xy",
        "title": "AddPoint_Magnetic_XY",
        "section": "AddPoint_Magnetic_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_point_magnetic_xy()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.html#line",
        "title": "Line",
        "section": "Line",
        "text": "Python representation of Motor-CAD line entity based upon start and end coordinates.\nStart coordinate.\nEnd coordinate.\nLine.coordinate_on_entity(coordinate)\nGet if a coordinate exists on this line.\nLine.get_coordinate_from_distance(...)\nGet the coordinate at the specified distance along the line from the reference.\nLine.get_coordinate_from_percentage_distance(...)\nGet the coordinate at the percentage distance along the line from the reference.\nLine.get_line_intersection(line)\nGet intersection Coordinate of line with another line.\nLine.mirror(mirror_line)\nMirror line about a line.\nLine.reverse()\nReverse Entity class.\nLine.rotate(centre_point, angle)\nRotate entity around a point for a given angle.\nLine.translate(x, y)\nTranslate Entity by specified x,y distances.\nLine.angle\nGet angle of line vector.\nLine.gradient\nGet gradient of line - A in equation (y = Ax + B).\nLine.is_horizontal\nCheck whether line is horizontal.\nLine.is_vertical\nCheck whether line is vertical.\nLine.length\nGet length of line.\nLine.midpoint\nGet midpoint of Line.\nLine.y_intercept\nGet y intercept of line - B in equation (y = Ax + B)."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.reset_adaptive_geometry",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.reset_adaptive_geometry.html#reset_adaptive_geometry",
        "title": "reset_adaptive_geometry",
        "section": "reset_adaptive_geometry",
        "text": "Reset geometry to default."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_duty_cycle",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_duty_cycle.html#save_duty_cycle",
        "title": "save_duty_cycle",
        "section": "save_duty_cycle",
        "text": "Save the duty cycle to a DAT file.\nThe duty cycle should be saved to a file with a DAT extension to ensure\nthat it can be correctly loaded into a MOT file.\nFilepath for saving the DAT file. The default directory is\nthe one with the MOT file. To use a different directory,\nspecify the absolute filepath. Use the r'filepath' syntax\nto force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_CustomMaterial_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddPoint_CustomMaterial_XY.html#addpoint_custommaterial_xy",
        "title": "AddPoint_CustomMaterial_XY",
        "section": "AddPoint_CustomMaterial_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_point_custom_material_xy()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_torque_envelope",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_torque_envelope.html#calculate_torque_envelope",
        "title": "calculate_torque_envelope",
        "section": "calculate_torque_envelope",
        "text": "Calculate the torque envelope for the machine."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateIronLossCoefficients",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateIronLossCoefficients.html#calculateironlosscoefficients",
        "title": "CalculateIronLossCoefficients",
        "section": "CalculateIronLossCoefficients",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_iron_loss_coefficients()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GeometryExport",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GeometryExport.html#geometryexport",
        "title": "GeometryExport",
        "section": "GeometryExport",
        "text": "Deprecated function. Replaced by MotorCAD.geometry_export()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetPointValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetPointValue.html#getpointvalue",
        "title": "GetPointValue",
        "section": "GetPointValue",
        "text": "Deprecated function. Replaced by MotorCAD.get_point_value()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetBndCond",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetBndCond.html#setbndcond",
        "title": "SetBndCond",
        "section": "SetBndCond",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetRegionColour",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetRegionColour.html#setregioncolour",
        "title": "SetRegionColour",
        "section": "SetRegionColour",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowResultsViewer_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ShowResultsViewer_Lab.html#showresultsviewer_lab",
        "title": "ShowResultsViewer_Lab",
        "section": "ShowResultsViewer_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.show_results_viewer_lab()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_RT",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddArc_RT.html#addarc_rt",
        "title": "AddArc_RT",
        "section": "AddArc_RT",
        "text": "Deprecated function. Replaced by MotorCAD.add_arc_rt()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.html#arc",
        "title": "Arc",
        "section": "Arc",
        "text": "Python representation of Motor-CAD arc entity based upon start, end, (centre or radius).\nStart coordinate.\nEnd coordinate.\nCentre coordinate.\nArc radius\nArc.coordinate_on_entity(coordinate)\nGet if a coordinate exists on this Arc.\nArc.coordinate_within_arc_radius(coordinate)\nCheck if coordinate exists within arc radius.\nArc.from_coordinates(start_point, ...)\nTake three coordinates and converts to an arc.\nArc.get_coordinate_from_distance(...)\nGet the coordinate at the specified distance along the arc from the reference coordinate.\nArc.get_coordinate_from_percentage_distance(...)\nGet the coordinate at the percentage distance along the arc from the reference coord.\nArc.mirror(mirror_line)\nMirror arc about a line.\nArc.reverse()\nReverse Arc entity.\nArc.rotate(centre_point, angle)\nRotate entity around a point for a given angle.\nArc.translate(x, y)\nTranslate Entity by specified x,y distances.\nArc.centre\nGet centre point of circle defining arc.\nArc.end_angle\nGet angle of end point from centre point coordinates.\nArc.length\nGet length of arc from start to end along circumference.\nArc.midpoint\nGet midpoint of arc.\nArc.start_angle\nGet angle of start point from centre point coordinates.\nArc.total_angle\nGet arc sweep angle."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate entity around a point for a given angle.\nCoordinate to rotate line around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autogen_Materials",
        "href": "methods/_autogen_Materials.html#materials",
        "title": "Materials",
        "section": "Materials",
        "text": "calculate_iron_loss_coefficients(material_name)\nCalculate and return the iron loss coefficients for the solid material.\ncalculate_magnet_parameters(material_name)\nCalculate parameters for the nonlinear demagnetization model.\ndelete_solid_material(material_name)\nDelete the solid material from the materials database.\nexport_solid_material(file_name, material_name)\nExport the solid material to the materials database.\nget_component_material(component_name)\nGet the solid material name of the component.\nimport_solid_material(file_name, material_name)\nImport the solid material from the materials database.\nsave_iron_loss_coefficients(material_name)\nSave the calculated iron loss coefficients to the materials database.\nsave_magnet_parameters(material_name)\nSave the calculated magnet parameters of the solid material to the materials database.\nset_component_material(component_name, ...)\nSet the solid material properties of the component from the materials database.\nset_fluid(cooling_type, fluid)\nSet the fluid for a cooling type."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_rt.html#add_arc_rt",
        "title": "add_arc_rt",
        "section": "add_arc_rt",
        "text": "Add an arc to the Motor-CAD axial geometry with an r, t (polar) coordinate system.\nThis method uses the center point, radius, and angles. Use degrees for angles.\nCenter position the radial coordinate.\nCenter position for the angular coordinate.\nAngular coordinate of the arc start point in degrees.\nAngular coordinate of the arc end point in degrees.\nRadius of the arc from the center point.\nadd_arc_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.clear",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.EntityList.clear.html#clear",
        "title": "clear",
        "section": "clear",
        "text": "Remove all items from list."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.html#entity",
        "title": "Entity",
        "section": "Entity",
        "text": "Generic parent class for geometric entities based upon a start and end coordinate.\nStart coordinate.\nEnd coordinate.\nEntity.mirror(mirror_line)\nMirror entity about a line.\nEntity.reverse()\nReverse Entity class.\nEntity.rotate(centre_point, angle)\nRotate entity around a point for a given angle.\nEntity.translate(x, y)\nTranslate Entity by specified x,y distances."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRegion_XY",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.AddRegion_XY.html#addregion_xy",
        "title": "AddRegion_XY",
        "section": "AddRegion_XY",
        "text": "Deprecated function. Replaced by MotorCAD.add_region_xy()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.translate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Entity.translate.html#translate",
        "title": "translate",
        "section": "translate",
        "text": "Translate Entity by specified x,y distances.\nx distance.\ny distance."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMagneticThermalCalculation",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoMagneticThermalCalculation.html#domagneticthermalcalculation",
        "title": "DoMagneticThermalCalculation",
        "section": "DoMagneticThermalCalculation",
        "text": "Deprecated function. Replaced by MotorCAD.do_magnetic_thermal_calculation()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateThermal_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateThermal_Lab.html#calculatethermal_lab",
        "title": "CalculateThermal_Lab",
        "section": "CalculateThermal_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_thermal_lab()."
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_mechanical_calculation",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_mechanical_calculation.html#do_mechanical_calculation",
        "title": "do_mechanical_calculation",
        "section": "do_mechanical_calculation",
        "text": "Run the Motor-CAD mechanical calculation."
    },
    {
        "objectID": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_file_name",
        "href": "methods/_autosummary_Variables/ansys.motorcad.core.motorcad_methods.MotorCAD.get_file_name.html#get_file_name",
        "title": "get_file_name",
        "section": "get_file_name",
        "text": "Get current .mot file name and path.\nCurrent .mot file path and name"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_winding_pattern",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_winding_pattern.html#save_winding_pattern",
        "title": "save_winding_pattern",
        "section": "save_winding_pattern",
        "text": "Save the winding pattern to a file.\nAbsolute filepath for the file. The default filepath is the\nWindows directory on the C: drive. The filepath must include\nthe name of the file. If the file is to be re-loaded into\nMotor-CAD, the file extension must be TXT. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.reverse",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.reverse.html#reverse",
        "title": "reverse",
        "section": "reverse",
        "text": "Reverse Arc entity."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateMagnetic_Lab",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.CalculateMagnetic_Lab.html#calculatemagnetic_lab",
        "title": "CalculateMagnetic_Lab",
        "section": "CalculateMagnetic_Lab",
        "text": "Deprecated function. Replaced by MotorCAD.calculate_magnetic_lab()."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_generator_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.calculate_generator_lab.html#calculate_generator_lab",
        "title": "calculate_generator_lab",
        "section": "calculate_generator_lab",
        "text": "Calculate generator performance.\nResults are saved in the MOT file results folder as LabResults_Generator.mat."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_template",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.save_template.html#save_template",
        "title": "save_template",
        "section": "save_template",
        "text": "Save the template to an MTT template file."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.children",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.children.html#children",
        "title": "children",
        "section": "children",
        "text": "Return list of child regions from Motor-CAD.\nlist of Motor-CAD region object"
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_magnet_region_rt",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_magnet_region_rt.html#add_magnet_region_rt",
        "title": "add_magnet_region_rt",
        "section": "add_magnet_region_rt",
        "text": "Add a magnet region to the Motor-CAD geometry with an r, t (polar) coordinate system.\nIf a region already exists, this method overwrites the existing region.\nUse degrees for angles.\nRegion position for the radial coordinate.\nRegion position for the angular coordinate in degrees.\nName of the region.\nMagnet material.\nMagnet angle in degrees.\nMagnet Br multiplier. The default is 1.\nMagnet polarity, where 0 is north and 1 is south.\nadd_magnet_region_rt will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_matrices",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.export_matrices.html#export_matrices",
        "title": "export_matrices",
        "section": "export_matrices",
        "text": "Export the resistance, power, and capacitance matrices to files.\nThe files are given the same name as the MOT model, with different\nfile extensions.\nDirectory for exporting the files. The default is the root\ndirectory. To use a different directory, specify the absolute\nfilepath. Use the r'filepath' syntax to force Python to\nignore special characters."
    },
    {
        "objectID": "user_guide/backwards_compatibility",
        "href": "user_guide/backwards_compatibility.html#backwards-compatibility-with-old-scripts",
        "title": "Backwards compatibility with old scripts",
        "section": "Backwards compatibility with old scripts",
        "text": "You can convert old ActiveX scripts to use PyMotorCAD\nas indicated in the subsequent sections.\nOld ActiveX scripts use this code to connect to Motor-CAD:\nTo use PyMotorCAD to connect to Motor-CAD, you replace the preceding code\nwith this code:\nWhile changing the communication method allows old ActiveX scripts to be\nconverted with minimal changes, some of the new features of PyMotorCAD\nare turned off to ensure compatibility of these older scripts.\nTo convert an old script so that it can use new PyMotorCAD features, you must change\nchange function names in the script to use Python syntax and update the function syntax.\nPython code conventions specify the use of snake case for function names. Thus, all\nfunctions in the ref_MotorCAD_object use lower case with underscores (snake_case).\nFor example, the function call for getting a variable in an old ActiveX script looks\nlike this:\nThe function name must be changed to use the Python function name:\nIf you are using a modern Python IDE, changing function names is straightforward\nbecause the IDE suggests functions based on your input:\nBuilt into the Python package is documentation that explains what\nfunctions do and what parameters they require:\nAdditionally, you can search for functions in the ref_MotorCAD_object.\nIn old ActiveX scripts, functions returned a success variable that would need\nto be checked to ensure an API call had been successful:\nThis meant that API calls could fail silently unless you checked the success variable every time.\nThis success variable has been removed because PyMotorCAD raises an exception if a failure occurs:\nFor cases where you might expect the API call to fail, you should wrap it in a try/except.\nFor example, the following script reads graph points until the end of the graph.\nThe MotorCADError exception type is used so that only errors raised by MotorCAD are caught:\nimport win32com.client\n\nmcApp = win32com.client.Dispatch(\"MotorCAD.AppAutomation\")\nimport ansys.motorcad.core as pymotorcad\n\nmcApp = pymotorcad.MotorCADCompatibility()\nMcApp.GetVariable()\nmcApp.get_variable()\nsuccess, VariableValue = mcApp.GetVariable(\"Not_A_Real_Var\")\nvariable_value = mcApp.get_variable(\"Not_A_Real_Var\")\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core import MotorCADError\n\nmcApp = pymotorcad.MotorCAD()\n\nmcApp.do_magnetic_calculation()\n\ni = 0\ntorque = []\n\nreading_graph = True\nwhile reading_graph is True:\n    try:\n        x, y = mcApp.get_magnetic_graph_point(\"TorqueVW\", i)\n        torque.append(y)\n        i = i + 1\n    except MotorCADError:\n        reading_graph = False"
    },
    {
        "objectID": "user_guide/backwards_compatibility",
        "href": "user_guide/backwards_compatibility.html#change-communication-method",
        "title": "Backwards compatibility with old scripts > Change communication method",
        "section": "Change communication method",
        "text": "Old ActiveX scripts use this code to connect to Motor-CAD:\nTo use PyMotorCAD to connect to Motor-CAD, you replace the preceding code\nwith this code:\nWhile changing the communication method allows old ActiveX scripts to be\nconverted with minimal changes, some of the new features of PyMotorCAD\nare turned off to ensure compatibility of these older scripts.\nimport win32com.client\n\nmcApp = win32com.client.Dispatch(\"MotorCAD.AppAutomation\")\nimport ansys.motorcad.core as pymotorcad\n\nmcApp = pymotorcad.MotorCADCompatibility()"
    },
    {
        "objectID": "user_guide/backwards_compatibility",
        "href": "user_guide/backwards_compatibility.html#convert-script-fully",
        "title": "Backwards compatibility with old scripts > Convert script fully",
        "section": "Convert script fully",
        "text": "To convert an old script so that it can use new PyMotorCAD features, you must change\nchange function names in the script to use Python syntax and update the function syntax.\nPython code conventions specify the use of snake case for function names. Thus, all\nfunctions in the ref_MotorCAD_object use lower case with underscores (snake_case).\nFor example, the function call for getting a variable in an old ActiveX script looks\nlike this:\nThe function name must be changed to use the Python function name:\nIf you are using a modern Python IDE, changing function names is straightforward\nbecause the IDE suggests functions based on your input:\nBuilt into the Python package is documentation that explains what\nfunctions do and what parameters they require:\nAdditionally, you can search for functions in the ref_MotorCAD_object.\nIn old ActiveX scripts, functions returned a success variable that would need\nto be checked to ensure an API call had been successful:\nThis meant that API calls could fail silently unless you checked the success variable every time.\nThis success variable has been removed because PyMotorCAD raises an exception if a failure occurs:\nFor cases where you might expect the API call to fail, you should wrap it in a try/except.\nFor example, the following script reads graph points until the end of the graph.\nThe MotorCADError exception type is used so that only errors raised by MotorCAD are caught:\nMcApp.GetVariable()\nmcApp.get_variable()\nsuccess, VariableValue = mcApp.GetVariable(\"Not_A_Real_Var\")\nvariable_value = mcApp.get_variable(\"Not_A_Real_Var\")\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core import MotorCADError\n\nmcApp = pymotorcad.MotorCAD()\n\nmcApp.do_magnetic_calculation()\n\ni = 0\ntorque = []\n\nreading_graph = True\nwhile reading_graph is True:\n    try:\n        x, y = mcApp.get_magnetic_graph_point(\"TorqueVW\", i)\n        torque.append(y)\n        i = i + 1\n    except MotorCADError:\n        reading_graph = False"
    },
    {
        "objectID": "user_guide/backwards_compatibility",
        "href": "user_guide/backwards_compatibility.html#change-function-names",
        "title": "Backwards compatibility with old scripts > Change function names",
        "section": "Change function names",
        "text": "Python code conventions specify the use of snake case for function names. Thus, all\nfunctions in the ref_MotorCAD_object use lower case with underscores (snake_case).\nFor example, the function call for getting a variable in an old ActiveX script looks\nlike this:\nThe function name must be changed to use the Python function name:\nIf you are using a modern Python IDE, changing function names is straightforward\nbecause the IDE suggests functions based on your input:\nBuilt into the Python package is documentation that explains what\nfunctions do and what parameters they require:\nAdditionally, you can search for functions in the ref_MotorCAD_object.\nMcApp.GetVariable()\nmcApp.get_variable()"
    },
    {
        "objectID": "user_guide/backwards_compatibility",
        "href": "user_guide/backwards_compatibility.html#update-function-syntax",
        "title": "Backwards compatibility with old scripts > Update function syntax",
        "section": "Update function syntax",
        "text": "In old ActiveX scripts, functions returned a success variable that would need\nto be checked to ensure an API call had been successful:\nThis meant that API calls could fail silently unless you checked the success variable every time.\nThis success variable has been removed because PyMotorCAD raises an exception if a failure occurs:\nFor cases where you might expect the API call to fail, you should wrap it in a try/except.\nFor example, the following script reads graph points until the end of the graph.\nThe MotorCADError exception type is used so that only errors raised by MotorCAD are caught:\nsuccess, VariableValue = mcApp.GetVariable(\"Not_A_Real_Var\")\nvariable_value = mcApp.get_variable(\"Not_A_Real_Var\")\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core import MotorCADError\n\nmcApp = pymotorcad.MotorCAD()\n\nmcApp.do_magnetic_calculation()\n\ni = 0\ntorque = []\n\nreading_graph = True\nwhile reading_graph is True:\n    try:\n        x, y = mcApp.get_magnetic_graph_point(\"TorqueVW\", i)\n        torque.append(y)\n        i = i + 1\n    except MotorCADError:\n        reading_graph = False"
    },
    {
        "objectID": "examples/links/sg_execution_times",
        "href": "examples/links/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "09:16.291 total execution time for 1 file from exampleslinks:\nExample\nTime\nMem (MB)\nsphx_glr_examples_links_ece_export_for_twinbuilder.py (ece_export_for_twinbuilder.py)\n09:16.291\n0.0"
    },
    {
        "objectID": "methods/_autogen_General",
        "href": "methods/_autogen_General.html#general",
        "title": "General",
        "section": "General",
        "text": "clear_duty_cycle()\nClear the duty cycle in both the lab and thermal contexts.\nclear_message_log()\nClear the message log file for the model.\ncreate_report(file_path, template_file_path)\nCreate a Word report of the report tree structure.\ndownload_mot_file(file_path)\nDownload the current .mot file from Motor-CAD and write it to a local directory.\nexport_force_animation(animation, file_name)\nExport a force animation to a GIF file.\nexport_matrices(directory_path)\nExport the resistance, power, and capacitance matrices to files.\nexport_multi_force_data(file_name)\nExport calculated multiforce data to a file.\nexport_nvh_results_data(file_name)\nExport NVH results data to a file.\nexport_results(solution_type, file_path)\nExport results from a solution to a CSV file.\nexport_to_ansys_discovery(file_path)\nExport the model to a Python script file that can be run in Ansys Discovery.\nexport_to_ansys_electronics_desktop(file_path)\nExport the model to a VBS script file that can run in Ansys Electronics Desktop.\ngeometry_export()\nExport the geometry to the file specified in the DXFFileName parameter.\nget_licence()\nCheck if a license is available for the current context and machine type.\nget_license()\nCheck if a license is available for the current context and machine type.\nget_messages(num_messages)\nGet a list of the last N messages from the message history.\nload_custom_drive_cycle(file_path)\nLoad a custom waveform from a file.\nload_duty_cycle(file_name)\nLoad a duty cycle from a DAT file.\nload_dxf_file(file_name)\nLoad a DXF geometry file.\nload_fea_result(file_path, solution_number)\nLoad an existing FEA solution to allow viewing of FEA results.\nload_from_file(mot_file)\nLoad a MOT file into the Motor-CAD instance.\nload_magnetisation_curves(file_path)\nLoad the magnetization curves from a text file.\nload_report_structure(file_path)\nLoad the tree structure of the report from a file.\nload_report_tree()\nLoad the report with the tree structure of the modules and components.\nload_results(solution_type)\nLoad the output results from an \"EMagnetic\" or \"Thermal\" solution.\nload_template(template_name)\nLoad a motor template.\nload_winding_pattern(file_path)\nLoad the winding pattern from a text file.\nquit()\nQuit Motor-CAD.\nsave_duty_cycle(file_path)\nSave the duty cycle to a DAT file.\nsave_magnetisation_curves(file_name)\nSave the magnetisation curves to a text file.\nsave_results(solution_type)\nSave the output results from an \"EMagnetic\" or \"Thermal\" solution.\nsave_template(template_file_name, name, ...)\nSave the template to an MTT template file.\nsave_to_file(mot_file)\nSave the MOT file.\nsave_winding_pattern(file_path)\nSave the winding pattern to a file.\nset_free()\nFree the Motor-CAD instance.\nupload_mot_file(file_path)\nUpload a .mot file to Motor-CAD instance from local directory."
    },
    {
        "objectID": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_thermal_context",
        "href": "methods/_autosummary_UI/ansys.motorcad.core.motorcad_methods.MotorCAD.show_thermal_context.html#show_thermal_context",
        "title": "show_thermal_context",
        "section": "show_thermal_context",
        "text": "Show the thermal context in Motor-CAD."
    },
    {
        "objectID": "user_guide/troubleshooting",
        "href": "user_guide/troubleshooting.html#troubleshooting",
        "title": "Troubleshooting",
        "section": "Troubleshooting",
        "text": "Solutions for common PyMotorCAD issues:\nWhen changing model parameters via automation, Motor-CAD does not update the user interface with the new parameter value\nat every step, to speed up the scripting.\nHowever, this means that you should never change a parameter which is shown on the currently displayed tab.\nBest practice is to view the Scripting tab when changing any parameters within Motor-CAD using the command:\nTo turn off popups in Motor-CAD, use the command:\nThis ensures that no dialogues are shown by Motor-CAD.\nNote that this turns off ‘crucial’ popups, for example: prompts to save data or overwrite data, or dialogues used to\nreconcile differences in material data between the database and .mot file. In each case the default action is\ntaken. This setting persists until Motor-CAD is closed.\nTo get the contents of the messages, use the command:\nThe retrieved messages can then be parsed and used by the user.\nUsing a num_messages value of 0 retrieves all messages in history, as detailed in the method’s description.\nTo simplify future calls to get_messages(), it is useful to clear the message history after getting the messages,\nby using the command:\nAutomation automatically launches whichever version of Motor-CAD is registered.\nCheck the registration form to see which version is registered.\nmcApp.display_screen(\"scripting\")\nmcApp.set_variable(\"MessageDisplayState\", 2)\nnum_messages = 100  # Specify number of messages to get\nmessages = mcApp.get_messages(num_messages)\nmcApp.clear_message_log()"
    },
    {
        "objectID": "user_guide/troubleshooting",
        "href": "user_guide/troubleshooting.html#the-ui-is-not-updated-when-a-parameter-is-changed-via-automation",
        "title": "Troubleshooting > The UI is not updated when a parameter is changed via automation",
        "section": "The UI is not updated when a parameter is changed via automation",
        "text": "When changing model parameters via automation, Motor-CAD does not update the user interface with the new parameter value\nat every step, to speed up the scripting.\nHowever, this means that you should never change a parameter which is shown on the currently displayed tab.\nBest practice is to view the Scripting tab when changing any parameters within Motor-CAD using the command:\nmcApp.display_screen(\"scripting\")"
    },
    {
        "objectID": "user_guide/troubleshooting",
        "href": "user_guide/troubleshooting.html#error-messages-from-motor-cad-keep-interrupting-the-script",
        "title": "Troubleshooting > Error messages from Motor-CAD keep interrupting the script",
        "section": "Error messages from Motor-CAD keep interrupting the script",
        "text": "To turn off popups in Motor-CAD, use the command:\nThis ensures that no dialogues are shown by Motor-CAD.\nNote that this turns off ‘crucial’ popups, for example: prompts to save data or overwrite data, or dialogues used to\nreconcile differences in material data between the database and .mot file. In each case the default action is\ntaken. This setting persists until Motor-CAD is closed.\nTo get the contents of the messages, use the command:\nThe retrieved messages can then be parsed and used by the user.\nUsing a num_messages value of 0 retrieves all messages in history, as detailed in the method’s description.\nTo simplify future calls to get_messages(), it is useful to clear the message history after getting the messages,\nby using the command:\nmcApp.set_variable(\"MessageDisplayState\", 2)\nnum_messages = 100  # Specify number of messages to get\nmessages = mcApp.get_messages(num_messages)\nmcApp.clear_message_log()"
    },
    {
        "objectID": "user_guide/troubleshooting",
        "href": "user_guide/troubleshooting.html#the-wrong-version-of-motor-cad-launches",
        "title": "Troubleshooting > The wrong version of Motor-CAD launches",
        "section": "The wrong version of Motor-CAD launches",
        "text": "Automation automatically launches whichever version of Motor-CAD is registered.\nCheck the registration form to see which version is registered."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.save_fea_data",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.save_fea_data.html#save_fea_data",
        "title": "save_fea_data",
        "section": "save_fea_data",
        "text": "Save raw data for the open FEA solution."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetPowerInjectionValue",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SetPowerInjectionValue.html#setpowerinjectionvalue",
        "title": "SetPowerInjectionValue",
        "section": "SetPowerInjectionValue",
        "text": "Deprecated function. Replaced by MotorCAD.set_power_injection_value()."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_all_data",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.clear_all_data.html#clear_all_data",
        "title": "clear_all_data",
        "section": "clear_all_data",
        "text": "Clear data and initialize the FEA.\nDeprecated since version 0.6.0: clear_all_data will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.export_solid_material",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.export_solid_material.html#export_solid_material",
        "title": "export_solid_material",
        "section": "export_solid_material",
        "text": "Export the solid material to the materials database.\nName of the materials database.\nName of the solid material."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.save_adaptive_script",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.save_adaptive_script.html#save_adaptive_script",
        "title": "save_adaptive_script",
        "section": "save_adaptive_script",
        "text": "Save adaptive templates script from Motor-CAD to file.\nfull file path of script"
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_internal_custom_loss",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.remove_internal_custom_loss.html#remove_internal_custom_loss",
        "title": "remove_internal_custom_loss",
        "section": "remove_internal_custom_loss",
        "text": "Remove an internal custom loss by name.\nName of lab internal custom loss"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeToNodeResistance",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetNodeToNodeResistance.html#getnodetonoderesistance",
        "title": "GetNodeToNodeResistance",
        "section": "GetNodeToNodeResistance",
        "text": "Deprecated function. Replaced by MotorCAD.get_node_to_node_resistance()."
    },
    {
        "objectID": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_if_geometry_is_valid",
        "href": "methods/_autosummary_Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.check_if_geometry_is_valid.html#check_if_geometry_is_valid",
        "title": "check_if_geometry_is_valid",
        "section": "check_if_geometry_is_valid",
        "text": "Check if the Motor-CAD geometry is valid.\nIndicates if Motor-CAD can try to reset the geometry\nwithin constraints if the geometry is invalid. Options are:\n1: Yes. Try and reset the geometry\n0: No. Do not try to reset the geometry.\n1 if an attempt to reset the geometry has been made, O otherwise."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportNVHResultsData",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.ExportNVHResultsData.html#exportnvhresultsdata",
        "title": "ExportNVHResultsData",
        "section": "ExportNVHResultsData",
        "text": "Deprecated function. Replaced by MotorCAD.export_nvh_results_data()."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.show_results_viewer_lab",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.show_results_viewer_lab.html#show_results_viewer_lab",
        "title": "show_results_viewer_lab",
        "section": "show_results_viewer_lab",
        "text": "Load the results viewer for the specified Lab calculation type.\nType of calculation. Options are \"Electromagnetic\", \"Thermal\",\n\"Generator\", \"Duty Cycle\", and \"Calibration\"."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.geometry_export",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.geometry_export.html#geometry_export",
        "title": "geometry_export",
        "section": "geometry_export",
        "text": "Export the geometry to the file specified in the DXFFileName parameter."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.IsStopRequested",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.IsStopRequested.html#isstoprequested",
        "title": "IsStopRequested",
        "section": "IsStopRequested",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_magnet_region_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_magnet_region_xy.html#add_magnet_region_xy",
        "title": "add_magnet_region_xy",
        "section": "add_magnet_region_xy",
        "text": "Add a magnet region to the Motor-CAD geometry with an x, y coordinate system.\nIf a region already exists, this method overwrites the existing region.\nUse degrees for angles.\nRegion position for the x coordinate.\nRegion position for the y coordinate.\nName of the region.\nMagnet material.\nMagnet angle in degrees.\nMagnet Br multiplier. The default is 1.\nMagnet polarity, where 0 is north and 1 is south.\nadd_magnet_region_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.InitiateGeometryFromScript",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.InitiateGeometryFromScript.html#initiategeometryfromscript",
        "title": "InitiateGeometryFromScript",
        "section": "InitiateGeometryFromScript",
        "text": "Deprecated function. Replaced by MotorCAD.initiate_geometry_from_script()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadResults",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadResults.html#loadresults",
        "title": "LoadResults",
        "section": "LoadResults",
        "text": "Deprecated function. Replaced by MotorCAD.load_results()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_results",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_results.html#load_results",
        "title": "load_results",
        "section": "load_results",
        "text": "Load the output results from an \"EMagnetic\" or \"Thermal\" solution.\nThis method supports only \"EMagnetic\" or \"Thermal\" solution.\nSolution type, which must be \"EMagnetic\" or \"Thermal\"."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_licence",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.get_licence.html#get_licence",
        "title": "get_licence",
        "section": "get_licence",
        "text": "Check if a license is available for the current context and machine type.\nIf such a license is available, it is checked out."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_magnetisation_curves",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.load_magnetisation_curves.html#load_magnetisation_curves",
        "title": "load_magnetisation_curves",
        "section": "load_magnetisation_curves",
        "text": "Load the magnetization curves from a text file.\nThis method is for switched reluctance machines (SRMs) only.\nFull path to the text file, including the file name. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_drawing/ansys.motorcad.core.geometry_drawing.draw_objects",
        "href": "methods/_autosummary_geometry_drawing/ansys.motorcad.core.geometry_drawing.draw_objects.html#draw_objects",
        "title": "draw_objects",
        "section": "draw_objects",
        "text": "Draw geometry objects on a plot."
    },
    {
        "objectID": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.add_internal_custom_loss",
        "href": "methods/_autosummary_Lab/ansys.motorcad.core.motorcad_methods.MotorCAD.add_internal_custom_loss.html#add_internal_custom_loss",
        "title": "add_internal_custom_loss",
        "section": "add_internal_custom_loss",
        "text": "Add an internal custom loss.\nName of lab internal custom loss\nFunction of lab internal custom loss\nType of lab internal custom loss. Options are Electrical or Mechanical\nThermal node of lab internal custom loss"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.download_mot_file",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.download_mot_file.html#download_mot_file",
        "title": "download_mot_file",
        "section": "download_mot_file",
        "text": "Download the current .mot file from Motor-CAD and write it to a local directory.\nThis allows users to download .mot files to a local directory from a Motor-CAD instance\non a remote machine. Equivalent of save_file() for remote machines.\nFull path to the mot file, including the file name and .mot extension.\nUse the r'filepath' syntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_capacitance",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.get_node_capacitance.html#get_node_capacitance",
        "title": "get_node_capacitance",
        "section": "get_node_capacitance",
        "text": "Get the capacitance of a thermal node.\nNumber of the thermal node.\nCapacitance of the thermal node."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.add_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.add_entity.html#add_entity",
        "title": "add_entity",
        "section": "add_entity",
        "text": "Add entity to list of region entities.\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_heatflow_graph",
        "href": "methods/_autosummary_Graphs/ansys.motorcad.core.motorcad_methods.MotorCAD.get_heatflow_graph.html#get_heatflow_graph",
        "title": "get_heatflow_graph",
        "section": "get_heatflow_graph",
        "text": "Get graph points from a Motor-CAD heat flow graph.\nName (preferred) or ID of the graph. In Motor-CAD, you can\nselect Help -> Graph Viewer to see the graph name.\nvalue of x coordinates from graph\nvalue of y coordinates from graph"
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SolveProblem",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SolveProblem.html#solveproblem",
        "title": "SolveProblem",
        "section": "SolveProblem",
        "text": "Deprecated function."
    },
    {
        "objectID": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.eq_triangle_h",
        "href": "methods/_autosummary_geometry_shapes/ansys.motorcad.core.geometry_shapes.eq_triangle_h.html#eq_triangle_h",
        "title": "eq_triangle_h",
        "section": "eq_triangle_h",
        "text": "Create an equilateral triangle of given height at a given set of coordinates.\nHeight value.\nRadial coordinate of the triangle centre.\nAngular coordinate of the triangle centre.\nRegion type with three Line entity types."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadWindingPattern",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.LoadWindingPattern.html#loadwindingpattern",
        "title": "LoadWindingPattern",
        "section": "LoadWindingPattern",
        "text": "Deprecated function. Replaced by MotorCAD.load_winding_pattern()."
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.create_report",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.create_report.html#create_report",
        "title": "create_report",
        "section": "create_report",
        "text": "Create a Word report of the report tree structure.\nFilepath for the Word report. Use the r'filepath'\nsyntax to force Python to ignore special characters.\nFilepath for the template file. Use the r'filepath'\nsyntax to force Python to ignore special characters."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_multiplier",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.br_multiplier.html#br_multiplier",
        "title": "br_multiplier",
        "section": "br_multiplier",
        "text": "Br multiplier."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.get_component_material",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.get_component_material.html#get_component_material",
        "title": "get_component_material",
        "section": "get_component_material",
        "text": "Get the solid material name of the component.\nComponent name. In Motor-CAD, you can select Input Data -> Materials\nand view the Component column to see component names."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMagnetParameters",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.SaveMagnetParameters.html#savemagnetparameters",
        "title": "SaveMagnetParameters",
        "section": "SaveMagnetParameters",
        "text": "Deprecated function. Replaced by MotorCAD.save_magnet_parameters()."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.reverse",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.reverse.html#reverse",
        "title": "reverse",
        "section": "reverse",
        "text": "Reverse Entity class."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.magnet_angle",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.magnet_angle.html#magnet_angle",
        "title": "magnet_angle",
        "section": "magnet_angle",
        "text": "Angle of the magnet in degrees."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.rotate",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate Region around a point for a given angle.\npoint to rotate Coordinate around.\nAngle of rotation in degrees. Anticlockwise direction is positive."
    },
    {
        "objectID": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_resistance_multiplier",
        "href": "methods/_autosummary_Thermal/ansys.motorcad.core.motorcad_methods.MotorCAD.set_resistance_multiplier.html#set_resistance_multiplier",
        "title": "set_resistance_multiplier",
        "section": "set_resistance_multiplier",
        "text": "Set or create a resistance multiplication factor."
    },
    {
        "objectID": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fluid",
        "href": "methods/_autosummary_Materials/ansys.motorcad.core.motorcad_methods.MotorCAD.set_fluid.html#set_fluid",
        "title": "set_fluid",
        "section": "set_fluid",
        "text": "Set the fluid for a cooling type.\nType of the cooling. Options are \"InternalFluid\",\n\"ExternalFluid\", \"ShaftSGFluid\", \"RotorWJFluid\",\n\"SlotWJFluid\", \"HousingWJFluid\", \"WetRotorFluid\",\n\"SprayCoolingFluid\", \"TVentFluid\",\n\"Spray_RadialHousing_Fluid\", \"Spray_RadialRotor_Fluid\",\n\"Spray_RadialHousing_Fluid_F\", \"Spray_RadialHousing_Fluid_R\",\n\"Spray_RadialRotor_Fluid_F\" and \"Spray_RadialRotor_Fluid_R\"."
    },
    {
        "objectID": "examples/internal_scripting/thermal_steady_state",
        "href": "examples/internal_scripting/thermal_steady_state.html#thermal-steady-state",
        "title": "Thermal steady-state",
        "section": "Thermal steady-state",
        "text": "This example demonstrates internal scripting thermal steady-state functionality\nPerform required imports\nLaunch Motor-CAD\nWe will update the resistance between nodes with the following equation:\nresistance = (0.01 × ambient_temp) + 1\nThis function is called when “Run” is pressed\n(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 28.750 seconds)\nDownload Jupyter notebook: thermal_steady_state.ipynb\nDownload Python source code: thermal_steady_state.py\nDownload zipped: thermal_steady_state.zip\nGallery generated by Sphinx-Gallery\nimport ansys.motorcad.core as pymotorcad\nmc = pymotorcad.MotorCAD()\ndef main():\n    pass\n\n\nclass thermal_steady:\n    # Select nodes to update\n    housing_node = 1\n    ambient_node = 0\n\n    def initial(self):\n        # %%\n        # Disable pop-up messages\n        mc.set_variable(\"MessageDisplayState\", 2)\n\n        # Adjust Losses\n        mc.display_screen(\"Scripting\")\n        mc.set_variable(\"Armature_Copper_Loss_@Ref_Speed\", 200)\n\n    def main(self):\n        ambient_temp = mc.get_variable(\"T_Ambient\")\n        resistance = (ambient_temp * 0.01) + 1\n        mc.set_resistance_value(\n            \"Custom Resistance\", self.ambient_node, self.housing_node, resistance, \"\"\n        )\n        print(str(resistance))\n\n    def final(self):\n        # Get temperature from node\n        housing_temp = mc.get_node_temperature(self.housing_node)\n        print(\"Housing Temperature: \" + str(round(housing_temp, 1)))\n\n        mc.set_variable(\"MessageDisplayState\", 0)\ntry:\n    from setup_scripts.setup_script import run_thermal_steady_demo\nexcept ImportError:\n    pass\nelse:\n    run_thermal_steady_demo(mc)\nArmature copper loss = 200\n9:18:55 AM : Python script output: 1.4\n9:18:56 AM : Steady State calculation completed after 7 iterations\n9:18:56 AM : Python script output: Housing Temperature: 111.8"
    },
    {
        "objectID": "examples/internal_scripting/thermal_steady_state",
        "href": "examples/internal_scripting/thermal_steady_state.html#pymotorcad-documentation-example",
        "title": "Thermal steady-state > PyMotorCAD Documentation Example",
        "section": "PyMotorCAD Documentation Example",
        "text": "(Used for the PyMotorCAD Documentation Examples only)\nTotal running time of the script: (0 minutes 28.750 seconds)\nDownload Jupyter notebook: thermal_steady_state.ipynb\nDownload Python source code: thermal_steady_state.py\nDownload zipped: thermal_steady_state.zip\nGallery generated by Sphinx-Gallery\ntry:\n    from setup_scripts.setup_script import run_thermal_steady_demo\nexcept ImportError:\n    pass\nelse:\n    run_thermal_steady_demo(mc)\nArmature copper loss = 200\n9:18:55 AM : Python script output: 1.4\n9:18:56 AM : Steady State calculation completed after 7 iterations\n9:18:56 AM : Python script output: Housing Temperature: 111.8"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.collides",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.collides.html#collides",
        "title": "collides",
        "section": "collides",
        "text": "Check whether any of the specified regions collide with self.\nMotor-CAD region object/list of objects"
    },
    {
        "objectID": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_boundary_xy",
        "href": "methods/_autosummary_FEA Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.add_arc_boundary_xy.html#add_arc_boundary_xy",
        "title": "add_arc_boundary_xy",
        "section": "add_arc_boundary_xy",
        "text": "Add a boundary condition arc using x, y coordinates for the center.\nDeprecated since version 0.6.0: add_arc_boundary_xy will be removed with Motor-CAD 2025R2 (tentative).\nFunctionality replaced by adaptive templates."
    },
    {
        "objectID": "methods/geometry_drawing",
        "href": "methods/geometry_drawing.html#geometry-drawing",
        "title": "Geometry drawing",
        "section": "Geometry drawing",
        "text": "Geometry drawing functions are used to visualise Motor-CAD\ngeometry objects using PyMotorCAD.\nMore information on Adaptive Templates is available\nin the ref_user_guide under ref_adaptive_templates_UG.\ndraw_objects(objects)\nDraw geometry objects on a plot.\ndraw_objects_debug(objects)\nDraw regions on plot if not being run in Motor-CAD."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.length",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Arc.length.html#length",
        "title": "length",
        "section": "length",
        "text": "Get length of arc from start to end along circumference.\nLength of arc"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.gradient",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Line.gradient.html#gradient",
        "title": "gradient",
        "section": "gradient",
        "text": "Get gradient of line - A in equation (y = Ax + B).\nUndefined for vertical lines."
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.remove_entity",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.RegionMagnet.remove_entity.html#remove_entity",
        "title": "remove_entity",
        "section": "remove_entity",
        "text": "Remove the entity from the region.\nLine/arc entity class instance"
    },
    {
        "objectID": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.upload_mot_file",
        "href": "methods/_autosummary_General/ansys.motorcad.core.motorcad_methods.MotorCAD.upload_mot_file.html#upload_mot_file",
        "title": "upload_mot_file",
        "section": "upload_mot_file",
        "text": "Upload a .mot file to Motor-CAD instance from local directory.\nThis allows users to send .mot files from a local directory to a Motor-CAD instance\non a remote machine. Equivalent of load_file() for remote machines.\nFull path to the mot file, including the file name and .mot extension.\nUse the r'filepath' syntax to force Python to ignore special characters."
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#bezier-curve-rotor-pockets",
        "title": "Bezier curve rotor pockets",
        "section": "Bezier curve rotor pockets",
        "text": "This script applies the adaptive templates functionality to modify rotor pockets\nwith a custom curve defined using a Bezier function.\nThis script requires Motor-CAD 2024 R2 or later.\nThis script is designed to be run from a Motor-CAD model based on the e4a template (a 48 slot,\n8 pole IPM machine). The model is modified from the template by adjusting the Standard Template\ngeometry parameters as follows:\nSet L1 Bridge thickness to 2 mm.\nSet L1 Pole V Angle to 180 degrees.\nSet L1 Magnet Post to 0 mm.\nSet L1 Magnet Separation to 0 mm.\nSet L1 Mag Gap Inner to 0 mm.\nIf no Motor-CAD file is open, the e4a template is loaded and the geometry is adjusted as\ndescribed earlier.\nImport the pymotorcad package to access Motor-CAD.\nImport the Coordinate, Arc, Line and rt_to_xy objects\nto define the adaptive template geometry.\nImport bezier used to draw the curve.\nImport the os, shutil, sys and tempfile packages\nto open and save a temporary MOT file if none is open.\nIf this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e4a IPM motor template is loaded, the geometry changes described earlier are applied and the\nfile is saved to a temporary folder. To keep a new Motor-CAD instance open after executing the\nscript, use the MotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nThe set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nUse the set_default_parameter() function to set the required L1 Bezier Curve Projection,\nL1 Upper Convex and L1 Lower Concave parameters if undefined.\nThe adaptive parameters are used to define the curved rotor pocket geometry with a Bezier\nfunction. The parameters relate to the rotor pocket shape as follows:\nL1 Bezier Curve Projection: Defines the rotor pocket extension beyond the magnet edge in the\ndirection of the magnet length in mm.\nL1 Upper Convex: Defines the concave rotor pocket extension beyond the magnet edge in the\ndirection of the magnet thickness. This parameter is dependent on the magnet thickness (a\nStandard Template parameter).\nL1 Lower Concave: Defines the convex rotor pocket curvature in the direction of the magnet\nthickness. This parameter is dependent on the magnet thickness (a Standard Template parameter).\nFrom Motor-CAD, get the adaptive parameters and their values.\nGet the standard template rotor region. This can be drawn for debugging if required.\nGet the adaptive parameters specified in Motor-CAD, and their values\nGet the Rotor Pocket regions\nGet the magnet regions\nFind the magnet edge that is shared with the first rotor pocket\nGet properties of the magnet edge that are to be used to define the new rotor pocket geometry\nRemove all existing entities from the first rotor pocket\nDefine the x-y points that are to be used to draw the new rotor pocket. The points are defined\nrelative to a vertical magnet edge (parallel to the y axis).\nDefine nodes from points and create curve using bezier\nCreate set of points for drawing the calculated bezier curve\nAdd the points as Coordinate objects to a list\nCreate a list of entities from the curve points\nAdd the new entities that make up the curve to the first rotor pocket region\nCounts the number of arcs and lines\nTranslate (move) the rotor pocket region in the x-y plane to the magnet edge\nRotate the rotor pocket region to match the magnet edge\nAdd the magnet edge line to the rotor pocket region\nCheck that the rotor pocket region is joined up and set the region in Motor-CAD\nMirror the first rotor pocket region on the other half of the rotor. Define the mirror line from\nthe origin and use the Region.mirror() method to create a new region named mirroredRegion\nfrom the rotor pocket region.\nUse the Region.replace() method to replace the entities in the second rotor pocket with those\nfrom the new mirroredRegion. The properties of the second rotor pocket (such as name,\nmaterial, colour) are retained.\nCheck that the rotor pocket region is joined up and set the region in Motor-CAD\nWhen this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 57.142 seconds)\nDownload Jupyter notebook: BezierCurveRotorPockets.ipynb\nDownload Python source code: BezierCurveRotorPockets.py\nDownload zipped: BezierCurveRotorPockets.zip\nGallery generated by Sphinx-Gallery\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport bezier\nimport numpy as np\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy\nfrom ansys.motorcad.core.geometry_fitting import return_entity_list\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e4a\")\n\n    # Set Standard Template geometry ready for Adaptive Templates script\n    mc.set_array_variable(\"BridgeThickness_Array\", 0, 2)  # Bridge thickness set to 0\n    mc.set_array_variable(\"PoleVAngle_Array\", 0, 180)  # Pole V angle set to 180\n    mc.set_array_variable(\"VShapeMagnetPost_Array\", 0, 0)  # Magnet Post set to 0\n    mc.set_array_variable(\"MagnetSeparation_Array\", 0, 0)  # Magnet Separation set to 0\n    mc.set_array_variable(\"VShape_Magnet_ClearanceInner\", 0, 0)  # Magnet Inner Gap set to 0\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"IPM_Pocket_Bezier\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\nset_default_parameter(\"L1 Bezier Curve Projection\", 6)\nset_default_parameter(\"L1 Upper Convex\", 0.5)\nset_default_parameter(\"L1 Lower Concave\", -0.3)\nrotor_region = mc.get_region(\"Rotor\")\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\npoles = mc.get_variable(\"Pole_Number\")\npole_angle = 360 / (poles * 2)\ntotalprojection = mc.get_adaptive_parameter_value(\"L1 Bezier Curve Projection\")\nupperconvex = mc.get_adaptive_parameter_value(\"L1 Upper Convex\")\nlowerconcave = mc.get_adaptive_parameter_value(\"L1 Lower Concave\")\nRotor_Pocket_regions = []\nfor i in rotor_region.child_names:\n    if \"Pocket\" in i:\n        Rotor_Pocket_regions.append(mc.get_region(i))\nMagnet_regions = []\nfor i in rotor_region.child_names:\n    if \"Magnet\" in i:\n        Magnet_regions.append(mc.get_region(i))\nfor j in Magnet_regions:\n    for i in j.entities:\n        MagnetFaceLine = Rotor_Pocket_regions[0].find_entity_from_coordinates(i.start, i.end)\n        if MagnetFaceLine is not None:\n            break\nLineLength = MagnetFaceLine.length\nStartCoordinate = MagnetFaceLine.start\nRotor_Pocket_regions[0].entities.clear()\nxlist = np.array(\n    [\n        0.0,\n        totalprojection * -0.2,\n        totalprojection * -0.5,\n        -1 * totalprojection,\n        totalprojection * -0.5,\n        0.0,\n    ]\n)\nylist = np.array([0, 1 - 1 * lowerconcave, -0.5, 0.5, 1 + upperconvex, 1]) * LineLength\nnodes2 = np.asfortranarray(\n    [\n        xlist,\n        ylist,\n    ]\n)\ncurve2 = bezier.Curve.from_nodes(nodes2)\nnum_pts = 256\ns_vals = np.linspace(0.0, 1.0, num_pts)\npoints2 = curve2.evaluate_multi(s_vals)\nxylist = []\nfor i in range(num_pts):\n    c = Coordinate(points2[0, i], points2[1, i])\n    xylist.append(c)\nlinetolerance = 0.01\narctolerance = 0.01\nbez_curve_entities = return_entity_list(xylist, linetolerance, arctolerance)\narccount = 0\nlinecount = 0\nfor ent in bez_curve_entities:\n    Rotor_Pocket_regions[0].add_entity(ent)\n    if isinstance(ent, Arc):\n        arccount = arccount + 1\n    if isinstance(ent, Line):\n        linecount = linecount + 1\nRotor_Pocket_regions[0].translate(StartCoordinate.x, StartCoordinate.y)\nRotor_Pocket_regions[0].rotate(StartCoordinate, -(90 - MagnetFaceLine.angle))\nRotor_Pocket_regions[0].add_entity(MagnetFaceLine)\nif Rotor_Pocket_regions[0].is_closed():\n    mc.set_region(Rotor_Pocket_regions[0])\nmirrorlinex, mirrorliney = rt_to_xy(rotor_radius, pole_angle)\nmirrorLine = Line(Coordinate(0, 0), Coordinate(mirrorlinex, mirrorliney))\nmirroredRegion = Rotor_Pocket_regions[0].mirror(mirrorLine)\nRotor_Pocket_regions[1].replace(mirroredRegion)\nif Rotor_Pocket_regions[1].is_closed():\n    mc.set_region(Rotor_Pocket_regions[1])\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#perform-required-imports",
        "title": "Bezier curve rotor pockets > Perform required imports",
        "section": "Perform required imports",
        "text": "Import the pymotorcad package to access Motor-CAD.\nImport the Coordinate, Arc, Line and rt_to_xy objects\nto define the adaptive template geometry.\nImport bezier used to draw the curve.\nImport the os, shutil, sys and tempfile packages\nto open and save a temporary MOT file if none is open.\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport bezier\nimport numpy as np\n\nimport ansys.motorcad.core as pymotorcad\nfrom ansys.motorcad.core.geometry import Arc, Coordinate, Line, rt_to_xy\nfrom ansys.motorcad.core.geometry_fitting import return_entity_list"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#connect-to-motor-cad",
        "title": "Bezier curve rotor pockets > Connect to Motor-CAD",
        "section": "Connect to Motor-CAD",
        "text": "If this script is loaded into the Adaptive Templates file in Motor-CAD, the current Motor-CAD\ninstance is used.\nIf the script is run externally, these actions occur: a new Motor-CAD instance is opened,\nthe e4a IPM motor template is loaded, the geometry changes described earlier are applied and the\nfile is saved to a temporary folder. To keep a new Motor-CAD instance open after executing the\nscript, use the MotorCAD(keep_instance_open=True) option when opening the new instance.\nAlternatively, use the MotorCAD() method, which closes the Motor-CAD instance after the\nscript is executed.\nif pymotorcad.is_running_in_internal_scripting():\n    # Use existing Motor-CAD instance if possible\n    mc = pymotorcad.MotorCAD(open_new_instance=False)\nelse:\n    mc = pymotorcad.MotorCAD(keep_instance_open=True)\n    # Disable popup messages\n    mc.set_variable(\"MessageDisplayState\", 2)\n    mc.set_visible(True)\n    mc.load_template(\"e4a\")\n\n    # Set Standard Template geometry ready for Adaptive Templates script\n    mc.set_array_variable(\"BridgeThickness_Array\", 0, 2)  # Bridge thickness set to 0\n    mc.set_array_variable(\"PoleVAngle_Array\", 0, 180)  # Pole V angle set to 180\n    mc.set_array_variable(\"VShapeMagnetPost_Array\", 0, 0)  # Magnet Post set to 0\n    mc.set_array_variable(\"MagnetSeparation_Array\", 0, 0)  # Magnet Separation set to 0\n    mc.set_array_variable(\"VShape_Magnet_ClearanceInner\", 0, 0)  # Magnet Inner Gap set to 0\n\n    # Open relevant file\n    working_folder = os.path.join(tempfile.gettempdir(), \"adaptive_library\")\n    try:\n        shutil.rmtree(working_folder)\n    except:\n        pass\n    os.mkdir(working_folder)\n    mot_name = \"IPM_Pocket_Bezier\"\n    mc.save_to_file(working_folder + \"/\" + mot_name + \".mot\")\n\n# Reset geometry to default\nmc.reset_adaptive_geometry()"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#set-adaptive-parameter-if-required",
        "title": "Bezier curve rotor pockets > Set adaptive parameter if required",
        "section": "Set adaptive parameter if required",
        "text": "The set_default_parameter function is defined to check if a parameter exists. If not,\nit creates the parameter with a default value.\nUse the set_default_parameter() function to set the required L1 Bezier Curve Projection,\nL1 Upper Convex and L1 Lower Concave parameters if undefined.\nThe adaptive parameters are used to define the curved rotor pocket geometry with a Bezier\nfunction. The parameters relate to the rotor pocket shape as follows:\nL1 Bezier Curve Projection: Defines the rotor pocket extension beyond the magnet edge in the\ndirection of the magnet length in mm.\nL1 Upper Convex: Defines the concave rotor pocket extension beyond the magnet edge in the\ndirection of the magnet thickness. This parameter is dependent on the magnet thickness (a\nStandard Template parameter).\nL1 Lower Concave: Defines the convex rotor pocket curvature in the direction of the magnet\nthickness. This parameter is dependent on the magnet thickness (a Standard Template parameter).\ndef set_default_parameter(parameter_name, default_value):\n    try:\n        mc.get_adaptive_parameter_value(parameter_name)\n    except pymotorcad.MotorCADError:\n        mc.set_adaptive_parameter_value(parameter_name, default_value)\nset_default_parameter(\"L1 Bezier Curve Projection\", 6)\nset_default_parameter(\"L1 Upper Convex\", 0.5)\nset_default_parameter(\"L1 Lower Concave\", -0.3)"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#get-required-parameters-and-objects",
        "title": "Bezier curve rotor pockets > Get required parameters and objects",
        "section": "Get required parameters and objects",
        "text": "From Motor-CAD, get the adaptive parameters and their values.\nGet the standard template rotor region. This can be drawn for debugging if required.\nGet the adaptive parameters specified in Motor-CAD, and their values\nGet the Rotor Pocket regions\nGet the magnet regions\nFind the magnet edge that is shared with the first rotor pocket\nGet properties of the magnet edge that are to be used to define the new rotor pocket geometry\nrotor_region = mc.get_region(\"Rotor\")\nrotor_radius = mc.get_variable(\"RotorDiameter\") / 2\npoles = mc.get_variable(\"Pole_Number\")\npole_angle = 360 / (poles * 2)\ntotalprojection = mc.get_adaptive_parameter_value(\"L1 Bezier Curve Projection\")\nupperconvex = mc.get_adaptive_parameter_value(\"L1 Upper Convex\")\nlowerconcave = mc.get_adaptive_parameter_value(\"L1 Lower Concave\")\nRotor_Pocket_regions = []\nfor i in rotor_region.child_names:\n    if \"Pocket\" in i:\n        Rotor_Pocket_regions.append(mc.get_region(i))\nMagnet_regions = []\nfor i in rotor_region.child_names:\n    if \"Magnet\" in i:\n        Magnet_regions.append(mc.get_region(i))\nfor j in Magnet_regions:\n    for i in j.entities:\n        MagnetFaceLine = Rotor_Pocket_regions[0].find_entity_from_coordinates(i.start, i.end)\n        if MagnetFaceLine is not None:\n            break\nLineLength = MagnetFaceLine.length\nStartCoordinate = MagnetFaceLine.start"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#create-the-adaptive-templates-geometry",
        "title": "Bezier curve rotor pockets > Create the Adaptive Templates geometry",
        "section": "Create the Adaptive Templates geometry",
        "text": "Remove all existing entities from the first rotor pocket\nDefine the x-y points that are to be used to draw the new rotor pocket. The points are defined\nrelative to a vertical magnet edge (parallel to the y axis).\nDefine nodes from points and create curve using bezier\nCreate set of points for drawing the calculated bezier curve\nAdd the points as Coordinate objects to a list\nCreate a list of entities from the curve points\nAdd the new entities that make up the curve to the first rotor pocket region\nCounts the number of arcs and lines\nTranslate (move) the rotor pocket region in the x-y plane to the magnet edge\nRotate the rotor pocket region to match the magnet edge\nAdd the magnet edge line to the rotor pocket region\nCheck that the rotor pocket region is joined up and set the region in Motor-CAD\nMirror the first rotor pocket region on the other half of the rotor. Define the mirror line from\nthe origin and use the Region.mirror() method to create a new region named mirroredRegion\nfrom the rotor pocket region.\nUse the Region.replace() method to replace the entities in the second rotor pocket with those\nfrom the new mirroredRegion. The properties of the second rotor pocket (such as name,\nmaterial, colour) are retained.\nCheck that the rotor pocket region is joined up and set the region in Motor-CAD\nRotor_Pocket_regions[0].entities.clear()\nxlist = np.array(\n    [\n        0.0,\n        totalprojection * -0.2,\n        totalprojection * -0.5,\n        -1 * totalprojection,\n        totalprojection * -0.5,\n        0.0,\n    ]\n)\nylist = np.array([0, 1 - 1 * lowerconcave, -0.5, 0.5, 1 + upperconvex, 1]) * LineLength\nnodes2 = np.asfortranarray(\n    [\n        xlist,\n        ylist,\n    ]\n)\ncurve2 = bezier.Curve.from_nodes(nodes2)\nnum_pts = 256\ns_vals = np.linspace(0.0, 1.0, num_pts)\npoints2 = curve2.evaluate_multi(s_vals)\nxylist = []\nfor i in range(num_pts):\n    c = Coordinate(points2[0, i], points2[1, i])\n    xylist.append(c)\nlinetolerance = 0.01\narctolerance = 0.01\nbez_curve_entities = return_entity_list(xylist, linetolerance, arctolerance)\narccount = 0\nlinecount = 0\nfor ent in bez_curve_entities:\n    Rotor_Pocket_regions[0].add_entity(ent)\n    if isinstance(ent, Arc):\n        arccount = arccount + 1\n    if isinstance(ent, Line):\n        linecount = linecount + 1\nRotor_Pocket_regions[0].translate(StartCoordinate.x, StartCoordinate.y)\nRotor_Pocket_regions[0].rotate(StartCoordinate, -(90 - MagnetFaceLine.angle))\nRotor_Pocket_regions[0].add_entity(MagnetFaceLine)\nif Rotor_Pocket_regions[0].is_closed():\n    mc.set_region(Rotor_Pocket_regions[0])\nmirrorlinex, mirrorliney = rt_to_xy(rotor_radius, pole_angle)\nmirrorLine = Line(Coordinate(0, 0), Coordinate(mirrorlinex, mirrorliney))\nmirroredRegion = Rotor_Pocket_regions[0].mirror(mirrorLine)\nRotor_Pocket_regions[1].replace(mirroredRegion)\nif Rotor_Pocket_regions[1].is_closed():\n    mc.set_region(Rotor_Pocket_regions[1])"
    },
    {
        "objectID": "examples/adaptive_library/BezierCurveRotorPockets",
        "href": "examples/adaptive_library/BezierCurveRotorPockets.html#load-in-adaptive-templates-script-if-required",
        "title": "Bezier curve rotor pockets > Load in Adaptive Templates script if required",
        "section": "Load in Adaptive Templates script if required",
        "text": "When this script is run externally, the script executes the following:\nSet Geometry type to Adaptive.\nLoad the script into the Adaptive Templates tab.\nGo to the Geometry -> Radial tab to run the Adaptive Templates script and display the new\ngeometry.\nWhen running in a Jupyter Notebook, you must provide the path for the Adaptive Templates script\n(PY file) instead of sys.argv[0] when using the load_adaptive_script() method.\nTotal running time of the script: (0 minutes 57.142 seconds)\nDownload Jupyter notebook: BezierCurveRotorPockets.ipynb\nDownload Python source code: BezierCurveRotorPockets.py\nDownload zipped: BezierCurveRotorPockets.zip\nGallery generated by Sphinx-Gallery\nif not pymotorcad.is_running_in_internal_scripting():\n    mc.set_variable(\"GeometryTemplateType\", 1)\n    mc.load_adaptive_script(sys.argv[0])\n    mc.display_screen(\"Geometry;Radial\")"
    },
    {
        "objectID": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_weight_calculation",
        "href": "methods/_autosummary_Calculations/ansys.motorcad.core.motorcad_methods.MotorCAD.do_weight_calculation.html#do_weight_calculation",
        "title": "do_weight_calculation",
        "section": "do_weight_calculation",
        "text": "Run the Motor-CAD weight calculation."
    },
    {
        "objectID": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.subtract_region",
        "href": "methods/_autosummary_Adaptive Geometry/ansys.motorcad.core.motorcad_methods.MotorCAD.subtract_region.html#subtract_region",
        "title": "subtract_region",
        "section": "subtract_region",
        "text": "Subtract Motor-CAD region (region_subtract) from another Motor-CAD region (region).\nMotor-CAD region object\nMotor-CAD region object\nMotor-CAD region objects"
    },
    {
        "objectID": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.points",
        "href": "methods/_autosummary_geometry_methods/ansys.motorcad.core.geometry.Region.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Get points that exist in region."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetFEAGraphPoint",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.GetFEAGraphPoint.html#getfeagraphpoint",
        "title": "GetFEAGraphPoint",
        "section": "GetFEAGraphPoint",
        "text": "Deprecated function. Replaced by MotorCAD.get_fea_graph_point()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoSteadyStateAnalysis",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.DoSteadyStateAnalysis.html#dosteadystateanalysis",
        "title": "DoSteadyStateAnalysis",
        "section": "DoSteadyStateAnalysis",
        "text": "Deprecated function. Replaced by MotorCAD.do_steady_state_analysis()."
    },
    {
        "objectID": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Set3DComponentVisibility",
        "href": "methods/_autosummary/ansys.motorcad.core.motorcad_methods.MotorCADCompatibility.Set3DComponentVisibility.html#set3dcomponentvisibility",
        "title": "Set3DComponentVisibility",
        "section": "Set3DComponentVisibility",
        "text": "Deprecated function. Replaced by MotorCAD.set_3d_component_visibility()."
    }
]