
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\advanced\force_extraction.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_advanced_force_extraction.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_advanced_force_extraction.py:


.. _ref_force_extraction:

Motor-CAD force extraction example script
=========================================

This sets up the operating points and threading options for a force/NVH calculation,
then displays some key force orders from a 2d FFT that may be important for NVH.

.. GENERATED FROM PYTHON SOURCE LINES 35-36

Import PyMotorCAD and launch Motor-CAD, turning off pop-up messages.

.. GENERATED FROM PYTHON SOURCE LINES 36-41

.. code-block:: Python

    import ansys.motorcad.core as pymotorcad

    mc = pymotorcad.MotorCAD()
    mc.set_variable("MessageDisplayState", 2)








.. GENERATED FROM PYTHON SOURCE LINES 42-44

Load a baseline model - in this case a template.
For users, this would normally be a baseline model.

.. GENERATED FROM PYTHON SOURCE LINES 44-46

.. code-block:: Python

    mc.load_template("e9")








.. GENERATED FROM PYTHON SOURCE LINES 47-49

Set 90 torque points per cycle, which will give us information up to the 45th electrical order.
If using an induction motor, use `IMSingleLoadPointsPerCycle_Rotating` instead.

.. GENERATED FROM PYTHON SOURCE LINES 49-51

.. code-block:: Python

    mc.set_variable("TorquePointsPerCycle", 90)








.. GENERATED FROM PYTHON SOURCE LINES 52-53

Enable multithreading for the force/NVH calculation

.. GENERATED FROM PYTHON SOURCE LINES 53-55

.. code-block:: Python

    mc.set_variable("MultiForceThreading", 0)  # 0 is multithreaded, 1 is single threaded.








.. GENERATED FROM PYTHON SOURCE LINES 56-57

Set operating points, in this case for speed and torque definition.

.. GENERATED FROM PYTHON SOURCE LINES 57-73

.. code-block:: Python

    operating_points_speed = [250, 4000, 8000]  # RPM
    operating_points_torque = [250, 250, 100]  # Nm
    num_operating_points = len(operating_points_speed)

    # Make sure the table is the correct length before setting value
    mc.set_variable("NumLoadPoints", num_operating_points)

    # Set the values:
    for operating_point in range(num_operating_points):
        mc.set_array_variable(
            "LoadPoint_Speed_Array", operating_point, operating_points_speed[operating_point]
        )
        mc.set_array_variable(
            "LoadPoint_Torque_Array", operating_point, operating_points_torque[operating_point]
        )








.. GENERATED FROM PYTHON SOURCE LINES 74-83

.. note::
  For other motor types or options, the following may be needed:

  - All motor types and options: `LoadPoint_Speed_Array`
  - BPM or similar for torque based definition: `LoadPoint_Torque_Array`
  - BPM or similar for current/phase advance definition: `LoadPoint_Current_Array`,
  and `LoadPoint_PhaseAdvance_Array`
  - SRM: `LoadPoint_Current_Array`, `LoadPoint_OnAngle_Array`, and `LoadPoint_OffAngle_Array`
  - IM: `LoadPoint_Current_Array` and `LoadPoint_Slip_Array`

.. GENERATED FROM PYTHON SOURCE LINES 85-86

Run the electromagnetic FEA calculation, which calculates the forces.

.. GENERATED FROM PYTHON SOURCE LINES 86-88

.. code-block:: Python

    mc.do_multi_force_calculation()








.. GENERATED FROM PYTHON SOURCE LINES 89-94

Define the orders that we want to extract as space and time order pairs. In this case, these
are some of the important orders for a  48 slot, 8 pole motor.

The orders are defined as pairs of
[Space order (positive or negative), electrical time order (0 or positive)]:

.. GENERATED FROM PYTHON SOURCE LINES 94-96

.. code-block:: Python

    required_orders = [[0, 12], [0, 24], [8, 2], [-8, 10], [8, 14]]








.. GENERATED FROM PYTHON SOURCE LINES 97-98

Get information about the results.

.. GENERATED FROM PYTHON SOURCE LINES 98-116

.. code-block:: Python


    # Number of cycles. If using this for an induction motor, use
    # `IMSingleLoadNumberCycles_Rotating` instead
    electrical_cycles = mc.get_variable("TorqueNumberCycles")

    # Maximum number of space orders in results
    mech_force_space_order_max = mc.get_variable("ForceMaxOrder_Space_Stator_OL")

    # Number of operating points. In this example we have set this earlier in the script
    num_operating_points = mc.get_variable("NumLoadPoints")

    # Find how many slices (for skew) are available.
    if mc.get_variable("SkewType") == 2:
        # Stepped skew
        rotor_slices = mc.get_variable("RotorSkewSlices")
    else:
        rotor_slices = 1








.. GENERATED FROM PYTHON SOURCE LINES 117-118

Find the force density for each slice, at the different operating points and slices:

.. GENERATED FROM PYTHON SOURCE LINES 118-176

.. code-block:: Python

    for rotor_slice in range(rotor_slices):
        print("\nSlice " + str(rotor_slice + 1) + ":")
        for operating_point in range(num_operating_points):
            print("\nOperating point " + str(operating_point + 1) + ":")

            print(
                "Results as: Space order, "
                "Electrical order, "
                "Force density amplitude (N/m^2), "
                "Force density phase (deg):"
            )

            for required_order in required_orders:
                required_space_order = required_order[0]
                required_electrical_time_order = required_order[1]

                # Results stored with negative space orders at the end, so apply offset
                if required_space_order < 0:
                    raw_space_order = required_space_order + 2 * mech_force_space_order_max
                else:
                    raw_space_order = required_space_order

                # If more than one cycle used, scale between electrical orders and internal orders
                raw_time_order = required_electrical_time_order * electrical_cycles

                # Find the force density using GetMagnetic3DGraphPoint:
                # Note the use of _Th1 for the 1st operating point in the name.
                # Note also that rotor slice numbering starts at 1.
                _, force_density_amplitude = mc.get_magnetic_3d_graph_point(
                    "Fr_Density_Stator_FFT_Amplitude_OL" + "_Th" + str(operating_point + 1),
                    rotor_slice + 1,
                    raw_space_order,
                    raw_time_order,
                )

                _, force_density_angle = mc.get_magnetic_3d_graph_point(
                    "Fr_Density_Stator_FFT_Angle_OL" + "_Th" + str(operating_point + 1),
                    rotor_slice + 1,
                    raw_space_order,
                    raw_time_order,
                )

                # Apply 2x factor due to FFT symmetry, unless on the 0th time order (mean)
                # This is equivalent to showing results with 'Positive time only'
                if required_electrical_time_order > 0:
                    force_density_amplitude = force_density_amplitude * 2

                # Print the result. In a user workflow, this would usually be stored,
                # for example for use as an optimisation metric:
                print(
                    str(required_space_order)
                    + ",\t"
                    + str(required_electrical_time_order)
                    + ",\t"
                    + str(force_density_amplitude)
                    + ",\t"
                    + str(force_density_angle)
                )




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Slice 1:

    Operating point 1:
    Results as: Space order, Electrical order, Force density amplitude (N/m^2), Force density phase (deg):
    0,      12,     5310.15574966298,       -42.3352064437098
    0,      24,     450.396710004854,       -98.7354224813454
    8,      2,      202754.824033778,       132.263873186762
    -8,     10,     12708.14592440818,      -135.756495659978
    8,      14,     3724.03735016062,       85.2108472824288

    Operating point 2:
    Results as: Space order, Electrical order, Force density amplitude (N/m^2), Force density phase (deg):
    0,      12,     5345.11347041728,       -42.2247763223371
    0,      24,     450.250677513312,       -97.808195314424
    8,      2,      202471.362361518,       132.357781128915
    -8,     10,     12734.39429704806,      -135.535619334396
    8,      14,     3730.9396715235,        85.3956950545609

    Operating point 3:
    Results as: Space order, Electrical order, Force density amplitude (N/m^2), Force density phase (deg):
    0,      12,     2229.51963313022,       1.62425458619173
    0,      24,     502.873622818256,       -148.340980715189
    8,      2,      124383.445639281,       121.090198826699
    -8,     10,     6596.57424753416,       -139.510198138667
    8,      14,     805.037462505712,       86.8118859446881





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 35.459 seconds)


.. _sphx_glr_download_examples_advanced_force_extraction.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: force_extraction.ipynb <force_extraction.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: force_extraction.py <force_extraction.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: force_extraction.zip <force_extraction.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
